WEBVTT

1
00:00:01.137 --> 00:00:03.496
> > Jem Young: 现在我们要谈的是集装箱。
&gt;&gt; Jem Young: Now we're
gonna talk about containers.

2
00:00:03.496 --> 00:00:05.777
容器很迷人
Containers are fascinating.

3
00:00:05.777 --> 00:00:08.977
他们正在改变服务器的状况
They are changing
the landscape of servers and

4
00:00:08.977 --> 00:00:12.759
我们对建筑结构的思考方式
the way we think about how
to structure architecture.

5
00:00:12.759 --> 00:00:16.939
刚才我们说过建筑的问题比我们想象的要多
A little bit ago we talked about how the
architecture matters more than we think

6
00:00:16.939 --> 00:00:21.260
作为高级工程师，我们需要思考的是建筑。
and as senior engineers there something
we need to think about is architecture.

7
00:00:21.260 --> 00:00:24.503
作为高级的全堆工程师们，我们想仔细想想
And as senior full stack engineers,
we want to think carefully about how

8
00:00:24.503 --> 00:00:27.603
我们的应用程序是结构化的，就像他们在服务器上的生活一样。
our applications are structured,
as in how they live on the server.

9
00:00:27.603 --> 00:00:32.280
所以我们在讨论集装箱因为他们改变了
So we're talking about containers because
they have been changing the game across

10
00:00:32.280 --> 00:00:33.429
这条网景
the net landscape.

11
00:00:33.429 --> 00:00:34.999
让我们从一个微型服务开始。
Let's start with a micro service.

12
00:00:34.999 --> 00:00:39.719
有人对微型服务有什么好的定义，谁不是 Sam 。
Does anybody have a good definition,
who's not Sam, of a micro service.

13
00:00:39.719 --> 00:00:43.457
就像扔了它听起来像什么
Like throw it out What does it sound like?

14
00:00:43.457 --> 00:00:48.497
>> off 屏幕女性: 仅完成一个任务的服务 ?
&gt;&gt; off screen female: A service
that only completes one task?

15
00:00:48.497 --> 00:00:50.326
> > Jem Young: 是的，我喜欢
&gt;&gt; Jem Young: Yeah, I like that.

16
00:00:50.326 --> 00:00:53.482
这是一个很小很小的服务
It's a teeny tiny service.

17
00:00:53.482 --> 00:00:55.015
如果我们谈论微型服务
If we talk about microservices,

18
00:00:55.015 --> 00:00:57.924
我们谈论的是一种松散连接的服务架构。
we talk about an architecture
of loosely connected services.

19
00:00:57.924 --> 00:01:02.585
这是一种错误的错误因为仅仅因为它是一个微型服务
It's kind of a misnomer because
just because it's a microservice

20
00:01:02.585 --> 00:01:06.254
并不代表它很小巧轻便
doesn't mean it's really small and
lightweight.

21
00:01:06.254 --> 00:01:10.132
所以我喜欢你我喜欢你的定义只做一件事
So I like what you I like your definition
of its it only does one thing because

22
00:01:10.132 --> 00:01:12.674
那是对微型服务的更清晰的定义
that's a better definition
of a microservice.

23
00:01:12.674 --> 00:01:14.394
它只做一件事
It only does one thing.

24
00:01:14.394 --> 00:01:17.879
微服务架构的反面是什么 ?
What's the opposite of
micro service architecture?

25
00:01:17.879 --> 00:01:19.030
嗯。
Yes.

26
00:01:19.030 --> 00:01:19.716
> > 屏幕雌性: 巨石?
&gt;&gt; off screen female: A monolith?

27
00:01:19.716 --> 00:01:20.396
>> Jem Young: 单块。
&gt;&gt; Jem Young: A monolith.

28
00:01:20.396 --> 00:01:20.947
嗯。
Yes.

29
00:01:20.947 --> 00:01:23.527
这是一个能做一切的应用。
That is one app that does everything.

30
00:01:23.527 --> 00:01:27.924
历史上是 Java 应用程序或节点应用程序或
Historically that's been a Java
application or a node application or

31
00:01:27.924 --> 00:01:32.854
Python 和 Django，类似的，都是一个应用程序。
Python with Django, something like that,
where it's all one application.

32
00:01:32.854 --> 00:01:37.396
我们说要搬家的时候就有勾销
There are trade offs we make
when we talk about moving to

33
00:01:37.396 --> 00:01:40.365
微服务与巨石之间的关系
microservices versus a monolith.

34
00:01:40.365 --> 00:01:41.658
一个巨石的好处是
The good thing about a monolith is that.

35
00:01:41.658 --> 00:01:45.218
你都用同样的语言
You're all using the same language.

36
00:01:45.218 --> 00:01:47.819
所以如果你雇佣一堆 Python 人，我们都是在为 Python工作。
So if you hire a bunch of Python people,
we're all working in Python.

37
00:01:47.819 --> 00:01:49.485
他们不是分开的服务
They're not separate services.

38
00:01:49.485 --> 00:01:54.022
安全更新从 Python 2 迁移到 Python 3
Security updates moving,
migrating from Python two to Python three,

39
00:01:54.022 --> 00:01:55.843
你一次都能做到
you can do it all at one time.

40
00:01:55.843 --> 00:01:58.637
因为没有太多的空间，所以它能让维修变得更容易些
And it actually makes maintenance a little
bit easier because you don't have a lot of

41
00:01:58.637 --> 00:02:00.581
不同的语言和服务相互交谈。
disparate languages and
services talking to each other.

42
00:02:00.581 --> 00:02:01.810
这只是一个申请
It's just one application.

43
00:02:02.882 --> 00:02:04.789
>> Jem Young: 单块的下面是什么 ?
&gt;&gt; Jem Young: What is
the downside of a monolith?

44
00:02:07.233 --> 00:02:12.981
> > 屏幕雌性 : 更难改变和自动操作。
&gt;&gt; off screen female: It's just harder
to make changes and automate things.

45
00:02:12.981 --> 00:02:15.401
你必须立刻把一切都推过去
You have to push everything all at once.

46
00:02:15.401 --> 00:02:17.342
>> Jem Young: 是的。
&gt;&gt; Jem Young: Yeah.

47
00:02:17.342 --> 00:02:21.526
>> 屏幕上的男士: 你可以摆脱一切
&gt;&gt; off screen male: You can get
away from having everything

48
00:02:21.526 --> 00:02:25.715
与微服务松散耦合。
loosely coupled with microservices.

49
00:02:25.715 --> 00:02:30.891
你可以通过设计保证一切都独立。
You can kinda by design guarantee
that everything is independent.

50
00:02:30.891 --> 00:02:35.489
有了巨石你就可以变成一个
And with a monolith, you can fall
into the pattern of having one

51
00:02:35.489 --> 00:02:40.199
事物会影响到其他事物并紧密结合
thing affect multiple other things and
it's tightly coupled.

52
00:02:40.199 --> 00:02:43.515
你可以打碎东西，并产生意想不到的后果。
And you can break things and
have unintended consequences.

53
00:02:43.515 --> 00:02:45.635
> > Jem Young: 是的，你长的样子。
&gt;&gt; Jem Young: Yeah,
it's exactly what you look like.

54
00:02:45.635 --> 00:02:48.854
你宁愿有一帮比较容易维护的小房子吗
Would you rather have a bunch of tiny
houses that are easier to maintain?

55
00:02:48.854 --> 00:02:51.350
还是你宁愿有一栋巨大的建筑
Or would you rather have
one giant building?

56
00:02:51.350 --> 00:02:52.175
那得看情况了
It depends.

57
00:02:52.175 --> 00:02:55.198
我不是来告诉你的你有一个
I won't be here to tell you,
you've one or the other.

58
00:02:55.198 --> 00:02:58.277
我只是来告诉你不同类型的
I'm just here to tell you
about the different types,

59
00:02:58.277 --> 00:03:00.542
我不想把它政治化太多
I don't wanna politicize it too much.

60
00:03:00.542 --> 00:03:03.152
>> 禁用屏幕男性: 您谈到升级和
&gt;&gt; off screen male: You
talked about upgrades and

61
00:03:03.152 --> 00:03:06.921
保护你安全的东西
keeping you stuff upgraded for security.

62
00:03:06.921 --> 00:03:11.548
如果你要升级包就更难了
That's harder with the monolith
if you are upgrading packages,

63
00:03:11.548 --> 00:03:15.175
您必须在整个代码库中进行升级。
you have to upgrade it
across the entire code base.

64
00:03:15.175 --> 00:03:16.984
那就更难了不然就更难了
Versus little, or it can be harder.

65
00:03:16.984 --> 00:03:20.216
那得看情况了
It depends.

66
00:03:20.216 --> 00:03:21.740
>> Jem Young: 这要看情况。
&gt;&gt; Jem Young: It depends.

67
00:03:21.740 --> 00:03:25.009
所以是和不，不是一个尺码都适合
So yes and no, it's not a one size
fits all and anybody that says

68
00:03:25.009 --> 00:03:29.419
微服务比 monolith 更好， monolith 优于微服务。
microservices are better than monolith,
monolith's better than microservice.

69
00:03:29.419 --> 00:03:32.319
他们都错了因为这真的取决于你的申请
They're both wrong because it
really depends on your application,

70
00:03:32.319 --> 00:03:35.819
你的公司结构，你有什么类型的工程师，之类的。
how your company structured, what type
of engineers you have, things like that.

71
00:03:35.819 --> 00:03:40.313
就应用程序而言，是，升级微服务可能更容易
As far as applications go, yeah, it might
be easier to upgrade a microservice

72
00:03:40.313 --> 00:03:42.776
因为您可以一次升级一次。
because you can upgrade
them one at a time.

73
00:03:42.776 --> 00:03:45.229
但另一方面你要做的升级都要做
But at the other hand, you have all
the upgrades you have to do for

74
00:03:45.229 --> 00:03:46.379
每一个微型服务
every single microservice.

75
00:03:46.379 --> 00:03:48.396
您需要执行以下操作的所有安全补丁
You have all the security
patches you need to do for

76
00:03:48.396 --> 00:03:50.326
每个微服务与一座巨石之间的关系
every single microservice
versus a monolith.

77
00:03:50.326 --> 00:03:52.444
你做一次就在一起了
You do it one time and it's all together.

78
00:03:52.444 --> 00:03:55.635
它可能比较麻烦，但更容易做到一次。
It can be more cumbersome but
it's easier to do all at once.

79
00:03:55.635 --> 00:04:00.467
再一次，这个整个容器，微型服务的单块建筑，
So again, this whole container,
microservice monolith architecture,

80
00:04:00.467 --> 00:04:01.318
那得看情况了
it depends.

81
00:04:01.318 --> 00:04:04.364
它取决于用例，它取决于贵公司的构建。
It depends on use case,
it depends on your company's builds.

82
00:04:04.364 --> 00:04:09.078
但微型服务主要基于这个概念，现在称为容器，
But microservices are largely built on
this concept now called containers,

83
00:04:09.078 --> 00:04:11.334
我们会在第二个方面谈
which we'll talk about in a second.

84
00:04:11.334 --> 00:04:15.098
但我可以说一些微型服务，因为我在 Netflix工作。
But I can speak a little bit about
microservices because I work at Netflix.

85
00:04:15.098 --> 00:04:20.050
这不像，这是我们内部基础设施的一个例子。
This is not like, this is an example
of our internal infrastructure.

86
00:04:20.050 --> 00:04:22.600
但这些都是假名字
But these are fake names, obviously.

87
00:04:22.600 --> 00:04:28.495
如果你知道一艘游艇是什么，它就不会告诉你任何东西。
It wouldn't tell you anything,
if you knew what a field craft was.

88
00:04:28.495 --> 00:04:32.103
这很酷野外的手艺让我听起来像个间谍
That's pretty cool, field craft,
makes me sound like a spy.

89
00:04:32.103 --> 00:04:35.701
但 Netflix 是其中之一，我不会说其中一位领导人。
But Netflix is one of,
I won't say one of the leaders.

90
00:04:35.701 --> 00:04:38.048
这让我听起来像是在用自己的喇叭
It makes me sound like
I'm tooting my own horn.

91
00:04:38.048 --> 00:04:41.271
但我们是微型服务的 [LAUGH] 领导人之一。
But we are one of the [LAUGH]
leaders in microservices.

92
00:04:41.271 --> 00:04:45.591
我们都相信，这对我们的用例更有效。
It's something we all believe, that
it's more efficient for our use cases.

93
00:04:45.591 --> 00:04:48.122
例如，我在 UI 团队中工作。
For instance, I work on the UI team.

94
00:04:48.122 --> 00:04:51.300
所以我就住在这里
So I live about here.

95
00:04:51.300 --> 00:04:53.802
因为我不太在边缘
Because I'm not quite at the edge gateway.

96
00:04:53.802 --> 00:04:57.566
他是我们开放的源负载均衡器之一
That would be Zuul,
one of our open source Load balancers,

97
00:04:57.566 --> 00:04:59.612
代理，做很多事情。
proxies, does lots of things.

98
00:04:59.612 --> 00:05:02.086
这就来了我在这儿工作
That would be about here coming in and
I work about about here.

99
00:05:02.086 --> 00:05:04.899
所以我住的是 UI 层
So I live on the UI layer, but

100
00:05:04.899 --> 00:05:09.954
这就是高复杂度的高 [ LAUGH] 。
behind that is this high
[LAUGH] mess of complexity.

101
00:05:09.954 --> 00:05:14.266
但好事是我的团队在节点堆栈中运行 React 。
But the good thing is my team
runs React in a Node stack.

102
00:05:14.266 --> 00:05:19.639
其他人员运行 Java，其他人员运行 Groovy ，这是 Java 的风格。
Other people run Java, other people
run Groovy, which is a flavor of Java.

103
00:05:19.639 --> 00:05:23.420
其他人运行 PHP，有些人以 Python 运行。
Other people run PHP,
some people run in Python.

104
00:05:23.420 --> 00:05:25.685
但这些团队中的每一个都能维持自己的堆栈。
But every one of these teams
can maintain their own stack.

105
00:05:25.685 --> 00:05:29.432
只要我们坚持共同的 API ，你就可以为所欲为。
And as long as we maintain that common
API, you can kind of do whatever you want.

106
00:05:29.432 --> 00:05:32.707
这就是自由的责任。
It very much lives up to
that freedom responsibility.

107
00:05:32.707 --> 00:05:35.340
维护自己的堆栈，维护自己的体系结构。
You maintain your own stack,
you maintain your own architecture.

108
00:05:35.340 --> 00:05:39.226
如果你的团队就像世界上最伟大的鲁斯特程序员
And if your team is like the world's
greatest Rust programmers, write your

109
00:05:39.226 --> 00:05:43.555
在鲁斯特服役但我不需要知道它是怎么运作的
service in Rust, which will be really but
I don't need to know how it works.

110
00:05:43.555 --> 00:05:47.047
这就是微型服务架构的好处。
That's the benefit of
the microservice architecture.

111
00:05:47.047 --> 00:05:50.713
下面是这个复杂性，而不是这里的一个东西，
The downside is look at this
complexity instead of one thing here,

112
00:05:50.713 --> 00:05:53.598
就是这个巨大的 Java 应用或者类似的东西
which is this giant Java app or
something like that.

113
00:05:53.598 --> 00:05:56.620
我们有其他的应用需要相互沟通
We have all these other apps that
need to talk to each other and

114
00:05:56.620 --> 00:06:00.913
保持联系和类似的事情，我们用这个概念来做这个。
maintain connections and things like that,
and we do this with this concept called.

115
00:06:00.913 --> 00:06:02.704
一个容器
A container.

116
00:06:02.704 --> 00:06:04.733
你觉得集装箱是什么
Now what do you think a container is?

117
00:06:09.177 --> 00:06:10.163
>> Jem Young: 是。
&gt;&gt; Jem Young: Yes.

118
00:06:10.163 --> 00:06:14.557
>> 关闭屏幕男性: 这是在环境中对代码进行分区的方法
&gt;&gt; off screen male: It's a way of
partitioning your code in an environment

119
00:06:14.557 --> 00:06:19.915
它可以运行，只需要包含必需的组件。
that it can run in, with only
the necessary components included.

120
00:06:19.915 --> 00:06:25.106
> > Jem Young: 是的，我问你，还有点更难的问题。
&gt;&gt; Jem Young: Yes, so I'll ask you,
and even a bit harder question.

121
00:06:25.106 --> 00:06:29.949
容器和虚拟机有什么区别 ?
What's the difference between
a container and a virtual machine?

122
00:06:29.949 --> 00:06:34.978
>> off screen : 虚拟机是整个操作系统模拟机器。
&gt;&gt; off screen male: A virtual machine
is a whole OS simulating machine.

123
00:06:34.978 --> 00:06:36.867
容器可以减轻重量。
A container can be lighter weight.

124
00:06:38.668 --> 00:06:41.367
>> Jem Young: 正是这样，这才是正确的。
&gt;&gt; Jem Young: Precisely,
that's exactly right.

125
00:06:41.367 --> 00:06:44.223
虚拟机具有整个操作系统。
Virtual machines have
an entire operating system.

126
00:06:44.223 --> 00:06:46.822
在微型服务架构的旧日里
So in the old days of
the microservice architecture,

127
00:06:46.822 --> 00:06:49.899
我要像现在这样运行一个 Ubuntu 版本。
I would have to run a version of
Ubuntu like we're running now.

128
00:06:49.899 --> 00:06:51.685
然后我就会跑了
And then I'd run Node.

129
00:06:51.685 --> 00:06:54.941
如果我想为我的数据库再运行一次微型服务
And then if I wanna run another
microservice for my database,

130
00:06:54.941 --> 00:06:57.894
我会用另一个版本的 Node 来运行 Fedora 或 Ubuntu 。
I'd run Fedora or
Ubuntu with another version of Node.

131
00:06:57.894 --> 00:07:00.728
那是以前的日子
And that was the old days.

132
00:07:00.728 --> 00:07:04.865
这看起来挺不错的，你很喜欢，对，有点重。
That seemed pretty good, cuz you're like
well, yeah that's a little bit heavy.

133
00:07:04.865 --> 00:07:08.286
但至少现在每个服务都有自己的操作系统
But at least now every service
has its own operating system and

134
00:07:08.286 --> 00:07:11.521
然后，他们只能通过已知的 API 来与其他服务进行对话。
then they can only talk to
other services over known APIs.

135
00:07:11.521 --> 00:07:15.196
容器采用该概念，并触发更多信息。
Containers take that concept and
trigger down even more.

136
00:07:15.196 --> 00:07:17.625
而不是在操作系统上运行
Instead of running out
on an operating system,

137
00:07:17.625 --> 00:07:20.298
就像每个集装箱都有自己的操作系统
like every container has
its own operating system,

138
00:07:20.298 --> 00:07:24.509
我们只运行它所需要的一组库，而仅运行其他的库。
we just run just the set of libraries that
it needs, and only that, nothing else.

139
00:07:24.509 --> 00:07:26.882
这就是一个容器。
And that's what a container is.

140
00:07:26.882 --> 00:07:30.851
容器在当今的环境中强大，我们只能使用它们
Containers are powerful in the way that
they are today and we can only use them

141
00:07:30.851 --> 00:07:34.153
因为云计算和我们所取得的进步
because of cloud computing and
the advances that we've made.

142
00:07:34.153 --> 00:07:36.375
我们在管理程序上取得进展
We've made advances in the hypervisor,

143
00:07:36.375 --> 00:07:40.694
这就是控制其他进程的过程，以及它们之间的对话方式。
that is the process that controls other
processes, how they talk to each other.

144
00:07:40.694 --> 00:07:42.749
这就是我们现在的工作方式。
And that's how we're working right now.

145
00:07:42.749 --> 00:07:46.721
这就是我们的服务器运行和运行的方式，这是我们可以进行隔离处理的事实。
That's how our servers up and running, is
the fact that we can do process isolation.

146
00:07:46.721 --> 00:07:49.949
但我要在这小小的服务器上运行
But I'm running on this tiny,
tiny, tiny sliver of the server.

147
00:07:49.949 --> 00:07:54.005
老实说，你们都可以和我在同一个服务器上跑步，我不知道。
And honestly, you all can be running on
the same server as me, I have no idea.

148
00:07:54.005 --> 00:07:58.238
因为我们有流程隔离，系统管理程序很不错
Because we have process isolation and the
hypervisor is really good at segmenting

149
00:07:58.238 --> 00:08:00.031
我们的资源是一体的
our resources to one or the other.

150
00:08:00.031 --> 00:08:04.004
当我们建立在这个之上的时候，我们就有了这个容器的概念。
When we build on top of that,
we have this idea of containers.

151
00:08:04.004 --> 00:08:08.745
而不是 VPS ，我们可以放大甚至更多地放大
So instead of the VPS, we can zoom in
even more and we take that concept of

152
00:08:08.745 --> 00:08:12.935
一个服务器，我们把它细分为不同的部分。
a server and we just segment that
out into different sections.

153
00:08:12.935 --> 00:08:16.949
但每一节都只有它自己的图书馆，它拥有自己的资源。
But every section only has it's
own libraries, it's own resources.

154
00:08:16.949 --> 00:08:20.552
它不一定知道它所开启的操作系统。
It doesn't necessarily even know about
the operating system that it's on.

155
00:08:20.552 --> 00:08:21.574
它才不管呢
It doesn't care.

156
00:08:21.574 --> 00:08:25.519
这是包装器的内容，类似于编排层。
That's what the wrapper is for,
something like the orchestration layer.

157
00:08:25.519 --> 00:08:26.295
怎么了
Yes?

158
00:08:26.295 --> 00:08:29.307
> > 脱网男: 我想说，这有点像不同，但是
&gt;&gt; off screen male: I was gonna say,
it's kind of like the difference, but

159
00:08:29.307 --> 00:08:30.149
树在颤抖
tree shaking.

160
00:08:30.149 --> 00:08:34.466
其中您仅包含实际使用的功能，
Where you only include the functionality
that you actually use,

161
00:08:34.466 --> 00:08:37.067
包括整个图书馆
versus including the entire library.

162
00:08:37.067 --> 00:08:41.100
>> Jem Young: 是的，或者我喜欢说的是哥伦布的做法。
&gt;&gt; Jem Young: Yes exactly, or as I like
to say, the Columbo way of doing it.

163
00:08:41.100 --> 00:08:42.485
只是事实而已
Just the facts.

164
00:08:42.485 --> 00:08:44.552
这正是它需要的
It's just what it needs.

165
00:08:44.552 --> 00:08:47.515
所以不要把整个操作系统都包括在每一个
So rather than including an entire
operating system on every single

166
00:08:47.515 --> 00:08:50.385
应用程序，我们只包括它需要的库。
application, we'll just include
the libraries that it needs.

167
00:08:52.283 --> 00:08:53.027
>> Jem Young: 这是以前的日子。
&gt;&gt; Jem Young: This was the old days.

168
00:08:53.027 --> 00:08:54.663
这将是虚拟机。
This would be a virtual machine.

169
00:08:54.663 --> 00:08:57.197
这可能是我们的服务器
This could be our server.

170
00:08:57.197 --> 00:08:59.162
其实现在离我们的服务器很近
Actually it's pretty close
to our server right now.

171
00:08:59.162 --> 00:09:02.077
我们有 NodeJS 正在运行 Nginx 正在运行
We have NodeJS running,
we have Nginx running.

172
00:09:02.077 --> 00:09:05.429
稍后，我将了解如何安装 MySQL。
We later I'll go over
how to install MySQL.

173
00:09:05.429 --> 00:09:07.940
不会太多，但我们可以运行 Python。
Won't do too much with it,
but we can run Python.

174
00:09:07.940 --> 00:09:10.434
这是以前的做法。
This was the old way of doing it.

175
00:09:10.434 --> 00:09:11.958
容器是这样的。
Containers are something like this.

176
00:09:11.958 --> 00:09:13.730
它还是一台服务器。
It's still one server.

177
00:09:13.730 --> 00:09:17.182
但现在它是它自己的微型服务器。
But now this is kind of
its own micro server.

178
00:09:17.182 --> 00:09:22.312
并且 MySQL 数据库未在其自己的微型服务器， Nginx等上运行。
And the MySQL database isn't running on
its own microserver, Nginx, etc., etc.

179
00:09:22.312 --> 00:09:24.943
他们只拥有他们需要的图书馆。
And they only have
the libraries that they need.

180
00:09:24.943 --> 00:09:26.986
为甚么会有这种好处呢 ?
Why is this beneficial?

181
00:09:26.986 --> 00:09:29.937
比如这事的威力
Like what's powerful about this.

182
00:09:29.937 --> 00:09:35.019
我们现在没有在每个应用程序上运行整个操作系统，但是
We're not running an entire operating
system on every single application now but

183
00:09:35.019 --> 00:09:38.040
我们还能做些什么
what's something we can
do even more when we're

184
00:09:38.040 --> 00:09:41.150
控制单个容器本身。
controlling the individual
containers itself.

185
00:09:41.150 --> 00:09:43.187
>> off screen male: 运行其中的几个。
&gt;&gt; off screen male: Run several of them.

186
00:09:43.187 --> 00:09:44.481
几份
Several copies.

187
00:09:44.481 --> 00:09:48.403
> > Jem Young: 是的，你可以，但我们也能做虚拟机。
&gt;&gt; Jem Young: Yeah no, you can, but
we can do that virtual machines too.

188
00:09:48.403 --> 00:09:50.094
但你在正确的轨道上
But you're on the right track.

189
00:09:50.094 --> 00:09:51.197
还有别的吗
What else?

190
00:09:53.296 --> 00:09:54.511
>> Jem Young: 他们是。
&gt;&gt; Jem Young: They are.

191
00:09:54.511 --> 00:09:56.110
是的，速度更快。
Yes, they are faster.

192
00:09:56.110 --> 00:10:01.389
但是当我们想到集装箱的时候，我们大概没有想到一个好处
But there's one benefit we probably don't
think of when we think of containers

193
00:10:01.389 --> 00:10:02.725
>> 屏幕阳性 : 静态分析。
&gt;&gt; off screen male: Static analysis.

194
00:10:05.336 --> 00:10:09.464
>> Jem Young: 不，你的意思是什么 ?
&gt;&gt; Jem Young: No,
what do you mean by that?

195
00:10:09.464 --> 00:10:14.647
>> 禁用屏幕男性: 静态分析允许您通过图形跟踪
&gt;&gt; off screen male: Static analysis allows
you to trace through the graph of what

196
00:10:14.647 --> 00:10:20.859
依赖树是并确定要包含的内容，要包括的内容。
the dependency tree is and figure out
what to include, what to exclude.

197
00:10:20.859 --> 00:10:26.059
不仅减少了资源，也减少了内存。
Reduces not just resources,
in terms of processing but also memory.

198
00:10:26.059 --> 00:10:29.333
>> Jem Young: 是的。
&gt;&gt; Jem Young: Yeah.

199
00:10:29.333 --> 00:10:34.248
更进一步，如果我们知道，因为你是绝对正确的。
Take that idea further, if we know,
because you're you're absolutely right.

200
00:10:34.248 --> 00:10:38.879
我不知道我是否称它为静态分析，但对每一个数据的分析
I don't know if I call it static analysis
as much but the analysis of what every

201
00:10:38.879 --> 00:10:43.296
单一的应用是在做而不是作为一个整体，我必须要运行我的负载，
single application is doing rather than
as a whole, I have to run my load,

202
00:10:43.296 --> 00:10:45.648
运行 topper 其他命令以查看类似的情况，
run topper other commands to see like,

203
00:10:45.648 --> 00:10:49.594
究竟是什么容器在做什么，或者一个过程正在做什么。
what exactly what containers doing,
or what a process is doing.

204
00:10:49.594 --> 00:10:50.883
当我把它装在容器里的时候
When I have it in container.

205
00:10:50.883 --> 00:10:52.845
我知道它在干什么
I know precisely what it's doing.

206
00:10:52.845 --> 00:10:56.710
通过这样做，我可以限制
And by doing that I can limit
the amount of resources that have given

207
00:10:56.710 --> 00:11:00.311
容器有，我可以向上扩展和缩小的速度更快。
container has, and I can scale up and
scale down much faster.

208
00:11:00.311 --> 00:11:06.677
例如，如果我运行 Python Web 服务器，那么它将被阻塞。
For instance, if I run a Python
web server it's gonna be blocking.

209
00:11:06.677 --> 00:11:10.956
我们之前谈到了拦截请求，如果我请求一个真正慢的数据库
We talked about blocking request earlier,
where if I request a really slow database

210
00:11:10.956 --> 00:11:15.052
或者类似的问题它会阻塞所有其他的请求
query or something like that, it's gonna
block all the other requests coming in

211
00:11:15.052 --> 00:11:19.296
除非我有一些合用的东西但那将会拖慢一切
unless I have some sort of pooling enabled
but that'll slow down everything else.

212
00:11:19.296 --> 00:11:23.115
但如果我想限制 Python 可以使用的资源呢 ?
But what if I want to just limit
the resources that Python can use?

213
00:11:23.115 --> 00:11:25.408
我想把它们分配给节点或者类似的东西。
And I want to allocate them in Node or
something like that.

214
00:11:25.408 --> 00:11:29.371
我可以更严格地控制在我的服务器上发生的事情。
I can more tightly control
what's happening on my server.

215
00:11:29.371 --> 00:11:34.653
既然它是自己的服务器，我可以控制它。
And since it's kind of its own server
in a way, and I can control that.

216
00:11:34.653 --> 00:11:37.780
这真的很强大。
And that's really, really powerful.

217
00:11:37.780 --> 00:11:42.788
而这一权力的一部分，我将会谈论更多的容器，
And part of that power, I'll talk about
the benefits even more of containers,

218
00:11:42.788 --> 00:11:47.717
但这权力的一部分就像你们都说的那样你可以把它滚出去
but part of that power is like you all
were saying, you can roll these out much,

219
00:11:47.717 --> 00:11:48.628
速度更快
much faster.

220
00:11:48.628 --> 00:11:52.466
启动时间更快，因为我没有启动整个操作
The startup time is much faster because
I'm not starting an entire operating

221
00:11:52.466 --> 00:11:54.129
系统，我必须安装。
system, that I have to install.

222
00:11:54.129 --> 00:11:55.907
我需要执行无人照管的升级。
I need to run unattended upgrades.

223
00:11:55.907 --> 00:11:59.899
我需要在每台服务器和所有这些东西上安装 Nginx 。
I need to install Nginx on every
single server and all these things.

224
00:11:59.899 --> 00:12:03.078
我可以做图书馆，我可以在一段时间内分发。
I can just run the library, and
I can distribute these over time.

225
00:12:03.078 --> 00:12:06.806
另一个好处是我可以更新我的节点应用程序，
The other benefit is I can make
updates to my node application,

226
00:12:06.806 --> 00:12:11.184
我的 Python 应用程序，甚至不知道它的其他服务。
my Python application without the other
services even knowing about it.

227
00:12:11.184 --> 00:12:14.903
因此，我可以控制单个转出，而不是转出整个服务器
So I can control the individual rollouts
rather than rolling out entire servers

228
00:12:14.903 --> 00:12:17.134
花了很多时间才能上到下
which take a lot of time to take up and
take down.

229
00:12:19.433 --> 00:12:22.822
> > Jem Young: 我们已经获得了一些好处，但它们很轻。
&gt;&gt; Jem Young: And we hit on some of the
benefits already but they're lightweight.

230
00:12:22.822 --> 00:12:24.258
这只是事实
It's just the facts.

231
00:12:24.258 --> 00:12:25.847
它只是它需要的东西。
It's only the things that it needs.

232
00:12:25.847 --> 00:12:26.974
他们是便携的
They're portable.

233
00:12:26.974 --> 00:12:30.254
在这种情况下，我可以创建节点应用程序，
In that case,
I can create a Node application,

234
00:12:30.254 --> 00:12:33.538
把它装在容器里放在我想要的任何地方
wrap it in container and
put it anywhere I want.

235
00:12:33.538 --> 00:12:37.337
不管操作系统是什么，不管它是什么，
And it doesn't matter what the operating
system is that point, it doesn't care,

236
00:12:37.337 --> 00:12:41.207
因为有一个层处理与操作系统的交互。
because there's a layer that handles that
interaction with the operating system.

237
00:12:41.207 --> 00:12:44.576
所以如果我想，我可以写 Node 应用程序，在 Windows 上运行，运行
So if I want, I can write a Node
application, run it on Windows, run it on

238
00:12:44.576 --> 00:12:48.169
我的 Mac 电脑然后在 Ubuntu 上运行它也会运行
my Mac computer and then run it on Ubuntu,
and it's all going to run the same,

239
00:12:48.169 --> 00:12:51.854
与虚拟机非常相似，但没有操作系统开销。
very similar to a virtual machine but
without the operating system overhead.

240
00:12:51.854 --> 00:12:56.635
坦白说，微型服务的发展更容易，因为它不是巨石。
Honestly, microservices are easier for
development because it's not a monolith.

241
00:12:56.635 --> 00:13:00.662
应用程序是，但就像你说的，安娜，它只做一件事。
The application is, but like you're
saying, Anna, it only does one thing.

242
00:13:00.662 --> 00:13:02.034
而且它也做得很好。
And it does one thing well.

243
00:13:02.034 --> 00:13:04.697
这就说明了发生了什么更简单的事情。
That makes reasoning about
what's happening much simpler.

244
00:13:04.697 --> 00:13:06.580
他们更容易管理
They're easier to manage.

245
00:13:06.580 --> 00:13:08.734
我应该给你个星号
I should put an asterisk by this.

246
00:13:08.734 --> 00:13:13.442
正如您之前看到的那样， >> Jem Young: 更容易
As you saw before with the,
&gt;&gt; Jem Young: Easier to

247
00:13:13.442 --> 00:13:15.418
管理是完全相对的。
manage is totally relative.

248
00:13:15.418 --> 00:13:20.302
有人会说，在一个大的教派里，这个比较难管理，我说的比较容易
Some might say this is harder to manage in
one big sect I might say it's easier to

249
00:13:20.302 --> 00:13:20.895
管理。
manage.

250
00:13:20.895 --> 00:13:24.173
因为他们比较容易管理因为它只做一件事
In mind they're easier to manage
because it's only doing one thing and

251
00:13:24.173 --> 00:13:27.886
这道理很合理他们肯定会更快地
that makes rational sense and they're
certain times it's gonna much faster cuz

252
00:13:27.886 --> 00:13:29.816
就不会有什么靴子了
there is no boot up time anymore certain.

253
00:13:29.816 --> 00:13:33.928
完全是 [INAUDIBLE] 把一些文件复制到运行。
It's just literally [INAUDIBLE] just
copying some files over and hitting run.

254
00:13:33.928 --> 00:13:37.572
它真正做的是将应用程序与基础架构分离。
And what it really does is decouples
the application from the infrastructure.

255
00:13:37.572 --> 00:13:42.226
切换到 Ubuntu 20 还是 Fedora ， Red Hat ， Debian 或者 Debian
It doesn't matter if we switch to Ubuntu
20 or Fedora or Red Hat or Debian or

256
00:13:42.226 --> 00:13:43.625
就像这样
something like that.

257
00:13:43.625 --> 00:13:47.525
应用程序不重要，我作为一个开发者，我不在乎。
The application doesn't matter and
me as a developer, I don't care.

258
00:13:47.525 --> 00:13:50.668
反正不影响我的申请，因为有
It doesn't affect my application
anyway because there's

259
00:13:50.668 --> 00:13:52.495
一个能推断出的层
a layer that does that inferring.

260
00:13:52.495 --> 00:13:56.918
这个解释容器我发现有些人喜欢把它们挂在他们的位置上
That explain containers I find people like
get hung up a little bit on them, and

261
00:13:56.918 --> 00:14:01.421
他们把它们与虚拟机和类似的虚拟机以及所有这些东西混淆
they confuse them with virtual machines
and like monoliths and all that stuff.
