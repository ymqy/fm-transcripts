WEBVTT

1
00:00:00.780 --> 00:00:06.040
威尔 · 森塔斯: 好吧，我们来谈谈
&gt;&gt; Will Sentance: All right,
so let's talk about what

2
00:00:06.040 --> 00:00:11.400
这个背包叫做，因为我想我们都同意。
this backpack is called,
because I think we can all agree.

3
00:00:11.400 --> 00:00:15.240
顺便说一下，自从我们赢了以后，事情已经发生了变化。
This is an ever by the way,
things have changed since we won.

4
00:00:15.240 --> 00:00:18.039
这位女士的名字背包被炸飞了
This lady's name backpack
has been blowing up

5
00:00:18.039 --> 00:00:21.699
有人给我买了一件 t 恤，背面有个背包。
somebody's got me a T shirt with
a backpack on the back of it.

6
00:00:21.699 --> 00:00:26.550
我认为这构成了巨大的爆炸。
I count that as constituting
blowing up huge.

7
00:00:26.550 --> 00:00:30.789
确实有一件 t 恤。
There is one t shirt, exactly.

8
00:00:32.259 --> 00:00:39.649
但是，现在有一个博客贴出了最受欢迎的关闭博客帖子。
But also, there is now a blog post
the most popular blog posts on closure.

9
00:00:39.649 --> 00:00:41.170
由《卫报》和《纽约时报》撰稿。
Outlet written by the Guardian and
New York Times.

10
00:00:41.170 --> 00:00:43.890
工程经理纽约时报你来到了困难的部分，酷。
Engineering manager New York Times
you came to hard part's, cool.

11
00:00:43.890 --> 00:00:45.950
我一直不明白什么叫了结直到我想到了这个,
I never understood closure
until I thought about this way,

12
00:00:45.950 --> 00:00:50.500
通过这种方式，他提到了那个背包14次。
learnt about this way, in which he
referred to the backpack, 14 times.

13
00:00:50.500 --> 00:00:54.320
没错，14 / 15毫米宽，没错。
Yeah, exactly, wow,
14/15 millimeter wide, exactly.

14
00:00:54.320 --> 00:00:57.479
这就是现实变得多么真实。
That's how real is becoming.

15
00:00:57.479 --> 00:00:59.548
我们正在游说规格制造商。
We're lobbying the spec makers.

16
00:00:59.548 --> 00:01:03.140
演讲者2: (笑)威尔 · 森塔斯: 显然不是但是
&gt;&gt; Speaker 2: [LAUGH]
&gt;&gt; Will Sentance: And obviously not but

17
00:01:03.140 --> 00:01:06.099
我想你们都没听说过
I don't think any of you heard of, and

18
00:01:06.099 --> 00:01:11.109
当然还有人听说过，不过有个好听的名字。
certainly another heard of it,
but there is a fancy name for it.

19
00:01:11.109 --> 00:01:13.719
开发人员对它有一个通俗的称呼。
There is a colloquial name
used by developers for it.

20
00:01:13.719 --> 00:01:17.980
我只是不喜欢存在的原因是我认为它是模糊和不精确的。
I just don't love the reason being
is I think it's vague and imprecise.

21
00:01:17.980 --> 00:01:23.150
它指的是两者的整体概念，他们也称之为背包。
It refers to both of the overall concept,
and they call the backpack this as well.

22
00:01:23.150 --> 00:01:24.789
所以这些是，让我把它说得更好。
So these are, let me put that better.

23
00:01:24.789 --> 00:01:28.989
它们指的是导致背包存在和
They refer to the thing that results
in the backpack existing and

24
00:01:28.989 --> 00:01:31.710
他们把背包叫做同样的伞形术语。
they call the backpack all
this same umbrella term.

25
00:01:31.710 --> 00:01:33.840
我认为这是一个有点模糊和混乱。
I think that is a bit vague and confusing.

26
00:01:33.840 --> 00:01:36.960
所以我要给我们的背包起一些好听的名字
So I'm gonna give us some fancy names for
the backpack and

27
00:01:36.960 --> 00:01:38.409
那为什么我们有背包。
then why we have the backpack.

28
00:01:39.420 --> 00:01:44.242
那么名字呢，我之前已经告诉过你们了
So first name, well I already told
you earlier on that people pool

29
00:01:44.242 --> 00:01:48.552
他们的局部记忆有时变化的环境。
their local memory sometimes
the variable environment.

30
00:01:48.552 --> 00:01:52.941
作为一个才华横溢的开发者，我认为谁有一本精彩的书，实际上我
As a brilliant I think developer out there
who's a wonderful book actually which I

31
00:01:52.941 --> 00:01:55.802
强烈推荐朋友喜欢一个聪明，但
highly recommend for
friends known as like a smart but

32
00:01:55.802 --> 00:01:58.299
不像一本书，让我做笔记。
isn't like a book like let me take notes.

33
00:01:58.299 --> 00:02:02.859
这就是所谓的如果海明威写 Javascript。
This is called
If Hemingway Wrote Javascript.

34
00:02:02.859 --> 00:02:06.650
是的，我认为这是一本完美的礼品书，我实际上买了十本。
Yeah, I think it's a perfect gift book,
I bought ten copies actually.

35
00:02:06.650 --> 00:02:11.539
它没有暗示太多关于-无论如何，我得到了他们为
It doesn't suggest much about the- anyway,
I got them for

36
00:02:11.539 --> 00:02:15.520
史密斯代码的人我觉得这是最糟糕的圣诞礼物了,
Code Smith people, I think, it's gotta
be the worst Christmas gift ever,

37
00:02:15.520 --> 00:02:17.579
没错，你会得到一本《当海明威写作时》。
right, you're getting a copy
of When Hemingway Wrote.

38
00:02:17.579 --> 00:02:20.659
所以如果我读海明威写的由 Gaga Angus Crow 编写的 JavaScript,
So if I read, Hemingway wrote
JavaScript by Gaga Angus Crow,

39
00:02:20.659 --> 00:02:25.079
他非常喜欢这个，他称之为基本上他只需要一小段代码
a big fan of it, he calls this is
basically he takes little snippets of code

40
00:02:25.079 --> 00:02:29.719
就像斐波那契序列一样，并以著名作家的风格写在网站上。
like Fibonacci sequence and writes them in
the site in the style of famous writers.

41
00:02:29.719 --> 00:02:34.579
所以海明威的很简洁，纳博科夫的我不知道，我没有读过,
So Hemingway's is very terse,
Nabokov's I don't know, I didn't read it,

42
00:02:34.579 --> 00:02:36.409
但我不知道该说什么。
but I don't know what to say.

43
00:02:36.409 --> 00:02:42.066
但是，威尔 · 森坦斯: 他把这个叫做背包,
But so,
&gt;&gt; Will Sentance: He calls this backpack,

44
00:02:42.066 --> 00:02:45.949
他称之为结案陈词。
he calls it the closed over.

45
00:02:45.949 --> 00:02:51.810
也就是说，我们关闭了这里的数据，关闭了变量环境。
That is to say we close a lid on this data
here, closed over variable environment.

46
00:02:51.810 --> 00:02:53.240
也就是说，我们把可变的环境,
That is to say,
we take the variable environment,

47
00:02:53.240 --> 00:02:55.129
盖上盖子，然后拔出来。
kinda close a lid on it, and pull it out.

48
00:02:55.129 --> 00:02:59.442
好的，他称之为曲线，结束
Okay, so he calls it the curve,
closed over

49
00:02:59.442 --> 00:03:04.486
变量环境代码，不是个坏名字。
variable environment code,
not a bad name for it.

50
00:03:04.486 --> 00:03:09.210
我想我喜欢它，这里有一个我很喜欢的名字。
I guess I like it,
now here's a name I quite like for it.

51
00:03:09.210 --> 00:03:13.532
我想这就是我所说的，如果你可以说你保证会成为一名高年级学生
I think this is the one that I said if
you can say you're guaranteed a senior

52
00:03:13.532 --> 00:03:14.528
开发人员的工作。
developer job.

53
00:03:14.528 --> 00:03:17.072
显然我得收回那句话。
I have to take that back obviously.

54
00:03:17.072 --> 00:03:20.826
所以听到这个名字，这是很好的,
So hear the name, that it is nice,

55
00:03:20.826 --> 00:03:25.069
这表明了我们对。
it shows a depth to understanding.

56
00:03:25.069 --> 00:03:28.740
所以这里的数据是持久的。
So this data here is persistent.

57
00:03:30.579 --> 00:03:32.969
对，它一直存在，不像常规的数据被删除,
Right, it sticks around, it's not like
the regular data that gets deleted,

58
00:03:32.969 --> 00:03:33.789
这是持久的。
it's persistent.

59
00:03:35.090 --> 00:03:37.189
这是数据，好吧，d 代表数据。
It's data, okay, d for data.

60
00:03:39.719 --> 00:03:42.250
它被引用了，被链接了
It's referenced, it's linked

61
00:03:44.490 --> 00:03:50.009
由 scope 属性引用，好的。
referenced by a scope property, okay.

62
00:03:50.009 --> 00:03:51.840
什么是范围？
What is scope?

63
00:03:51.840 --> 00:03:55.889
范围是任何编程语言的规则。
Scope is the rules in any
programming language.

64
00:03:55.889 --> 00:04:01.189
对于任何给定的代码行，我有什么数据可用？
For at any given line of code,
what data do I have available to me?

65
00:04:01.189 --> 00:04:04.780
所以如果我每天都在这条线上如果我在这条线上,
So if I'm in this line every day as
this is it, if I'm in this line,

66
00:04:04.780 --> 00:04:07.909
我可以通过某种方式访问这些数据，还有这些数据。
somehow I have access to this data,
and this data.

67
00:04:07.909 --> 00:04:11.520
范围是什么数据和规则是什么的花哨词汇
Scope is the fancy word for
what data and what are the rules for

68
00:04:11.520 --> 00:04:14.580
但是我们假设如果我运行一个函数。
but we assume that if I
run a function like outer.

69
00:04:14.580 --> 00:04:18.622
如果我们没有发现内部数据和 global 有联系，为什么？
in global that if we don't find data
inside out to be connected to global, why?

70
00:04:18.622 --> 00:04:22.706
这不像是由开发人员决定的编程语言所固有的
That's not like inherent in a programming
language that was decided by the developer

71
00:04:22.706 --> 00:04:26.807
当他们决定给定语言的范围规则时。
of the language, when they're deciding the
rules of scope for that given language.

72
00:04:26.807 --> 00:04:30.745
在我的运行中的任何给定行对我可用的数据的规则
The rules of what data is available to
me at any given line in my running of

73
00:04:30.745 --> 00:04:31.769
我的密码。
my code.

74
00:04:31.769 --> 00:04:34.360
你可以想象一种语言里面没有可用的新数据
You can imagine a language says
no new data available inside that

75
00:04:34.360 --> 00:04:35.149
功能，就是这个。
function, that's it.

76
00:04:36.730 --> 00:04:38.279
呼叫所有的地区语言
Beep every regional language and

77
00:04:38.279 --> 00:04:43.500
作用域规则是只保护函数本身内部的数据。
the scoping rule would be protecting
the data only inside the function itself.

78
00:04:43.500 --> 00:04:44.699
你不能访问那些函数数据。
You don't have access
to that functions data.

79
00:04:44.699 --> 00:04:46.670
也就是说，语言是范围规则。
That would be that language is scope rule.

80
00:04:47.889 --> 00:04:51.939
这是 JavaScript 语言有一个非常特殊的作用域规则。
This the language of JavaScript
has a very particular scope rule.

81
00:04:52.990 --> 00:04:54.959
它的范围规则是。
Its scope rule is.

82
00:04:54.959 --> 00:04:58.439
所谓的词法范围或静态范围。
What's called lexical or static scoping.

83
00:04:58.439 --> 00:05:03.670
也就是说，我保存我的功能的地方
That is to say that
where I save my function

84
00:05:03.670 --> 00:05:08.560
决定了其余的生命，决定了其功能的生命。
determines for the rest of that life,
for the life of that function.

85
00:05:08.560 --> 00:05:12.350
无论它以何种新标签运行,
Whenever it gets run under
whatever new label it gets,

86
00:05:12.350 --> 00:05:16.670
当这个函数运行时，它能访问哪些数据。
what data it will have access
to when that function runs.

87
00:05:16.670 --> 00:05:17.629
不是我经营的地方。
Is not where I run it.

88
00:05:17.629 --> 00:05:20.850
这就是所谓的动态范围。
That would be called dynamic scoping.

89
00:05:20.850 --> 00:05:23.610
它会根据我运行函数的位置而变化。
It changes depending on
where I run the function.

90
00:05:23.610 --> 00:05:26.819
如果我要动态地调用语言，我会运行我的新函数和
If I were to dynamically scope language,
I'd run my new functioning and

91
00:05:26.819 --> 00:05:29.949
我会直接向下看全球，不会发现计数器就是它。
I'd look straight down to global,
wouldn't find counter that was it.

92
00:05:29.949 --> 00:05:33.180
是一种静态的或者词汇范围限定的语言。
JavaScript is a static or
lexically scoped language.

93
00:05:33.180 --> 00:05:35.550
词汇是指页面上的物理位置。
Lexical means the physical
positioning on the page.

94
00:05:35.550 --> 00:05:38.649
我物理上把它放在外部的运行中。
I physically position this
inside the running of outer.

95
00:05:38.649 --> 00:05:41.029
是一种静态的词汇范围语言。
Is a lexical statically scope language.

96
00:05:41.029 --> 00:05:44.889
这意味着即使我返回我的函数，并且
That means that even if I
returned my function out, and

97
00:05:44.889 --> 00:05:46.699
理论上所有的数据都应该被删除。
theoretically all this data
should have been deleted.

98
00:05:46.699 --> 00:05:52.430
不，因为我有这个词汇范围语言的基本规则。
Nope, because I have this fundamental
rule of lexically scoped language.

99
00:05:52.430 --> 00:05:54.680
我得把幕后的数据都拿来
I'm gonna have to grab all that
data behind the scenes and

100
00:05:54.680 --> 00:05:56.740
放在背包上。
put it out on the backpack.

101
00:05:56.740 --> 00:06:00.569
这样，当我运行函数时，我仍然拥有上次作用域时的所有数据。
Such that when I run the function, I still
have all the data from when I last scope.

102
00:06:00.569 --> 00:06:03.490
不是因为我回到了之前的执行环境。
Not because I go back into
the earlier execution context, uh-uh.

103
00:06:03.490 --> 00:06:04.800
我要回到外层去。
I'm going back up into outer.

104
00:06:04.800 --> 00:06:09.029
我不需要这样做---- 我从 incrementCounter 函数出现的时候提取了数据
I didn't have to, I pulled the data from
when the function incrementCounter was

105
00:06:09.029 --> 00:06:12.930
我的词汇范围属性。
born out with me on my
lexical scope property.

106
00:06:12.930 --> 00:06:15.139
在幕后，我把数据拿出来
Behind the scenes I
pulled the data out and

107
00:06:15.139 --> 00:06:18.689
把它和我的新功能连在一起。
left it attached to now my new function.

108
00:06:18.689 --> 00:06:20.300
这是一种词汇范围的语言。
It's a lexically scoped language.

109
00:06:21.480 --> 00:06:25.410
持久的词法或静态范围引用数据。
Persistent lexically or
static scope reference data.

110
00:06:25.410 --> 00:06:28.360
所以特殊类型的作用域，即词法作用域，具有静态作用域规则
So special type of scope, the lexical
scope, with static scoping rule

111
00:06:28.360 --> 00:06:32.290
也就是说，我们把函数诞生时的数据带来了。
which means we literally bring the data
with us from when the function was born.

112
00:06:32.290 --> 00:06:36.920
因为我们的规则是我的函数保存在哪里决定
Because our rule is where my
function was saved determines

113
00:06:36.920 --> 00:06:41.379
我能访问哪些数据，什么时候最终运行，不管它在哪里。
what data I have access to, when it's
eventually run, wherever that may be.

114
00:06:42.459 --> 00:06:46.879
这里是持久化的词法静态范围引用数据。
And there it is persistent lexical
static scope reference data.

115
00:06:46.879 --> 00:06:54.944
你们可以看到这就是为什么我叫它背包，看看这个美丽的名字。
And you can see that's why I call it the
back pack, look at that beautiful name.

116
00:06:54.944 --> 00:06:58.016
威尔 · 森塔斯: 但是在工业界，他们倾向于使用
&gt;&gt; Will Sentance: But
in industry they tend to use

117
00:06:58.016 --> 00:07:03.220
Kayla 之前给我们的口语词。
the colloquial term that
Kayla gave us earlier.

118
00:07:03.220 --> 00:07:09.740
也就是说，把数据放到函数的闭包中。
Which is they say,
put the data in the function's closure.

119
00:07:09.740 --> 00:07:13.779
我对这个术语的看法是，它的整体概念很酷
My problem with that term is a cool
the overall concept, the notion of

120
00:07:13.779 --> 00:07:18.189
他们称之为结束，然后他们称之为背包结束。
lexical scoping and they call that closure
and then they call the backpack closure.

121
00:07:18.189 --> 00:07:21.750
这是由于 JavaScript 是一个词典范围的结果
It's the backpack as a result of
JavaScript being a lexically scoped

122
00:07:21.750 --> 00:07:26.600
语言，一个把数据和函数一起带到函数所到之处的语言,
language, one that brings the data with
the function wherever that function goes,

123
00:07:27.759 --> 00:07:30.459
藏在望远镜里，藏在背包里。
hidden on the scope property,
hidden on the backpack.

124
00:07:30.459 --> 00:07:33.079
这意味着如果你在房间里保存一个函数，另一个函数。
Meaning that if you save a function
inside the room another function.

125
00:07:33.079 --> 00:07:35.909
当它退出的时候，这些都应该被删除，不。
When it exits,
that should all be deleted, nope.

126
00:07:35.909 --> 00:07:39.300
但是把这些数据放在背包里所以当我们运行这个功能时,
But bringing that data with us on
the backpack so when we run that function,

127
00:07:39.300 --> 00:07:43.000
它仍然可以访问背包里的持久数据。
it still has access to that
persistent data from its backpack.

128
00:07:45.029 --> 00:07:47.014
我们走吧，我们还没有完全结束。
There we go people,
we're not quite done yet.

129
00:07:47.014 --> 00:07:54.307
[声音]在这一点上我们应该做点什么，以防这会引起任何新的问题。
[SOUND] Let's do thumbs at that point in
case this is raise any new questions.

130
00:07:54.307 --> 00:07:57.639
你把我弄糊涂了，不要到处看。
You lost me clear clarification,
no looking around.

131
00:07:57.639 --> 00:07:59.050
托德，我看到你在四处张望。
Todd, I saw you looking around.

132
00:07:59.050 --> 00:08:00.620
是好的澄清。
Is okay good clarifications.

133
00:08:00.620 --> 00:08:01.319
彼得有一个。
Peter has one.

134
00:08:01.319 --> 00:08:02.860
彼得，请继续。
Peter, go ahead please.

135
00:08:02.860 --> 00:08:07.649
Peter: 如果你定义了一个新的变量作为我的新函数,
&gt;&gt; Peter: If you defined a new variable
that you defined as my new function,

136
00:08:07.649 --> 00:08:09.889
它也能拿到它的背包吗？
would it also get its backpack?

137
00:08:09.889 --> 00:08:10.589
威尔 · 森塔斯: 好吧，那么
&gt;&gt; Will Sentance: Okay, so

138
00:08:10.589 --> 00:08:13.199
我们可以说一些有趣的附加事情。
there is a couple of interesting
bonus things we can say around that.

139
00:08:13.199 --> 00:08:18.132
你是说如果我们说彼得
So you're saying if we
said let's say Peter =

140
00:08:18.132 --> 00:08:23.629
我的新功能你是这个意思吗？
my new Function,
is that what you're saying?

141
00:08:23.629 --> 00:08:26.449
是啊那就是说 peter 现在是个新标签了
Yeah, so that would just be
peter is now a new label for

142
00:08:26.449 --> 00:08:28.730
同样的功能，同样的背包。
this same function with the same backpack.

143
00:08:28.730 --> 00:08:30.500
是的 彼得: 它仍然可以访问所有的-
Yeah.
&gt;&gt; Peter: It still gets access to all the-

144
00:08:30.500 --> 00:08:31.110
威尔 · 森特斯: 是的，当然。
&gt;&gt; Will Sentance: Yeah, absolutely.

145
00:08:31.110 --> 00:08:32.870
因为那只是现在彼得是一个新的标签
Cuz that's just now
peter is a new label for

146
00:08:32.870 --> 00:08:34.929
同样的功能，所有的东西都附着在上面。
this same function with all
the stuff attached to it.

147
00:08:34.929 --> 00:08:36.870
这是字面上附加到功能。
This is literally
attached to the function.

148
00:08:36.870 --> 00:08:39.529
Mynewfunction 现在是所有这一切的标签。
myNewFunction is the label for
all of this together now.

149
00:08:39.529 --> 00:08:42.789
函数代码运行，我的意思是，想想这个。
Function code to run, I mean,
just think about this.

150
00:08:42.789 --> 00:08:47.039
它被标记为一个可以创建的函数代码，所以是内存。
It's labeled for a function code
to run that can create, so memory.

151
00:08:47.039 --> 00:08:49.470
但是它也有自己的永久记忆。
But it's also got its own
permanent memory attached to it.

152
00:08:49.470 --> 00:08:51.440
这真是太不寻常了。
That is kind of extraordinary.

153
00:08:51.440 --> 00:08:52.620
还有一件事我想补充一下
Yeah.
There's one other thing I do want to add

154
00:08:52.620 --> 00:08:53.509
还是长话短说吧。
actually, keep it short.

155
00:08:53.509 --> 00:09:00.039
但是，如果我从相同的外部执行返回，自由函数。
But, if I returned out from the same
outer execution, free functions.

156
00:09:00.039 --> 00:09:01.905
顺便说一句如果你需要归还那个东西,
Which by the way,
if you need to return that one things,

157
00:09:01.905 --> 00:09:04.028
如何从学生合同中返回三个函数？
how can I return out three
functions from a student contracts?

158
00:09:04.028 --> 00:09:04.855
是的，丹。
Yeah, Dan.

159
00:09:04.855 --> 00:09:05.785
Dan: 在函数数组中。
&gt;&gt; Dan: In array of array of functions.

160
00:09:05.785 --> 00:09:08.745
方法的函数或对象数组,
&gt;&gt; Will Sentance: Array of function or
object for the methods yeah,

161
00:09:08.745 --> 00:09:12.059
它们都与同一个背包相连。
they would all be linking
to the same backpack.

162
00:09:12.059 --> 00:09:14.419
所以他们都可以使用那个共享背包。
And so they'd all have access
to that share backpack.

163
00:09:14.419 --> 00:09:14.980
挺酷的。
That's kind of cool.

164
00:09:14.980 --> 00:09:17.100
但这还不是我们要去的地方。
But that's not where we're going yet.

165
00:09:17.100 --> 00:09:19.610
我还以为我们要养彼得呢，这是最后一块了。
I thought we were going to raise
Peter is this final piece here.

166
00:09:19.610 --> 00:09:20.570
我们在这里看到了这一切。
So we saw all this here.

167
00:09:22.259 --> 00:09:25.440
我称之为背包紧密在变化的环境持久词汇,
What I call the backpack close over
variable environment persistent lexically,

168
00:09:25.440 --> 00:09:30.470
范围或标准东科特，参考数据，缓存，背包或封闭。
scoped or standard eastcote, reference
data, cache, backpack or closure.

169
00:09:30.470 --> 00:09:34.990
实时数据的背包或关闭附加到增量计数器上
The backpack or closure of live data
is attached to increment counter

170
00:09:34.990 --> 00:09:38.649
通过被称为作用域的隐藏属性。
via the hidden property known as scope.

171
00:09:38.649 --> 00:09:41.750
即使在返回这个内部函数时，它仍然持久存在。
Which persists, even when this
inner function is returned out.

172
00:09:41.750 --> 00:09:45.840
我们随身携带所有的数据，然后从函数的背面提取出来。
We grab all that data with us and
pull it out, on the back of the function.

173
00:09:45.840 --> 00:09:47.929
所以当我们用这个函数的新标签时,
So as we we use that
function by its new label,

174
00:09:47.929 --> 00:09:50.100
我们仍然可以访问所有的数据。
we still have access to all that data.

175
00:09:50.100 --> 00:09:50.820
而且是永久的。
And it's permanent.

176
00:09:50.820 --> 00:09:51.320
它不会消失。
It ain't going away.
