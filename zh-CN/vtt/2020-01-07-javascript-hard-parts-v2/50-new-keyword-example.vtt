WEBVTT

1
00:00:00.060 --> 00:00:01.610
这是我们的用户创建函数,
&gt;&gt; Will Sentance: There's
our user creator function,

2
00:00:01.610 --> 00:00:04.530
注意不要在里面创建一个物体。
notice no creating an object inside of it.

3
00:00:04.530 --> 00:00:09.060
不与某些共享存储或函数建立联系，也不返回对象。
No making a bond to some shared store or
functions, no returning an object out.

4
00:00:09.060 --> 00:00:13.750
因为我们要借助新的,
Because we're gonna run that
function with the help of the new,

5
00:00:13.750 --> 00:00:15.689
我们可以称之为修饰语。
we can call that a modifier.

6
00:00:15.689 --> 00:00:20.074
它改变了用户创建者执行上下文的行为,
It alters the behavior of the user
creator execution context,

7
00:00:20.074 --> 00:00:24.968
当我们运行它的时候，它会自动为我们插入东西。
it's gonna insert stuff in there
automatically for us when we run it.

8
00:00:24.968 --> 00:00:31.475
但是等一下，我们需要一个共享的功能存储，一个是铜的。
But hold on, we need a shared store
of functions one, copper one.

9
00:00:31.475 --> 00:00:36.039
你觉得怎么样，这些函数的一个保存版本。
What do you say,
one save version of those functions.

10
00:00:36.039 --> 00:00:37.630
我们怎么确保和他们有联系？
How are we gonna make sure
we have a bond to them?

11
00:00:39.210 --> 00:00:43.789
原来用户创建函数也是一个对象,
Well, it turns out that user
creator function is also an object,

12
00:00:43.789 --> 00:00:45.039
函数对象组合。
function object combo.

13
00:00:45.039 --> 00:00:47.198
这就是函数，我们只是不讨论对象，但大多数时候。
That's what a function is, we just don't
talk about the object but most the time.

14
00:00:47.198 --> 00:00:52.189
它的对象位有一个叫做 prototype into 的属性
And its object bit has
a property called prototype into

15
00:00:52.189 --> 00:00:57.159
我们要存储和增量方法。
which we're going to store and
increment method.

16
00:00:57.159 --> 00:01:00.789
让我们通过人群，这里我们一行一行地来看民谣。
Let's go through people,
here we go folk line by line.

17
00:01:00.789 --> 00:01:06.609
杰夫，如果你不介意把它拿走的话，实际上是完整的
Jeff, if you don't mind taking it away
actually with a full kind of complete

18
00:01:06.609 --> 00:01:11.180
称为全局存储器。
description as global memory.

19
00:01:11.180 --> 00:01:15.539
杰夫，在第一行完整地描述我们在做什么
Jeff, complete description of what
we're doing in that very first line

20
00:01:15.539 --> 00:01:17.469
不仅仅是声明一个函数，对吗？
more than just declaring a function,
right?

21
00:01:17.469 --> 00:01:18.010
我们在做什么？
What are we doing?

22
00:01:19.620 --> 00:01:22.454
演讲者2: 我们正在创建一个名为用户创造者的标签。
&gt;&gt; Speaker 2: We're creating
a label called user creator.

23
00:01:22.454 --> 00:01:25.251
威尔 · 森坦斯: 太棒了，这是一个函数定义，但是
&gt;&gt; Will Sentance: Fantastic,
it's a function definition stored it, but

24
00:01:25.251 --> 00:01:25.841
还有什么？
what else?

25
00:01:28.971 --> 00:01:31.246
说话人2: 这隐含了一个对象。
&gt;&gt; Speaker 2: That
implicitly has an object.

26
00:01:31.246 --> 00:01:33.906
威尔 · 森特斯: 我不介意这里隐含的意思，是的,
&gt;&gt; Will Sentance: I don't mind
the word implicit there, yeah,

27
00:01:33.906 --> 00:01:37.620
它是一个函数对象组合，我喜欢这样称呼它。
it has it is a function object combo,
as I like to call it.

28
00:01:37.620 --> 00:01:44.728
它有一个函数声明，或者函数定义,
There it is, it has both a function
declaration, or function definition sorry,

29
00:01:44.728 --> 00:01:49.376
这是一个函数和一个物体的组合。
that is the combination of
a function plus an object.

30
00:01:49.376 --> 00:01:51.729
这就是我们在定义函数时所做的。
That is what we're doing when
we're defining a function.

31
00:01:51.729 --> 00:01:55.079
我们只是大部分时间不谈论这件事，但它总是存在的。
We just don't talk about this thing most
of the time, but it's there, always.

32
00:01:55.079 --> 00:01:58.569
好了，现在，我们还没有完全结束。
Okay, now, we're not still quite done yet.

33
00:01:58.569 --> 00:02:00.599
亚当，这个物体不是空的。
Adam, this object is not an empty object.

34
00:02:00.599 --> 00:02:02.298
它是一个物体，上面有什么属性？
It's an object with, what property on it?

35
00:02:05.691 --> 00:02:08.201
什么问题是如何自动走向的？
&gt;&gt; Will Sentance: What problem
is it how automatically towards?

36
00:02:08.201 --> 00:02:10.312
亚当: 原型 威尔 · 森塔斯: 原型，亚当,
&gt;&gt; Adam: Prototype.
&gt;&gt; Will Sentance: Prototype, and Adam,

37
00:02:10.312 --> 00:02:14.401
这么大的一个古董，里面装的是什么？
what is that prototype property
got stored in it a big old?

38
00:02:14.401 --> 00:02:15.318
亚当: 空物体。
&gt;&gt; Adam: Empty object.

39
00:02:15.318 --> 00:02:16.627
Will Sentance: 空的物体，所以
&gt;&gt; Will Sentance: Empty object, so

40
00:02:16.627 --> 00:02:22.020
这就是我们在函数定义中所做的。
this is literally what we're doing
in just our function definition.

41
00:02:22.020 --> 00:02:25.967
我们只是不经常谈到这一点，但是
We just don't talk about this
bit of it that often but

42
00:02:25.967 --> 00:02:29.121
就在那儿，函数，对象组合。
it's there, function, object combo.

43
00:02:29.121 --> 00:02:33.349
这个物体有一个叫做原型的属性，这个属性本身就是一个很大的古老物体
And that object's got a property called
prototype which is itself a big old object

44
00:02:33.349 --> 00:02:34.270
储存在里面。
stored on it.

45
00:02:34.270 --> 00:02:35.014
我怎样才能到达这个物体？
How do I get to this object?

46
00:02:35.014 --> 00:02:40.882
丹，我要写什么样的文字才能写出这里的东西？
Dan, what's my kind of words do I
write to get to the object here?

47
00:02:40.882 --> 00:02:42.347
创造者，原型。
&gt;&gt; Dan: Creator.prototype.

48
00:02:42.347 --> 00:02:45.469
Will Sentance: Usercreated.prototype，这将给我这个对象。
&gt;&gt; Will Sentance: Usercreated.prototype,
and that's going to give me the object.

49
00:02:45.469 --> 00:02:47.801
如果我想在那个物体里存储一些东西，丹，我会写什么？
If I wanted to store something in
that object Dan, what would I write?

50
00:02:47.801 --> 00:02:50.526
Usercreator-Dan: . prototype.-
Usercreator-
&gt;&gt; Dan: .prototype.-

51
00:02:50.526 --> 00:02:51.450
威尔 · 森塔斯: 随便什么标签
&gt;&gt; Will Sentance: Whatever the label would

52
00:02:51.450 --> 00:02:52.425
就是为了这个。
be for that that exactly.

53
00:02:52.425 --> 00:02:55.550
恐怕我们得走了。
I'm afraid there we go.

54
00:02:55.550 --> 00:02:58.079
我们开始吧，丹，我们在这里做什么
Here we go on that note,
Dan, what are we doing here

55
00:02:58.079 --> 00:03:01.289
因为我们要使用这个对象，就像函数存储的用途一样
because we're gonna use this object
like how use a function store was for

56
00:03:01.289 --> 00:03:04.259
每个函数的一个垂直保存版本。
a single vert save
version of each function.

57
00:03:04.259 --> 00:03:09.430
我们希望任何运行后返回的对象
That we want any objects that
get returned from running

58
00:03:09.430 --> 00:03:14.659
用户创建器访问任何存储的函数在这里。
user creator to have access
to any stored function here.

59
00:03:14.659 --> 00:03:19.740
丹，我们要把教给我的东西一个字一个字地储存起来,
And Dan, what are we gonna store taught
me through word by word by word,

60
00:03:19.740 --> 00:03:21.360
从左到右。
the left to the right.

61
00:03:21.360 --> 00:03:22.228
我们正在寻找用户创建者。
&gt;&gt; Dan: We're looking for user creator.

62
00:03:22.228 --> 00:03:23.668
我们要去原型机那里。
We're going to the prototype.

63
00:03:23.668 --> 00:03:25.427
威尔 · 森坦斯: 嗯，我不会使用原型，但是
&gt;&gt; Will Sentance: Well,
I wouldn't use a prototype but

64
00:03:25.427 --> 00:03:27.079
听起来很神奇。
it sounds like something magical.

65
00:03:27.079 --> 00:03:29.192
Dan: 我们将进入-Will Sentance: User creates object
&gt;&gt; Dan: We're going to the-
&gt;&gt; Will Sentance: User creates object

66
00:03:29.192 --> 00:03:34.870
自身的版本，我们要找的自身的对象部分，上面有什么属性？
version of itself, object part of itself
which we look for, what property on it?

67
00:03:34.870 --> 00:03:36.146
丹: 原型-威尔 · 森塔斯: 当然,
&gt;&gt; Dan: Prototype-
&gt;&gt; Will Sentance: Absolutely,

68
00:03:36.146 --> 00:03:37.144
我们找到了一个？
which we find is a?

69
00:03:37.144 --> 00:03:39.084
丹: 空物体威尔 · 森塔斯: 谢天谢地,
&gt;&gt; Dan: Empty object
&gt;&gt; Will Sentance: Thank goodness,

70
00:03:39.084 --> 00:03:40.579
因为我们接下来要做什么，我们要做什么？
because what we try and
do next, we try to?

71
00:03:40.579 --> 00:03:43.329
创建一个新的标签增量。
&gt;&gt; Dan: Create a new label increment.

72
00:03:43.329 --> 00:03:44.735
威尔 · 森塔斯: 太棒了，在那个物体里
&gt;&gt; Will Sentance: Fantastic,
in that object-

73
00:03:44.735 --> 00:03:47.050
阿丹: 还要存储一个函数。
&gt;&gt; Dan: And store a function.

74
00:03:48.349 --> 00:03:50.400
威尔 · 森塔斯: 老实说，我知道为了在年做这个
&gt;&gt; Will Sentance: I honestly got to
say I know in order to do this in

75
00:03:50.400 --> 00:03:53.050
这样的录音版本，但这值得一阵掌声。
this sort of recorded version, but
that deserves a round of applause.

76
00:03:53.050 --> 00:03:54.240
谢谢你 Dan 你真是太好了。
Thank you, Dan.
That was very, very nice.

77
00:03:54.240 --> 00:03:56.247
(掌声)威尔 · 森坦斯: 丹说得好。
&gt;&gt; [APPLAUSE]
&gt;&gt; Will Sentance: Nice from Dan.

78
00:03:56.247 --> 00:04:00.909
我们让伊森在这里做下一个。
Let's have Ethan do the next one here.

79
00:04:00.909 --> 00:04:04.975
在查用户创建者 Ethan？
So looking up user creator, Ethan?

80
00:04:04.975 --> 00:04:06.175
伊森: 是的。
&gt;&gt; Ethan: Yes.

81
00:04:06.175 --> 00:04:09.157
威尔 · 森特斯: 发现它是一个函数加一个对象,
&gt;&gt; Will Sentance: Finding that
it's a function plus an object,

82
00:04:09.157 --> 00:04:13.449
我们要在这里访问它的函数位，还是它的对象位？
are we gonna access its function bit here,
or its object bit here?

83
00:04:13.449 --> 00:04:14.349
伊森: 反对。
&gt;&gt; Ethan: Object.

84
00:04:14.349 --> 00:04:16.259
Will Sentance: Object bit，使用点符号，和
&gt;&gt; Will Sentance: Object bit,
using dot notation, and

85
00:04:16.259 --> 00:04:18.189
它有一个属性的对象叫什么？
it's got a property on the object called?

86
00:04:19.430 --> 00:04:20.404
原型 威尔 · 森塔斯: 它本身就是,
&gt;&gt; Ethan: Prototype.
&gt;&gt; Will Sentance: Which is itself,

87
00:04:20.404 --> 00:04:22.983
感谢上帝，一个物体，因为我们要尝试
thank goodness, an object,
because we're gonna try and

88
00:04:22.983 --> 00:04:24.620
用那个原型物体做什么。
do what with that prototype object.

89
00:04:24.620 --> 00:04:26.120
我们要试着分配它吗？
We're gonna try and assign it?

90
00:04:26.120 --> 00:04:27.005
伊森: 还有标签登录。
&gt;&gt; Ethan: And label login.

91
00:04:27.005 --> 00:04:30.834
威尔 · 森坦斯: 太棒了，在属性登录时，给它分配一个功能,
&gt;&gt; Will Sentance: Fantastic, at the
property login and assign it a function,

92
00:04:30.834 --> 00:04:31.514
一种方法。
a method.

93
00:04:31.514 --> 00:04:34.941
伙计们看看这个,
Look at that, folks, look at that,

94
00:04:34.941 --> 00:04:39.810
这样的存储单一版本的功能。
that such store of single
version of our functions.

95
00:04:39.810 --> 00:04:41.959
好的很好。
Okay, good.

96
00:04:41.959 --> 00:04:44.269
现在移到下一行。
Now move down to the next line.

97
00:04:44.269 --> 00:04:45.670
布雷登，左手边。
Braydon, left-hand side.

98
00:04:45.670 --> 00:04:48.247
那句话是什么意思? 等一下，让我做我的左手边。
What's that saying?
Hold on, let me just do my left-hand side.

99
00:04:48.247 --> 00:04:49.293
布莱登，该怎么办？
Braden, what to say to do?

100
00:04:49.293 --> 00:04:51.610
Braydon: 不要声明一个常量用户为1。
&gt;&gt; Braydon: Don't declare
a constant user one.

101
00:04:52.779 --> 00:04:54.540
Will Sentance: 声明一个常量用户为。
&gt;&gt; Will Sentance: Declare
a constant user one.

102
00:04:55.590 --> 00:04:58.610
我们知道里面放什么吗，布雷顿？
Do we know what to store in it, Braydon?

103
00:04:58.610 --> 00:05:00.970
布雷登: 不仅仅是——威尔 · 森坦斯: 我们不知道。
&gt;&gt; Braydon: Not just-
&gt;&gt; Will Sentance: We have no idea.

104
00:05:00.970 --> 00:05:02.648
千万不要看那个新的关键词
Do not ever look at that new key word and

105
00:05:02.648 --> 00:05:05.387
认为用户一这是一个不同的功能。
think somehow user one this
is a different to a function.

106
00:05:05.387 --> 00:05:08.108
我们在右手边做什么，布雷登？
What are we doing on the right-hand
side there, Brayden?

107
00:05:08.108 --> 00:05:09.524
暂时保持新鲜，你在右手边做了什么？
Hold the new for now,
what did you do in right-hand side?

108
00:05:09.524 --> 00:05:11.990
布雷顿: 你在给用户创建者打电话
&gt;&gt; Braydon: You're
calling the user creator

109
00:05:11.990 --> 00:05:12.535
威尔 · 森特斯: 我们在打电话,
&gt;&gt; Will Sentance: We're calling,

110
00:05:12.535 --> 00:05:14.834
我们正在执行，我们正在使用 Prince 运行用户创建函数。
we're executing, we're running
the user create function with Prince.

111
00:05:14.834 --> 00:05:19.055
没有什么魔法，没有什么不同，没有什么东西,
Nothing magic, nothing different,
nothing object,

112
00:05:19.055 --> 00:05:22.399
就叫做用户创造者。
is just literally call user creator.

113
00:05:22.399 --> 00:05:26.740
前面有一个特殊的三个字母的单词，可以做很多事情
With a special three-letter word in
front that's gonna do a ton of stuff

114
00:05:26.740 --> 00:05:29.339
在用户创建器的执行上下文中。
inside user creator's execution context.

115
00:05:30.810 --> 00:05:33.901
好吧，那么现在，我们的用户1是 Brayden？
All right, so for now,
our user1 is, Brayden?

116
00:05:33.901 --> 00:05:35.295
未初始化。
&gt;&gt; Braydon: Uninitialized.

117
00:05:35.295 --> 00:05:37.240
威尔 · 森特斯: 没有初始化，是的，很好。
&gt;&gt; Will Sentance: Uninitialized,
yeah, perfect.

118
00:05:37.240 --> 00:05:38.356
好了我们开始吧。
All right, here we go.

119
00:05:38.356 --> 00:05:41.850
这是最后一块了，最后一块，各位。
This is the final, final piece, people.

120
00:05:42.980 --> 00:05:47.970
好的，用户创造者，我要用蓝色来做我的新东西。
Okay, user creator, I'm gonna use blue for
my stuff that new does.

121
00:05:47.970 --> 00:05:51.723
这就是我们的新号召,
So there's our new, calling,

122
00:05:51.723 --> 00:05:56.310
和往常一样，调用函数。
just as usual, calling the function.

123
00:05:56.310 --> 00:05:57.540
只要稍微改变一下,
Just with a slight little change,

124
00:05:57.540 --> 00:06:00.480
在执行过程中会发生什么。
in terms of what it's gonna do
inside the execution context.

125
00:06:00.480 --> 00:06:02.732
在执行过程中会自动化大量的事情。
It's gonna automate a ton of stuff
inside that execution context.

126
00:06:02.732 --> 00:06:10.029
与 Eva 和9一起呼叫 userCreator。
Calling userCreator with Eva, and 9.

127
00:06:10.029 --> 00:06:12.079
我想这几乎是我们最后的机会了。
I think it's almost our
last chance to do this.

128
00:06:13.420 --> 00:06:17.259
它是一个品牌，它是一个全新的？
It's a brand, it's a brand new?

129
00:06:17.259 --> 00:06:18.899
演讲者2: 执行情境。
&gt;&gt; Speaker 2: Execution context.

130
00:06:18.899 --> 00:06:22.480
威尔 · 森塔斯: 执行环境，听起来很神奇。
&gt;&gt; Will Sentance: Execution context,
it sounds amazing.

131
00:06:22.480 --> 00:06:24.759
这就是了，这是一个大问题。
There it is, it's a huge one.

132
00:06:25.959 --> 00:06:30.199
就是这样，我仍然，总有一天我会做得很好。
There it is, I still,
one day I'll get good at that.

133
00:06:30.199 --> 00:06:32.577
这就是巨大的执行环境。
There it is, huge execution context.

134
00:06:32.577 --> 00:06:38.127
直觉，你去，是的，直觉，我们去,
Intuit you go, yep, Intuit we go,

135
00:06:38.127 --> 00:06:42.987
还有，威尔 · 森特斯: 在我们当地,
and,
&gt;&gt; Will Sentance: In our local,

136
00:06:45.264 --> 00:06:46.500
威尔 · 句子: 记忆。
&gt;&gt; Will Sentance: Memory.

137
00:06:48.670 --> 00:06:53.860
首先，让我们处理参数参数组合。
First, let's handle our
parameter argument combinations.

138
00:06:53.860 --> 00:06:59.149
彼得，这个函数的输入是什么？
Peter, our,
inputs to this function, are what?

139
00:07:00.500 --> 00:07:02.139
彼得: 伊娃-威尔 · 森坦斯: 我们先做那个吧。
&gt;&gt; Peter: Eva-
&gt;&gt; Will Sentance: Let's do that one first.

140
00:07:02.139 --> 00:07:06.670
它被分配给函数中的哪个参数，哪个占位符？
Eva, and it's assigned to what parameter,
what placeholder inside the function?

141
00:07:06.670 --> 00:07:08.170
彼得: 姓名 威尔 · 森坦斯: 名字，完全正确。
&gt;&gt; Peter: Name.
&gt;&gt; Will Sentance: Name, exactly.

142
00:07:08.170 --> 00:07:10.899
不要认为这些是对象或者属性,
Don't think these are objects,
or properties, or by the way,

143
00:07:10.899 --> 00:07:14.079
任何与新的关键字，这是正则输入的函数。
anything to do with new keyword that
is regular inputs for function.

144
00:07:14.079 --> 00:07:17.129
下一个，又是彼得？
The next one, Peter again?

145
00:07:17.129 --> 00:07:18.259
彼得: 得分是9分。
&gt;&gt; Peter: Score is 9.

146
00:07:18.259 --> 00:07:21.329
Will Sentance: 是的，score 参数是值9的参数。
&gt;&gt; Will Sentance: Yeah, score parameter
is the argument of the value 9.

147
00:07:21.329 --> 00:07:23.709
这就像我们在这个函数中声明变量一样。
That is like if we declare
the variables inside this function.

148
00:07:23.709 --> 00:07:27.930
我们可以在这里面写，我不知道，名字也行。
We could just write inside here,
I don't know, const name is either.

149
00:07:27.930 --> 00:07:31.641
但是我们不想让它变得如此非一般，如此不灵活。
But we don't wanna make it so
non-general, [LAUGH] so inflexible.

150
00:07:31.641 --> 00:07:36.670
我们希望每次运行这个函数的时候都能改变它，好吗？
We wanna be able to have it change
each time we run this function, okay?

151
00:07:36.670 --> 00:07:41.689
那就是，白色笔下，蓝色笔下的时间。
That's, white pen down, blue pen time.

152
00:07:41.689 --> 00:07:45.548
这个函数的意义在于，无论我们在这里做什么，都是为了创造,
The whole point of this function, whatever
we're doing here is to create what,

153
00:07:45.548 --> 00:07:46.069
布雷顿？
Braydon?

154
00:07:46.069 --> 00:07:47.322
布雷顿: 一个物体。
&gt;&gt; Braydon: An object.

155
00:07:47.322 --> 00:07:48.283
威尔 · 森塔斯: 一个客体。
&gt;&gt; Will Sentance: An object.

156
00:07:48.283 --> 00:07:51.038
我们是否需要在每次执行函数时手动声明一个对象
Do we wanna have to manually declare
an object every time you do a function

157
00:07:51.038 --> 00:07:51.680
是这样吗？
that does this?

158
00:07:51.680 --> 00:07:53.620
没有，那我们的新关键词是什么？
No, so what's our new key words?

159
00:07:53.620 --> 00:07:54.581
它要做的第一件事是什么，布雷顿？
First thing it's gonna do, Braydon?

160
00:07:54.581 --> 00:07:56.963
Braydon: 分配空对象。
&gt;&gt; Braydon: Assign empty object.

161
00:07:56.963 --> 00:08:00.437
是的，声明并保存在内存中。
&gt;&gt; Will Sentance: Yeah,
declare and save in memory.

162
00:08:00.437 --> 00:08:04.480
一个空的物体。
An empty object.

163
00:08:04.480 --> 00:08:07.519
我们希望能够得到访问，这样我们就可以把东西放进去。
We wanna be able to get access so
we can stick stuff into it.

164
00:08:07.519 --> 00:08:10.060
我们给它贴的标签是什么，布雷顿？
What is the label we've
given to access it, Braydon?

165
00:08:10.060 --> 00:08:13.800
布雷顿: 这个 威尔 · 森塔斯: 这真是太美了,
&gt;&gt; Braydon: This.
&gt;&gt; Will Sentance: This, exactly beautiful,

166
00:08:13.800 --> 00:08:17.269
设置为空对象。
set this to empty object.

167
00:08:17.269 --> 00:08:18.120
Beaituful.
Beaituful.

168
00:08:18.120 --> 00:08:19.550
好吧。
All right.

169
00:08:19.550 --> 00:08:25.779
但是当它最终返回到用户一时，我们不会反对
But we will not object when it eventually
gets returned out into user one

170
00:08:25.779 --> 00:08:30.660
访问我们的单一保存版本的功能。
to have access to our single
save version of the functions.

171
00:08:30.660 --> 00:08:32.980
我们希望它能记住我们的整个目标。
We want it to have access to remember,
our whole goal here.

172
00:08:34.629 --> 00:08:36.259
所以我可以用一点点增量来做到这一点。
So I can do this using
one little increments.

173
00:08:36.259 --> 00:08:40.129
这是整个工作坊的唯一目标。
That's the only goal
of the whole workshop.

174
00:08:40.129 --> 00:08:44.389
图标是否具有适用于该用户的功能,
Is the icon have the functionality
that applies to that user one,

175
00:08:44.389 --> 00:08:48.129
不是所有的10万行代码，但是
not all over the whole
100,000 lines of code, but

176
00:08:48.129 --> 00:08:52.889
取而代之的是，在我们的用户上有一个对象。
instead, right there on
our user one object.

177
00:08:52.889 --> 00:08:57.190
排行榜上所有的测验问题都不分享，没有。
Not being shared by all the quiz
questions in the league tables, no.

178
00:08:57.190 --> 00:08:59.789
就在这里，在我们的 user1对象上，这是我们唯一的目标。
Right there, on our user1 object,
it's our only goal.

179
00:08:59.789 --> 00:09:03.482
但是要知道我们不能把增量函数直接存储在对象上,
But know we can't have increment
function directly stored on that object,

180
00:09:03.482 --> 00:09:06.437
我们想要的是一个链接，通过其原始参考。
we wanna have instead a link
through its proto reference to.

181
00:09:08.860 --> 00:09:11.015
Will Sentance: 这个共享的函数存储。
&gt;&gt; Will Sentance: this
shared store of functions.

182
00:09:11.015 --> 00:09:18.809
那么 Braydon，你认为他们隐藏的原始财产会链接到什么呢？
And so Braydon, what do you think their
hidden proto property is going to link to?

183
00:09:18.809 --> 00:09:20.669
具体点，具体在哪里？
Be very specific, exactly where?

184
00:09:20.669 --> 00:09:24.100
布雷顿: 它将连接到
&gt;&gt; Braydon: It's going to
link to the object part of

185
00:09:24.100 --> 00:09:29.190
原型属性的用户创建器函数。
the user creator function
to the prototype property.

186
00:09:29.190 --> 00:09:30.190
威尔 · 森塔斯: 哪个是它本身？
&gt;&gt; Will Sentance: Which is itself?

187
00:09:30.190 --> 00:09:31.049
布雷顿: 一个物体。
&gt;&gt; Braydon: An object.

188
00:09:31.049 --> 00:09:34.830
威尔 · 森坦斯: 一个对象，充满了我们放在里面的功能。
&gt;&gt; Will Sentance: An object, full of
the functions that we've put in there.

189
00:09:34.830 --> 00:09:38.879
非常，非常，非常好，非常感谢布雷登。
Very, very, very nice there,
much appreciated by Braydon.

190
00:09:38.879 --> 00:09:46.475
从布雷登到那个东西，简直太棒了。
From Brayden there,
up to that object, fantastic.

191
00:09:46.475 --> 00:09:49.480
好了，现在我们回到正题。
Okay, now we're back to us.

192
00:09:49.480 --> 00:09:56.220
这是它做的第二件事，设置运行的函数的原型,
So that's the second thing it does, set
proto to the function that's being run,

193
00:09:56.220 --> 00:10:00.610
对象版本的原型属性，它本身就是一个对象。
onto its prototype property of its object
version, which is itself an object.

194
00:10:00.610 --> 00:10:05.820
因此我们将原型设置为 userCreate，或者
So we set the proto to userCreate, or

195
00:10:05.820 --> 00:10:11.690
不管功能是什么，这已经成为了新的关键词，原型。
whatever the function is, this has been
rather the new keyword .prototype.

196
00:10:11.690 --> 00:10:15.190
这些都是通过我们的新关键字自动生成的。
This is all automated by
the new keyword for us.

197
00:10:15.190 --> 00:10:17.000
这看起来已经很不错了，不是吗？
This is looking pretty nice already,
right?

198
00:10:17.000 --> 00:10:19.679
但是现在我们必须得到一些实际的具体数据。
But now we've got to get some
actual specific data in.

199
00:10:19.679 --> 00:10:24.009
丹，对你来说，丹: 我们运行这一行的栈名称,
Dan, to you
&gt;&gt; Dan: We run the line the stack name,

200
00:10:24.009 --> 00:10:24.740
威尔 · 森塔斯: 太棒了。
&gt;&gt; Will Sentance: Fantastic.

201
00:10:24.740 --> 00:10:26.759
我们把这个加到本地存储器里，威尔 · 森坦斯: 是的。
&gt;&gt; Dan: We add this in the local memory,
&gt;&gt; Will Sentance: Yeah.

202
00:10:26.759 --> 00:10:29.889
丹: 并创建一个新的标签名称标志的名称-
&gt;&gt; Dan: And creates a new label
name signs that the name-

203
00:10:29.889 --> 00:10:31.679
威尔 · 森塔斯: 我想说,
&gt;&gt; Will Sentance: I would say here,

204
00:10:31.679 --> 00:10:32.889
因为我们不想搞混
because we don't wanna get confused

205
00:10:32.889 --> 00:10:33.779
和我们的丹: 是的。
with our
&gt;&gt; Dan: Yeah.

206
00:10:33.779 --> 00:10:37.409
Will Sentance: 变量名或参数、新的属性名和
&gt;&gt; Will Sentance: Variable names or
parameters, a new property name and

207
00:10:37.409 --> 00:10:41.370
被我无情地选中了那会是工作吗 Dan？
very unhelpfully chosen by me,
which is gonna be work, Dan?

208
00:10:41.370 --> 00:10:43.750
阿丹: 年通过的那个论点。
&gt;&gt; Dan: The argument that was passed in.

209
00:10:43.750 --> 00:10:44.399
哪一个是？
&gt;&gt; Will Sentance: Which is?

210
00:10:44.399 --> 00:10:45.019
太棒了。
Fantastic.

211
00:10:45.019 --> 00:10:47.129
顺便说一下，丹，你的技术社区非常出色。
By the way, Dan your technical
community is outstanding.

212
00:10:47.129 --> 00:10:47.919
那下一行呢？
And then the next line?

213
00:10:49.549 --> 00:10:54.679
阿丹: 同样的事情，但在这方面的分数-威尔森坦斯: 自动创建
&gt;&gt; Dan: Same thing but with score on this-
&gt;&gt; Will Sentance: The auto-created

214
00:10:54.679 --> 00:10:57.850
新关键字的帮助下创建一个对象，它有标签？
object with the help of the new keyword,
which has got the label?

215
00:10:57.850 --> 00:10:59.720
丹: 这个 威尔 · 森塔斯: 这个，没错，还有
&gt;&gt; Dan: This.
&gt;&gt; Will Sentance: This, exactly, and

216
00:10:59.720 --> 00:11:03.250
我们去找它，然后我们发现，它有什么特性吗？
we go to it and we find,
does it have a score property?

217
00:11:03.250 --> 00:11:04.029
丹: 没有 威尔 · 森塔斯: 不，是这样
&gt;&gt; Dan: No.
&gt;&gt; Will Sentance: No, so

218
00:11:04.029 --> 00:11:06.019
我们成功了，就是这样。
we make it, there it is.

219
00:11:06.019 --> 00:11:08.120
我们分配到这个任务，什么，丹？
And we assigned to it, what, Dan?

220
00:11:08.120 --> 00:11:09.864
丹: 9 威尔 · 森塔斯: 我们学校的价值
&gt;&gt; Dan: 9.
&gt;&gt; Will Sentance: The value of our school

221
00:11:09.864 --> 00:11:16.139
参数是策略的参数，也就是9。
parameter which is the argument that
was policy which is 9, exactly.

222
00:11:16.139 --> 00:11:19.419
那是一个相当不错的民间，那正是我们想要的。
Folk that is a pretty nice,
that's exactly what we want.

223
00:11:19.419 --> 00:11:22.970
但是它被限制在我们的用户创造者内部的一个函数中,
But it's stuck inside a function,
inside of our user creator,

224
00:11:22.970 --> 00:11:25.298
我正在查看用户创建器，我没有看到任何返回。
and I'm looking at user creator I
don't see anything returned out.

225
00:11:26.370 --> 00:11:33.879
什么标志，你认为我们的新关键字自动化是最后一件事吗？
What Mark, do you think is the last
thing that our new keyword automates?

226
00:11:33.879 --> 00:11:36.419
阿丹: 还这个。
&gt;&gt; Dan: Returning the this.

227
00:11:36.419 --> 00:11:41.080
威尔 · 森特斯: 记住，把这个还回去，完全正确。
&gt;&gt; Will Sentance: Remember that,
returning this, exactly right.

228
00:11:41.080 --> 00:11:44.429
返回分配给这个关键字的对象,
Returning the object assigned to this,
keyword,

229
00:11:44.429 --> 00:11:46.200
我也喜欢蓝色的，对吧？
I like to do it in blue as well, right?

230
00:11:46.200 --> 00:11:53.879
因为它是自动的，返回到全局标签。
Because it's automatic,
returning it out into the global label.

231
00:11:53.879 --> 00:11:58.149
这里的整个部分计算转换为返回的对象，并且
This whole portion here evaluates
turns into the returned object, and

232
00:11:58.149 --> 00:12:00.523
储存在哪里？
stored into what?

233
00:12:00.523 --> 00:12:04.003
1 with name,
Into user1 with name,

234
00:12:04.003 --> 00:12:09.048
有趣的是我现在已经改变了
it's funny that I've now changed

235
00:12:09.048 --> 00:12:14.149
这个颜色，没什么用。
the color, is not helpful.

236
00:12:14.149 --> 00:12:18.878
好了，亲爱的，是的,
There we go, well, dear, yeah,

237
00:12:18.878 --> 00:12:24.220
用我们隐藏的原始财产原型
with our hidden proto property__proto

238
00:12:24.220 --> 00:12:31.240
下划线是到 userCreator.product 的链接
underscore which is a link
up to userCreator.product

239
00:12:31.240 --> 00:12:36.750
这个用于共享功能的大对象。
this big object for the shared functions.

240
00:12:38.090 --> 00:12:45.100
好，现在执行上下文在这里，停留还是去？
Okay, now execution context here,
stays or goes?

241
00:12:45.100 --> 00:12:47.129
完全正确，突然挂断了电话。
Goes, exactly, popped off the call stat.

242
00:12:47.129 --> 00:12:49.751
我们没有显示这个呼叫，但是它被删除了
We didn't show the call stat,
but it's deleted, and

243
00:12:49.751 --> 00:12:51.408
现在我们要做最重要的检查。
now we do our all important check.

244
00:12:51.408 --> 00:12:54.669
一直以来我们唯一在乎的。
The only thing we really
cared about the whole time.

245
00:12:54.669 --> 00:12:59.088
如果我可以做 user1.increment。
If can I do user1.increment.

246
00:12:59.088 --> 00:13:06.330
顺便说一句，这就是为什么我要告诉你们解决方案二，做到了。
And by the way people, this is why I'd
tell you solution two, did the job.

247
00:13:07.679 --> 00:13:12.360
解决方案三就是让我们的大部分工作自动化，这太棒了。
Solution three is just automating so much
of that job for us, which is fantastic.

248
00:13:12.360 --> 00:13:17.389
但是在引擎盖下面，它是完全相同的，在做完全相同的事情方面。
But under the hood, it's exactly the same,
in terms of doing exactly the same stuff.

249
00:13:17.389 --> 00:13:19.940
是的，它必须做一些小小的改变。
Yes, it has to make a few little changes.

250
00:13:19.940 --> 00:13:24.100
我们必须把我们所有的函数放在这个对象中，因为我们不能控制它。
We have to put all our functions in this
object, cuz we don't get it controlled.

251
00:13:24.100 --> 00:13:28.389
所以我们最好把它放在 JavaScript 知道它们会出现的地方。
So we better put it somewhere where
JavaScript knows they're gonna be.

252
00:13:28.389 --> 00:13:30.730
我们把这个作为对象的标签。
We've got this as the label for
the object.

253
00:13:30.730 --> 00:13:33.220
但除此之外，一切都是一样的。
But otherwise, it's exactly the same.

254
00:13:33.220 --> 00:13:34.809
另外，我们可以做这一件事。
Also, we can do this one thing.

255
00:13:35.820 --> 00:13:40.195
将我们的函数和数据捆绑在一起，以便于进行推理，但是
Have our functions and data bundle
together for our ease of reasoning, but

256
00:13:40.195 --> 00:13:43.399
我们不能在物体上实现这些功能。
we can't have the functions
literally on the object.

257
00:13:43.399 --> 00:13:47.932
否则，我已经复制了每一个用户对象，用户1，用户2,
Otherwise, I've been copied on every
single user object, user one, user two,

258
00:13:47.932 --> 00:13:48.740
用户500。
user 500.

259
00:13:48.740 --> 00:13:50.820
我们浪费了记忆空间。
We waste memory space.

260
00:13:50.820 --> 00:13:56.200
所以取而代之的是，我们将它们保存在一个单独的版本中。
So instead, we have them in
one place single save version.

261
00:13:56.200 --> 00:13:59.830
而 Java 原型的原型特性将包含 JavaScript。
And the proto feature of Java
prototype will feature JavaScript.

262
00:13:59.830 --> 00:14:02.629
所有对象都有一个原始属性。
It's proto property that
all objects have a.

263
00:14:02.629 --> 00:14:08.230
我们将其设置为链接到该对象，因为我们知道当 JavaScript
We set it to link up to that object,
knowing that when JavaScript

264
00:14:08.230 --> 00:14:13.049
运行 user1.increment，它是否能很好地执行，让我们看看。
runs user1.increment, and
does it fight well, let's see.

265
00:14:13.049 --> 00:14:14.559
托德，轮到你了。
Todd, it's your moment.

266
00:14:14.559 --> 00:14:16.059
用户1我们在哪里寻找它？
User1 where do we look for it?

267
00:14:16.059 --> 00:14:16.679
托德: 全球记忆。
&gt;&gt; Todd: Global memory.

268
00:14:16.679 --> 00:14:18.220
威尔 · 森特斯: 全局记忆，它在那里吗？
&gt;&gt; Will Sentance: Global memory,
is it there?

269
00:14:18.220 --> 00:14:21.309
托德: 是的 是的，它是，增量。
&gt;&gt; Todd: Yes.
&gt;&gt; Will Sentance: Yes, it is, increment.

270
00:14:21.309 --> 00:14:22.649
我们看着，你告诉我？
We look on, well, you tell me?

271
00:14:22.649 --> 00:14:23.750
托德: 不在那里。
&gt;&gt; Todd: Not there.

272
00:14:23.750 --> 00:14:24.250
威尔 · 森塔斯: [笑]好-托德: [笑]
&gt;&gt; Will Sentance: [LAUGH] Good-
&gt;&gt; Todd: [LAUGH]

273
00:14:24.250 --> 00:14:25.572
对一个对象排队,
&gt;&gt; Will Sentance: Queue one object,

274
00:14:25.572 --> 00:14:26.980
不是那里，我们会恐慌吗？
not there.
Do we panic?

275
00:14:26.980 --> 00:14:28.567
托德: 没有 威尔 · 森坦斯: JavaScript 是做什么的
&gt;&gt; Todd: No.
&gt;&gt; Will Sentance: What does JavaScript do

276
00:14:28.567 --> 00:14:29.909
自动？
automatically?

277
00:14:29.909 --> 00:14:34.460
托德: 它需要原型，它会跟着用户创建者
&gt;&gt; Todd: It'll take the proto,
it'll follow that up to the user creator

278
00:14:35.649 --> 00:14:40.669
对象，以及该对象中的原型属性，然后看这里。
object, and the prototype property
in that object, and look in there.

279
00:14:40.669 --> 00:14:42.759
威尔 · 森特斯: 绝对出色，并找到了吗？
&gt;&gt; Will Sentance: Absolutely outstanding,
and find?

280
00:14:42.759 --> 00:14:43.988
托德: 增量 增量，和
&gt;&gt; Todd: Increment.
&gt;&gt; Will Sentance: Increment, and

281
00:14:43.988 --> 00:14:47.639
然后我们用这段代码，构建一个执行上下文。
then we take that code, and
we build an execution context.

282
00:14:49.509 --> 00:14:52.850
太棒了，让我们给托德一点掌声，托德非常友好。
Amazing, let's give Todd a hand,
very nice from Todd.

283
00:14:52.850 --> 00:14:54.769
这对我来说是最难的部分。
That for me is the hardest bit.

284
00:14:54.769 --> 00:14:55.940
好极了，伙计们。
Excellent, people.

285
00:14:55.940 --> 00:15:01.471
就是这样，一个新的关键字出售了至少一些我们的输入太多的问题,
That's it, a new keyword has sold at least
some of our typing too much problem,

286
00:15:01.471 --> 00:15:02.721
但是我的天啊,
but my goodness,
