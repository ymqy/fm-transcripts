WEBVTT

1
00:00:00.060 --> 00:00:01.727
威尔 · 森塔斯: 我不想让任何人对这种差异感到困惑。
&gt;&gt; Will Sentance: I don't want anyone
confused by this difference here.

2
00:00:01.727 --> 00:00:06.091
所以我们必须声明 outer，运行 outer，然后把 incrementCounter 输入到 myNewFunction,
So we had declare outer, run outer, out
came incrementCounter into myNewFunction,

3
00:00:06.091 --> 00:00:08.926
运行 myNewFunction，再次运行 myNewFunction，好吗？
run myNewFunction,
run myNewFunction again, okay?

4
00:00:08.926 --> 00:00:10.521
我们现在知道这一点了。
We know this bit now.

5
00:00:10.521 --> 00:00:14.085
我的新功能，当它出来的时候，带着所有的背包数据,
myNewFunction, when it came out,
got with it all that backpacked data,

6
00:00:14.085 --> 00:00:17.257
当它跑出来的时候，得到了所有的背包数据。
when it came out of running outer,
got all that backpacked data.

7
00:00:17.257 --> 00:00:22.251
也就是说，我们运行了 myNewFunction，我们可以访问背包里的所有数据。
Meaning, we ran myNewFunction, we had
access to all that data in the backpack.

8
00:00:22.251 --> 00:00:26.995
从增量计数器作为一个函数在运行中诞生开始
From when increment counter was born
as a function inside the running of

9
00:00:26.995 --> 00:00:30.568
在我的新函数中加入增量计数。
outer out came increment
count into my new function.

10
00:00:30.568 --> 00:00:33.539
现在有了增量计数器，但是,
myNewFunction has now
increment counter but also,

11
00:00:33.539 --> 00:00:38.064
通过它的隐藏范围属性，所有周围的实时数据时，它是
through its hidden scope property all
the surrounding live data from when it was

12
00:00:38.064 --> 00:00:40.512
我们运行新功能的时候，我也是这样出生的。
born as well me when we
run my new function.

13
00:00:40.512 --> 00:00:44.892
我们仍然可以使用 myNewFunctions 背包
We still have access to
myNewFunctions backpack

14
00:00:44.892 --> 00:00:49.177
增量计数器，周围的实时数据。
increment counters, surrounding live data.

15
00:00:49.177 --> 00:00:50.957
如果你看看这里的代码,
If you look at this code here,

16
00:00:50.957 --> 00:00:55.664
这是我们的外部你看，我把增量计数器现在对，多行。
there's our outer you see I put increment
counter now on to, multiple lines.

17
00:00:55.664 --> 00:00:58.840
然后我们来到这里，这都是一样的,
Then we've got over here,
this is all the same,

18
00:00:58.840 --> 00:01:02.018
右外部 myNewFunction 是外部函数的返回。
right outer myNewFunction
is a return of outer.

19
00:01:02.018 --> 00:01:06.253
这是增量计数面试一切到这里完全一样。
Which was increment count interview
everything up to here exactly the same.

20
00:01:06.253 --> 00:01:07.754
事情发生了变化。
Where things change.

21
00:01:07.754 --> 00:01:10.567
我现在在这里添加了一个新的代码块。
I've now added a new block of code here.

22
00:01:10.567 --> 00:01:14.016
不要因为我把它绕了一圈而感到困惑
Don't get confused by the fact
I kind of looped it around but

23
00:01:14.016 --> 00:01:18.787
线程的执行是[声音]和下来，右，两列基本上。
the thread of execution is going [SOUND]
and down, right, two columns basically.

24
00:01:18.787 --> 00:01:20.228
这里没有什么深奥的东西。
There's nothing profound here.

25
00:01:20.228 --> 00:01:21.799
我不能把所有的东西放在一张幻灯片上。
I cannot fit all on one slide.

26
00:01:21.799 --> 00:01:26.063
这是一个新的代码块，有三行代码。
And so, here we got this new block
with three lines of code here.

27
00:01:26.063 --> 00:01:27.558
又一轮的外在,
Another running of outer,

28
00:01:27.558 --> 00:01:32.183
另一个新的执行上下文，我们将其输出分类为另一个函数。
another new execution context, the output
of which we sort into another function.

29
00:01:32.183 --> 00:01:35.984
然后再运行另一个函数两次。
We're then gonna run
another function twice.

30
00:01:35.984 --> 00:01:38.700
让我们从最后三行开始，丹,
Let's do it down to
the last three lines Dan,

31
00:01:38.700 --> 00:01:42.426
我们在左手边讨论什么功能？
where we speak on the left hand
side here about what function?

32
00:01:42.426 --> 00:01:43.049
阿丹: 我们正在宣布。
&gt;&gt; Dan: We're declaring it.

33
00:01:43.049 --> 00:01:45.152
所以在所有的函数中，常量的作用是已经完成的。
&gt;&gt; Will Sentance: So in all function will
function what constants already done.

34
00:01:45.152 --> 00:01:47.200
阿丹: 我们在声明一个常量，另一个函数。
&gt;&gt; Dan: We're declaring
a constant another function.

35
00:01:47.200 --> 00:01:48.408
威尔 · 森特斯: 太好了，谢谢你，丹。
&gt;&gt; Will Sentance: Perfect, thank you, Dan.

36
00:01:48.408 --> 00:01:50.921
我不会再道歉了。
I will not apologize one more time.

37
00:01:50.921 --> 00:01:52.412
但我为我的道歉感到抱歉。
But I am sorry for the apologies.

38
00:01:52.412 --> 00:01:54.719
好的，另一个函数。
All right, another function.

39
00:01:54.719 --> 00:01:58.832
很好，我们现在要运行的另一个函数是什么，丹？
Good, another function we're now
gonna have to go and run what Dan?

40
00:01:58.832 --> 00:01:59.420
丹: 外面。
&gt;&gt; Dan: Outer.

41
00:01:59.420 --> 00:02:00.388
威尔 · 森特斯: 外部，完全正确。
&gt;&gt; Will Sentance: Outer, exactly.

42
00:02:00.388 --> 00:02:02.718
那么现在另一个函数是？
So for now another function is?

43
00:02:02.718 --> 00:02:03.337
丹: 不确定。
&gt;&gt; Dan: Undefined.

44
00:02:03.337 --> 00:02:06.194
威尔 · 森坦斯: 我们会说未初始化，我被分类了。
&gt;&gt; Will Sentance: We will say
uninitialized and I was assorted at all.

45
00:02:06.194 --> 00:02:10.240
我要过来这里，我可能要做我的是我的错
And I'm gonna come over here, I'm probably
have to do my is going to be my bad

46
00:02:10.240 --> 00:02:13.236
笔迹的角度，所以我们会尝试，所以另一个。
handwriting angle so
we'll give it a try, so another.

47
00:02:17.256 --> 00:02:19.064
威尔 · 句子: 逆向重写
&gt;&gt; Will Sentance: Rewriting in reverse but

48
00:02:19.064 --> 00:02:23.896
另一个函数是调用什么函数的返回值 Tod？
another function will be the return
of calling what function Tod?

49
00:02:23.896 --> 00:02:24.899
托德: 外面 威尔 · 森特斯: 外部
&gt;&gt; Tod: Outer.
&gt;&gt; Will Sentance: Outer

50
00:02:24.899 --> 00:02:27.769
什么我是一个全新的大家？
what I'm a brand new everybody?

51
00:02:27.769 --> 00:02:29.560
每个人: 执行环境。
&gt;&gt; Everyone: Execution context.

52
00:02:29.560 --> 00:02:32.699
威尔 · 森塔斯: 漂亮，就是这样。
&gt;&gt; Will Sentance: Beautiful, there it is.

53
00:02:32.699 --> 00:02:35.733
我们忘记把我的新功能从之前的酷属性弹出来了。
We forgot to pop my new function
off the cool stat from earlier.

54
00:02:35.733 --> 00:02:39.242
所以让我们摆脱它，摆脱它。
So let's get rid of,
let's get rid of that.

55
00:02:39.242 --> 00:02:40.961
好了。
There we go.

56
00:02:40.961 --> 00:02:47.364
这就是全球化。
And there it is global.

57
00:02:47.364 --> 00:02:51.007
另一个代码是外部全新的执行上下文。
And another code outer brand
new execution context.

58
00:02:51.007 --> 00:02:52.084
就是这个全新的,
There it is.
Brand new,

59
00:02:52.084 --> 00:02:55.144
我从这个角度这么做很奇怪吗？
is it that weird me doing
it from this angle, right?

60
00:02:55.144 --> 00:02:56.430
或者不，没关系？
Or no, it's okay?

61
00:02:56.430 --> 00:02:57.962
全新的本地记忆。
Brand new local memory.

62
00:02:57.962 --> 00:03:00.325
你会说，是的，看起来很奇怪。
You're like yeah, it looks really weird.

63
00:03:00.325 --> 00:03:06.010
全新的本地记忆，我们保存在里面的第一件东西是什么，伊森？
Brand new local memory, what's the first
thing we save inside of it, Ethan?

64
00:03:06.010 --> 00:03:08.268
我们现在所做的外部调用的内部,
Inside of the call to outer
we're doing right here,

65
00:03:08.268 --> 00:03:10.799
我们保存在本地记忆里的第一样东西是什么？
what's the first thing we save
inside this local memory?

66
00:03:10.799 --> 00:03:12.134
伊森: 柜台？
&gt;&gt; Ethan: Counter?

67
00:03:12.134 --> 00:03:13.330
句子: 设置什么值？
&gt;&gt; Will Sentance: Set to what value?

68
00:03:13.330 --> 00:03:14.415
伊森: 0。
&gt;&gt; Ethan: 0.

69
00:03:14.415 --> 00:03:16.870
威尔 · 森特斯: 然后我们宣布什么，伊森？
&gt;&gt; Will Sentance: And
then we declare what Ethan?

70
00:03:16.870 --> 00:03:18.550
Ethan: 新的函数增量计数。
&gt;&gt; Ethan: New function increment count.

71
00:03:18.550 --> 00:03:21.408
Will Sentance: Yeah new function increment counter.
&gt;&gt; Will Sentance: Yeah new
function increment counter.

72
00:03:21.408 --> 00:03:24.039
就是这样，省省吧。
There it is, save it.

73
00:03:24.039 --> 00:03:27.703
那我们该怎么办呢？
And what do we do with it?

74
00:03:27.703 --> 00:03:30.603
我们不叫它“我们用它做什么” ，伊森？
We don't call it we do what with it,
Ethan?

75
00:03:30.603 --> 00:03:31.365
伊森: 还给我。
&gt;&gt; Ethan: Return it.

76
00:03:31.365 --> 00:03:34.557
威尔 · 森特斯: 你认为这里的全局常量是什么？
&gt;&gt; Will Sentance: Into what global
constant do you think here?

77
00:03:34.557 --> 00:03:35.664
伊森: 另一个功能。
&gt;&gt; Ethan: Another function.

78
00:03:35.664 --> 00:03:37.513
进入另一个功能，干得好。
&gt;&gt; Will Sentance: Into another function,
well done.

79
00:03:37.513 --> 00:03:42.899
另一种情况，我只是要在这里展示它,
Into another, I'm just gonna show it here,

80
00:03:42.899 --> 00:03:45.884
转换成另一个功能。
into another function.

81
00:03:45.884 --> 00:03:46.439
就是这个。
There it is.

82
00:03:46.439 --> 00:03:51.026
出来就变成了另一个函数。
Out it comes into another function.

83
00:03:51.026 --> 00:03:56.626
进入另一个功能，它来了，但是等等，伙计们，我真的搞砸了。
Into another function, it comes, but
wait, people, I really messed that up.

84
00:03:56.626 --> 00:03:58.413
我忘记做什么了？
What did I forgot to do?

85
00:03:58.413 --> 00:04:02.734
到底发生了什么谁想告诉我到底发生了什么,
What actually happened, who wants
to tell me what actually happened,

86
00:04:02.734 --> 00:04:07.139
当我在第二次运行的 outer 中声明 incrementCounter 时。
when I declared incrementCounter
inside this second running of outer.

87
00:04:07.139 --> 00:04:08.901
当我在内部声明增量计数器时,
When I declared increment counter inside,

88
00:04:08.901 --> 00:04:11.909
如果你想告诉我当时到底发生了什么，请举手。
raise your hand if you wanna tell me
what actually happened at that moment.

89
00:04:11.909 --> 00:04:13.152
Peter 求你了。
Peter, please.

90
00:04:13.152 --> 00:04:18.065
Peter: 你还得到了一个与局部变量环境的关系。
&gt;&gt; Peter: You also got a bond to
the local variable environment.

91
00:04:18.065 --> 00:04:19.704
威尔 · 森塔斯: 这个说法太妙了。
&gt;&gt; Will Sentance: That's
fantastically put.

92
00:04:19.704 --> 00:04:21.254
通过什么隐藏的财产？
Through what hidden property?

93
00:04:21.254 --> 00:04:22.060
彼得: 通过望远镜。
&gt;&gt; Peter: Through scope.

94
00:04:22.060 --> 00:04:23.625
是的，通过隐藏范围属性。
&gt;&gt; Will Sentance: Yeah,
through the hidden scope property.

95
00:04:23.625 --> 00:04:29.896
这意味着当我将该函数返回到另一个函数时,
Meaning when I return that function out
increment counter into another function,

96
00:04:29.896 --> 00:04:35.644
我把所有本地数据都带来了包括什么 Kayla？
I brought with attached all that local
data, which included what, Kayla?

97
00:04:35.644 --> 00:04:37.634
那个当地的背包里有什么？
What's in that local, in that backpack?

98
00:04:37.634 --> 00:04:38.245
柜台。
&gt;&gt; Kayla: Counter.

99
00:04:38.245 --> 00:04:39.740
威尔 · 森特斯: 是字面上的设置是什么？
&gt;&gt; Will Sentance: Is
literally set to what?

100
00:04:39.740 --> 00:04:40.297
凯拉: 0。
&gt;&gt; Kayla: 0.

101
00:04:40.297 --> 00:04:43.197
是字面上存储为0，这就是它。
&gt;&gt; Will Sentance: Is literally
stored as 0, and there it is.

102
00:04:43.197 --> 00:04:48.173
这是附在，威尔 · 森塔斯: 我没有
And that is attached on,
&gt;&gt; Will Sentance: I'm not

103
00:04:48.173 --> 00:04:51.191
我本来想说的，但是我本来想放下的，好吗，就是这样，好吗？
meant to say this, but I meant to
leave it, okay, there it is, okay?

104
00:04:51.191 --> 00:04:55.393
所以现在我要跑了，我要在这里做，伙计们。
So now I'm gonna run,
I'm just gonna do it here, people.

105
00:04:55.393 --> 00:04:59.153
我要走了，我可能没钱了。
I'm gonna run, I am probably out of short.

106
00:04:59.153 --> 00:05:03.966
我打算再经营一家公司，威尔 · 森坦斯: 那也是
I am gonna run anotherfFnction,
&gt;&gt; Will Sentance: That's too

107
00:05:03.966 --> 00:05:06.615
这个角度慢一点，另一个函数两次。
slow with that angle,
anotherFunction twice.

108
00:05:06.615 --> 00:05:10.483
所以这里有个大问题，伙计们。
So here's the big question, folk.

109
00:05:10.483 --> 00:05:15.264
Brayden，我调用过一次我的新函数，我又调用了一次。
Brayden, I've called my new function once,
I've called it again.

110
00:05:15.264 --> 00:05:22.298
然后我拉出另一个函数，再调用一次。
Then I pull another function once,
and I call it again.

111
00:05:22.298 --> 00:05:27.783
Brayden，如果我要控制日志，我在控制台中看到什么值
Brayden, what values do I see in my
console if I were to console log

112
00:05:27.783 --> 00:05:34.683
在这些功能之后的 mechanicus + ，控制台或价值帐户？
inside of these functions after mechanicus
plus, console or the value account?

113
00:05:34.683 --> 00:05:39.533
我的计数器值会是来自这四个函数调用我的新函数
What would my counter values be from those
four function calls two my new function

114
00:05:39.533 --> 00:05:41.475
其中两个还有另一个功能。
and two have another function.

115
00:05:41.475 --> 00:05:43.105
我能看到什么，布雷登？
What would I see, Brayden?

116
00:05:43.105 --> 00:05:45.112
布雷登: 我会走一二，一二。
&gt;&gt; Brayden: I would go one two, one two.

117
00:05:45.112 --> 00:05:46.307
威尔 · 森坦斯: 他说得对吗？
&gt;&gt; Will Sentance: Is he right?

118
00:05:46.307 --> 00:05:47.692
他说对了。
He's spot on.

119
00:05:47.692 --> 00:05:49.274
为什么是布雷登？
And why is that Brayden?

120
00:05:49.274 --> 00:05:51.723
布雷登: 因为我的新功能背包和美元的背包
&gt;&gt; Brayden: Because the backpack for
my new function and a backpack for

121
00:05:51.723 --> 00:05:53.779
另一个功能是两个不同的背包。
another function are two
different backpacks.

122
00:05:53.779 --> 00:05:54.810
威尔 · 桑塔斯: 完全不同的背包。
&gt;&gt; Will Sentance: Totally
different backpacks.

123
00:05:54.810 --> 00:05:58.103
他们是在一个全新的、完全冷静的执行环境中被创造出来的
They were created in brand new
totally sober execution context for

124
00:05:58.103 --> 00:06:00.113
完全不同的跑道。
totally different runnings for outer.

125
00:06:00.113 --> 00:06:01.452
他说对了。
He’s spot on.

126
00:06:01.452 --> 00:06:03.153
外层是从一个很酷的堆栈里弹出来的。
Outer was popped off a cool stack.

127
00:06:03.153 --> 00:06:07.980
但是当它在那里的时候，它创造了全新的执行环境
But when it was on there, it created
brand new execution context with

128
00:06:07.980 --> 00:06:11.822
一个全新的储存增量计数器功能。
a brand new stored saved
increment counter function.

129
00:06:11.822 --> 00:06:14.365
全新保存的增量计数器功能。
Brand new saved increment
counter function there it is.

130
00:06:14.365 --> 00:06:16.601
我们把它返回到另一个函数中
And we returned that out
into another function and

131
00:06:16.601 --> 00:06:19.699
带来了一个全新的储存国家0商店这个背包。
brought with it a brand new stored
countries 0 store this backpack.

132
00:06:19.699 --> 00:06:23.540
我们不仅得到很少的私人背包数据，而且
We get not only little
private backpacks of data but

133
00:06:23.540 --> 00:06:28.016
每个单独的函数从我们运行的 outer 中得到一个。
each individual function gets
one from our running outer.

134
00:06:28.016 --> 00:06:32.293
非常，非常漂亮的外观划分数据来源。
Very, very nice look
compartmentalised source of data.

135
00:06:32.293 --> 00:06:34.255
让我们做一些其他的调整。
Let's make a couple of other adjustments.

136
00:06:34.255 --> 00:06:39.057
让我们试试这个，如果我要，在增量计数器里面
Let's try this one if I were to,
inside of increment counter

137
00:06:39.057 --> 00:06:44.158
之前我做了柜台加，加上工人声明柜台是0。
before I did counter plus,
plus workers declare counter is 0.

138
00:06:44.158 --> 00:06:46.622
我们的柜台在这里，柜台在这里，柜台在这里。
So our counters here,
counters here, counters here.

139
00:06:46.622 --> 00:06:50.863
如果我有的话，我在控制台上的价值会是多少
What would my, value in the console
told be of counter if I had

140
00:06:50.863 --> 00:06:55.454
我的计数器是零声明每次增量计数器？
my counter is zero declared each
time inside increment counter?

141
00:06:55.454 --> 00:06:57.125
布雷登: 一个一个。
&gt;&gt; Brayden: The one one one one.

142
00:06:57.125 --> 00:07:00.310
威尔 · 森特斯: 一个一个点上，因为那个局部记忆全部
&gt;&gt; Will Sentance: One one one spot
on because that local memory all

143
00:07:00.310 --> 00:07:03.502
那是每次都被删除的计数器。
that's counters getting
deleted every time.

144
00:07:03.502 --> 00:07:06.259
我要计算这里的0递增。
I'm going to counter is
zero in here incremented.

145
00:07:06.259 --> 00:07:07.978
把它记录下来然后就没了。
Console.log it, and then it's gone.

146
00:07:07.978 --> 00:07:09.733
再做一次，console.log 它，它就消失了。
Do it again, console.log it,
and it's gone.

147
00:07:09.733 --> 00:07:12.223
没有细节存储在后台。
No niceties stored in the background.

148
00:07:12.223 --> 00:07:14.127
顺便说一下，这只是一个范围规则。
And by the way, that's just a scope rule.

149
00:07:14.127 --> 00:07:17.786
在 JavaScript 中，只要你点击一个标签，一个标识符
As soon as, in JavaScript,
you hit a label, an identifier for

150
00:07:17.786 --> 00:07:21.937
一个非常漂亮的数据，你改变它，你使用它，它就完成了。
a very beautiful data, you change it,
and you use it, and it's done.

151
00:07:21.937 --> 00:07:23.959
你不能再往前走了。
You don't go any further out.

152
00:07:23.959 --> 00:07:26.762
你可以再一次想象一种语言，你可以看到所有的方式，并且
You could again imagine a language
where you looked all the way out, and

153
00:07:26.762 --> 00:07:27.427
把他们都杀了。
hit all of them.

154
00:07:27.427 --> 00:07:30.699
但是这就像我们认为这些事情本质上是正确的时候，范围就不是了。
But that's like scope is not when we
think of these things as inherently true.

155
00:07:30.699 --> 00:07:34.125
它们只是开发者或创造者设计的决策，就像我们一样
They're just designed decisions by
developer or creators like us have

156
00:07:34.125 --> 00:07:37.947
可编程的，疯狂的编程语言，像我们一样的开发者,
programmable, crazy programming languages
who are developers just like us,

157
00:07:37.947 --> 00:07:39.957
和我们一样都是软件工程师。
who are software engineers just like us.

158
00:07:39.957 --> 00:07:43.322
他们选择当你点击计数器的时候，在本地是零
And they choose that when you
hit counter is zero in the local

159
00:07:43.322 --> 00:07:45.552
如果我们在内部声明它。
memory if we had declared it inside of.

160
00:07:45.552 --> 00:07:49.659
增量计数器是零种尽可能的改变它在这里
Increment counter counter is zero kind
of as possible have changed it in here

161
00:07:49.659 --> 00:07:50.822
每次都是全新的。
brand new each time.

162
00:07:50.822 --> 00:07:54.468
那样的话，我们就不能再往外走了。
Well that would not allow
us to go any further out.

163
00:07:54.468 --> 00:07:58.903
如果我们从来没有声明计数器是0里面的外部在所有这样
What if we never declared counter is
0 inside of outer at all such that

164
00:07:58.903 --> 00:08:03.038
返回功能没有在他的背包里。
the returned out function didn't
get counter in his backpack.

165
00:08:03.038 --> 00:08:06.879
但是我们在全局计数器中声明是0。
But instead we declared
in global counter is 0.

166
00:08:06.879 --> 00:08:11.259
彼得，如果我每次控制台登录计数器，我会在控制台上看到什么？
Peter, what would I see in my console if I
were to console log the counter each time?

167
00:08:11.259 --> 00:08:12.552
布雷登: 我需要1,2,3,4。
&gt;&gt; Brayden: I need to 1, 2, 3, 4.

168
00:08:12.552 --> 00:08:13.841
威尔 · 森塔斯: 1,2,3,4，完全正确。
&gt;&gt; Will Sentance: 1, 2, 3, 4, exactly.

169
00:08:13.841 --> 00:08:17.648
我们一路走到全球，在那里改变它。
We go all the way out to global and
change it there.

170
00:08:17.648 --> 00:08:19.245
正中人心。
Spot on people.

171
00:08:19.245 --> 00:08:25.170
好的，这就是我们的核心原则。
All right, that is our core
principles of closure under the hood.

172
00:08:25.170 --> 00:08:26.658
好了，我们开始吧。
Now, yeah here we go.

173
00:08:26.658 --> 00:08:27.572
个人背包。
Individual backpacks.

174
00:08:27.572 --> 00:08:29.293
如果我们再跑到这里
If we run out here again and

175
00:08:29.293 --> 00:08:34.779
在另一个函数中存储返回的增量计数器函数定义,
store the return the increment counter
function definition in another function,

176
00:08:34.779 --> 00:08:39.735
在另一个功能中，带上全新的储存数据的背包。
in another function, bring with it its
brand new stored backpack of data.

177
00:08:39.735 --> 00:08:42.945
这个新的增量计数器函数是在新的执行上下文中创建的,
This new increment counter function was
created in a new execution context,

178
00:08:42.945 --> 00:08:45.129
因此，全新的独立数据背包。
therefore brand new
independent backpack of data.

179
00:08:45.129 --> 00:08:49.563
然后我们运行另一个函数，我们从它的背包里拿出计数器。
And we run another function, we go and
grab the counter from its backpack.
