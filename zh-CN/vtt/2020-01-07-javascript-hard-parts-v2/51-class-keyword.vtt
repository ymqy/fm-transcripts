WEBVTT

1
00:00:00.190 --> 00:00:01.209
威尔 · 森特斯: 让我们看看，解决方案3,
威尔 · 森特斯: 让我们看看，解决方案3,
&gt;&gt; Will Sentance: Let's see, solution 3,

2
00:00:01.209 --> 00:00:03.589
关键词，自动化的艰苦工作，新。
关键词，自动化的艰苦工作，新。
the keyword that automates the hard work,
new.

3
00:00:03.589 --> 00:00:05.500
好处，写得更快，我明白了。
好处，写得更快，我明白了。
Benefits, faster to write, I get it.

4
00:00:05.500 --> 00:00:07.110
看看这些蓝色，那不再是我们写的了。
看看这些蓝色，那不再是我们写的了。
Look at all the blue,
that wasn't us writing anymore.

5
00:00:08.609 --> 00:00:10.939
经常用于专业领域。
经常用于专业领域。
Often still used professionally.

6
00:00:10.939 --> 00:00:14.310
其中很大一部分是这样的，但是我们会看到，解决方案4稍微改变了它。
其中很大一部分是这样的，但是我们会看到，解决方案4稍微改变了它。
And a big part of it is, but we'll see,
solution 4 changes it slightly.

7
00:00:14.310 --> 00:00:19.329
问题---- 95% 的开发人员不知道它是如何在引擎盖下工作的。
问题---- 95% 的开发人员不知道它是如何在引擎盖下工作的。
Problems, 95% of developers have no
idea how it's working under the hood.

8
00:00:19.329 --> 00:00:23.949
我认为因此失败的面试，有一点雇佣兵的动机去学习,
我认为因此失败的面试，有一点雇佣兵的动机去学习,
I think therefore fail interview, there's
a slightly mercenary motivation to learn,

9
00:00:23.949 --> 00:00:29.920
因此不能一直调试和构建干净可靠的代码。
因此不能一直调试和构建干净可靠的代码。
and therefore can't debug and build
clean and reliable code all the time.

10
00:00:29.920 --> 00:00:32.399
这里还有一个小问题，这是设计,
这里还有一个小问题，这是设计,
Here's another little problem with it,
this is the design,

11
00:00:32.399 --> 00:00:37.219
我会说，流不是流，这是一个不明智的设计举措。
我会说，流不是流，这是一个不明智的设计举措。
I would say, flow not a flow,
it's a not smart design move.

12
00:00:37.219 --> 00:00:41.229
这个用户创建一个函数，如果我运行它没有新的关键字,
这个用户创建一个函数，如果我运行它没有新的关键字,
That user create a function if I
ran it without the new keyword,

13
00:00:41.229 --> 00:00:42.159
我在代码库里找到的。
我在代码库里找到的。
I found it in the code base.

14
00:00:42.159 --> 00:00:44.579
当我运行我的团队，我开始运行没有新的关键字。
当我运行我的团队，我开始运行没有新的关键字。
And when I was running my team and
I started running without the new keyword.

15
00:00:44.579 --> 00:00:51.829
对于物体中的六个物质，这个结果会是什么呢？
对于物体中的六个物质，这个结果会是什么呢？
What would the this end up that I refer
to in order to six stuff in the object?

16
00:00:51.829 --> 00:00:53.031
它会指向布莱登什么？
它会指向布莱登什么？
What would it point to Braden?

17
00:00:53.031 --> 00:00:53.929
布雷顿: 全球化。
布雷顿: 全球化。
&gt;&gt; Braydon: The global.

18
00:00:53.929 --> 00:00:59.039
威尔 · 森塔斯: 这个全球性的物体，虽然知道它很伟大，但是,
威尔 · 森塔斯: 这个全球性的物体，虽然知道它很伟大，但是,
&gt;&gt; Will Sentance: The global object,
as know great as it and yet,

19
00:00:59.039 --> 00:01:02.152
你可能会说，很明显我需要新的关键词，对吧？
你可能会说，很明显我需要新的关键词，对吧？
you might say, well, it's kinda obvious
I need to have the new keyword, right?

20
00:01:02.152 --> 00:01:03.420
所以我们要这么早就拿到这个。
所以我们要这么早就拿到这个。
So we're gonna get this so early.

21
00:01:03.420 --> 00:01:06.810
这不是因为我可能有其他代码之前，这是甚至在那里。
这不是因为我可能有其他代码之前，这是甚至在那里。
It kind of isn't because I might have
other code before that this is even there.

22
00:01:06.810 --> 00:01:08.980
我可能有一个函数声明我正在使用它,
我可能有一个函数声明我正在使用它,
I might have like a function
declared that I am using it,

23
00:01:08.980 --> 00:01:11.700
这个函数可能就在这个函数内部。
这个函数可能就在这个函数内部。
that this might be inside
the function that this equals.

24
00:01:11.700 --> 00:01:16.670
关键是我不知道当我看到这个函数时，它需要一个新的
关键是我不知道当我看到这个函数时，它需要一个新的
The point is I do not know when I look
at that function that it requires a new

25
00:01:16.670 --> 00:01:19.230
关键字来完成它的工作。
关键字来完成它的工作。
keyword in order to do its job.

26
00:01:19.230 --> 00:01:23.170
这可能不是最明智的设计决策，对吧？
这可能不是最明智的设计决策，对吧？
That is probably not the smartest
design decision, right?

27
00:01:23.170 --> 00:01:25.890
你可能希望能够看到函数,
你可能希望能够看到函数,
You probably tend to want to be able
to look at the function and go,

28
00:01:25.890 --> 00:01:29.334
我知道这需要一个新的关键词来做任何有用的事情。
我知道这需要一个新的关键词来做任何有用的事情。
I know that that requires a new
key word to do anything useful.

29
00:01:30.960 --> 00:01:33.549
所以开发者们互相帮助。
所以开发者们互相帮助。
So developers helped each other out.

30
00:01:33.549 --> 00:01:36.439
如果你能想象这种语言，如果它是一个函数
如果你能想象这种语言，如果它是一个函数
If you can imagine the language
where if it's going to be a function

31
00:01:36.439 --> 00:01:39.590
要求是自动化的东西，你不会声明它的功能
要求是自动化的东西，你不会声明它的功能
that requires is going to automate stuff,
you wouldn't declare it with function you

32
00:01:39.590 --> 00:01:43.150
构造函数是一个典型的术语
构造函数是一个典型的术语
declare it with and
the constructor is a typical term for

33
00:01:43.150 --> 00:01:45.879
任何创建对象的东西。
任何创建对象的东西。
anything that creates
constructs an object.

34
00:01:45.879 --> 00:01:47.020
但是 JavaScript 没有做到这一点。
但是 JavaScript 没有做到这一点。
But JavaScript didn't do that.

35
00:01:47.020 --> 00:01:50.409
他们说，没有问题是功能，留下它作为常规功能。
他们说，没有问题是功能，留下它作为常规功能。
They said no problem is functions,
leaving it as regular function.

36
00:01:50.409 --> 00:01:54.379
然后在运行函数时预先插入三个 new 字母。
然后在运行函数时预先插入三个 new 字母。
And then insert three letters beforehand
new when you run the function.

37
00:01:54.379 --> 00:01:55.549
我不知道。
我不知道。
I don't know.

38
00:01:55.549 --> 00:01:56.546
这可不是什么好主意
这可不是什么好主意
That's not ideal for

39
00:01:56.546 --> 00:01:59.770
你的团队成员喜欢，如果你写评论告诉他们，但。
你的团队成员喜欢，如果你写评论告诉他们，但。
your team members who are like if
you write comments to tell them but.

40
00:01:59.770 --> 00:02:04.233
那么，开发人员在短时间内做了什么来互相帮助呢
那么，开发人员在短时间内做了什么来互相帮助呢
So what did developers in a short
hand do to help each other out so

41
00:02:04.233 --> 00:02:08.950
他们知道当他们看到一个函数，它需要一个新的关键字
他们知道当他们看到一个函数，它需要一个新的关键字
that they know when they see a function
that it needs a new keyword in

42
00:02:08.950 --> 00:02:12.229
为了完成它的工作？
为了完成它的工作？
front of it in order to do it's job?

43
00:02:12.229 --> 00:02:14.080
好的，说吧，亚当。
好的，说吧，亚当。
Yeah, go ahead Adam.

44
00:02:14.080 --> 00:02:14.889
亚当: 大写。
亚当: 大写。
&gt;&gt; Adam: Capitalize.

45
00:02:14.889 --> 00:02:16.110
威尔 · 句子: 第一个字母大写。
威尔 · 句子: 第一个字母大写。
&gt;&gt; Will Sentance: Capitalize
the first letter.

46
00:02:16.110 --> 00:02:19.379
这就是为什么你不会看到，当你看到一个新的关键字被使用在前面
这就是为什么你不会看到，当你看到一个新的关键字被使用在前面
And that's why you won't see, whenever you
see a new keyword being used in front of

47
00:02:19.379 --> 00:02:21.620
这个函数有一个大写字母。
这个函数有一个大写字母。
a function the function
will have an upper case.

48
00:02:21.620 --> 00:02:25.060
它没有任何意义，对代码没有任何影响。
它没有任何意义，对代码没有任何影响。
It doesn't have any meaning,
it doesn't have any impact to the code.

49
00:02:25.060 --> 00:02:28.969
就是互相帮助，互相帮助才能认出来
就是互相帮助，互相帮助才能认出来
Is just to help each other help
folk out to be able to spot

50
00:02:28.969 --> 00:02:30.629
这个函数需要一个新的关键字。
这个函数需要一个新的关键字。
that this function needs a new keyword.

51
00:02:30.629 --> 00:02:35.270
这显然是需要改进的地方。
这显然是需要改进的地方。
That is clearly something that
probably needed to be improved.

52
00:02:35.270 --> 00:02:36.819
这就是解决方案4的用武之地。
这就是解决方案4的用武之地。
And that is where solution 4 came in.

53
00:02:36.819 --> 00:02:39.389
我们必须首先提倡我们知道它需要新的功能之一
我们必须首先提倡我们知道它需要新的功能之一
We had to advocate first one of
the functions we know it requires new

54
00:02:39.389 --> 00:02:41.039
我们研究过的关键词。
我们研究过的关键词。
keywords we've worked.

55
00:02:41.039 --> 00:02:42.620
这就是解决方案4出现的地方。
这就是解决方案4出现的地方。
And that's where solution 4 came along.

56
00:02:42.620 --> 00:02:45.219
布糖。
布糖。
The cloth syntactic sugar.

57
00:02:45.219 --> 00:02:46.490
但它是一种语法糖。
但它是一种语法糖。
But it is a syntactic sugar.

58
00:02:46.490 --> 00:02:48.909
这意味着一些东西可以改变它的外观，但是
这意味着一些东西可以改变它的外观，但是
That means something that
changes the way it looks, but

59
00:02:48.909 --> 00:02:49.930
也改变不了什么。
也改变不了什么。
doesn't change it under the hood.

60
00:02:49.930 --> 00:02:52.789
为了我们的目的，为了这一点，我们将要使用它在这里的方式,
为了我们的目的，为了这一点，我们将要使用它在这里的方式,
For our purposes, for this bit here,
the way we're going to use it here,

61
00:02:52.789 --> 00:02:56.139
这改变不了什么。
这改变不了什么。
it doesn't change anything under the hood.

62
00:02:56.139 --> 00:02:57.909
有两个因素促成了这一结果。
有两个因素促成了这一结果。
Two things motivate this.

63
00:02:58.939 --> 00:03:04.710
它出现在2015年，ES6，在宣布
它出现在2015年，ES6，在宣布
It came along in the year 2015,
ES6, In declaring

64
00:03:04.710 --> 00:03:10.250
我们的功能用户创建器，当执行时
我们的功能用户创建器，当执行时
our function user creator, when executed

65
00:03:10.250 --> 00:03:14.469
使用新的关键字 help 自动返回一个对象到 user1。
使用新的关键字 help 自动返回一个对象到 user1。
automatically with the new keywords
help returns out an object into user1.

66
00:03:14.469 --> 00:03:20.340
再次运行它会将一个对象返回到 user2，这里有两个重要的部分。
再次运行它会将一个对象返回到 user2，这里有两个重要的部分。
Run it again will return an object into
user2, there's two important parts to it.

67
00:03:20.340 --> 00:03:23.270
这是自动生成对象的函数。
这是自动生成对象的函数。
There's the function that produces
the object automatically.

68
00:03:23.270 --> 00:03:26.229
然后还有共享的函数存储。
然后还有共享的函数存储。
And then there's the shared
store of functions.

69
00:03:26.229 --> 00:03:28.969
它们都捆绑在同一个功能对象组合上。
它们都捆绑在同一个功能对象组合上。
They're all bundled up on
the same functional object combo.

70
00:03:30.689 --> 00:03:35.469
但是我们向 JavaScript 分别宣布了这两个部分。
但是我们向 JavaScript 分别宣布了这两个部分。
But we announced to JavaScript
the two parts separately.

71
00:03:35.469 --> 00:03:37.594
我们声明用户创建器，它创建一个函数，然后
我们声明用户创建器，它创建一个函数，然后
We declare user creator,
that creates a function and

72
00:03:37.594 --> 00:03:40.057
一个有原型属性的对象和一个对象。
一个有原型属性的对象和一个对象。
an object with a prototype property
on it with an object to it.

73
00:03:40.057 --> 00:03:45.849
我们可以完全独立地存储这些功能。
我们可以完全独立地存储这些功能。
Which we can store then totally,
independently, the functions.

74
00:03:45.849 --> 00:03:51.129
在其他语言中，这两件事是紧密相连的，对吗？
在其他语言中，这两件事是紧密相连的，对吗？
In other languages, these two things are
so kind of intimately connected, right?

75
00:03:51.129 --> 00:03:54.819
这是有意义的，这个函数运行时创建一个对象，返回它,
这是有意义的，这个函数运行时创建一个对象，返回它,
It makes sense, this function when it
runs creates an object, returns it out,

76
00:03:54.819 --> 00:03:56.620
这个对象可以访问这些函数。
这个对象可以访问这些函数。
and that object has access
to these functions.

77
00:03:56.620 --> 00:03:58.280
所以它们就像是紧密相连的。
所以它们就像是紧密相连的。
So they're like intimately connected.

78
00:03:58.280 --> 00:03:59.770
在其他语言中。
在其他语言中。
In other languages you.

79
00:03:59.770 --> 00:04:02.080
即使在 JavaScript 中，它们也是紧密相连的
即使在 JavaScript 中，它们也是紧密相连的
Even in JavaScript,
they're intimately connected and

80
00:04:02.080 --> 00:04:04.389
他们用的是同一个功能性物体组合。
他们用的是同一个功能性物体组合。
they're on the same
functional object combo.

81
00:04:05.460 --> 00:04:09.270
但是在其他语言中，你可以一起声明它们。
但是在其他语言中，你可以一起声明它们。
But in other languages you
can declare them together.

82
00:04:09.270 --> 00:04:14.319
知道在运行时声明的函数返回一个对象的访问权限
知道在运行时声明的函数返回一个对象的访问权限
Know declaring the function who when run
returns out an object that has access to

83
00:04:14.319 --> 00:04:16.269
完全分开申报。
完全分开申报。
totally separately declared.

84
00:04:16.269 --> 00:04:20.769
在项目属性中出售的原型对象中的函数,
在项目属性中出售的原型对象中的函数,
The functions that go into the prototype
object sold on the project property,

85
00:04:20.769 --> 00:04:24.240
对不起，项目属性上的对象，所有的函数对象组合。
对不起，项目属性上的对象，所有的函数对象组合。
sorry that the objects on the project
property, all that function object combo.

86
00:04:24.240 --> 00:04:27.290
所以是的，它们存放在一起,
所以是的，它们存放在一起,
So yes, they are stored together,

87
00:04:27.290 --> 00:04:32.389
但是它们没有被声明，这意味着我们不会一起将它们编写到 JavaScript 中。
但是它们没有被声明，这意味着我们不会一起将它们编写到 JavaScript 中。
but they're not declared that means we
don't write them to JavaScript together.

88
00:04:32.389 --> 00:04:35.379
我们不会同时写作业说明来实现这两个目标。
我们不会同时写作业说明来实现这两个目标。
We don't write the instructions of jobs
to achieve those two things together.

89
00:04:35.379 --> 00:04:36.909
我们不把它们写在一起，我们分开运行。
我们不把它们写在一起，我们分开运行。
We don't write them together,
we run separately.

90
00:04:38.319 --> 00:04:42.129
另一种语言是我们在一个结构中一次完成所有的工作,
另一种语言是我们在一个结构中一次完成所有的工作,
Another language is we do that all
in one construct, in all in one go,

91
00:04:42.129 --> 00:04:45.240
都是一种格式。
都是一种格式。
all in one format.

92
00:04:45.240 --> 00:04:48.870
这种格式的人，任何人都知道这个构造叫什么
这种格式的人，任何人都知道这个构造叫什么
And that format people,
anyone know what that construct's called

93
00:04:48.870 --> 00:04:51.649
能让我们一起做这些同时保存这些 Peter？
能让我们一起做这些同时保存这些 Peter？
that allows us to do these together,
save these at the same time, Peter?

94
00:04:51.649 --> 00:04:52.269
亚当: 一个子句。
亚当: 一个子句。
&gt;&gt; Adam: A clause.

95
00:04:52.269 --> 00:04:53.959
威尔 · 句子: 一个确切的子句。
威尔 · 句子: 一个确切的子句。
&gt;&gt; Will Sentance: A clause exactly.

96
00:04:53.959 --> 00:04:55.800
是宣读从句，彼得。
是宣读从句，彼得。
It's pronounced clause, Peter.

97
00:04:55.800 --> 00:04:56.300
亚当: 对不起。
亚当: 对不起。
&gt;&gt; Adam: Sorry.

98
00:04:57.590 --> 00:05:02.519
威尔 · 森塔斯: 这是个玩笑，显然是个玩笑，一个确切的条款，我们开始吧。
威尔 · 森塔斯: 这是个玩笑，显然是个玩笑，一个确切的条款，我们开始吧。
&gt;&gt; Will Sentance: That's a joke, obviously
joke, a clause exactly, there we go.

99
00:05:02.519 --> 00:05:05.399
但是彼得，你是那么的善良，有人指出你不是。
但是彼得，你是那么的善良，有人指出你不是。
But Peter, you're so
kind that you were pointed out you do not.

100
00:05:06.639 --> 00:05:09.850
你真的是一个非常非常好的人。
你真的是一个非常非常好的人。
You truly in a very, very nice person.

101
00:05:09.850 --> 00:05:12.701
不像我，所以我们写我分享的方法,
不像我，所以我们写我分享的方法,
Unclearly unlike myself, so
we're writing I shared methods,

102
00:05:12.701 --> 00:05:14.718
这些方法被所有人共享。
这些方法被所有人共享。
these methods that get
shared by all others.

103
00:05:14.718 --> 00:05:21.192
实际上，让我们只是帮助自己在这里有一个用户701,
实际上，让我们只是帮助自己在这里有一个用户701,
Actually let's just to help
ourselves out here have a user 701,

104
00:05:21.192 --> 00:05:26.643
再次运行用户创建器就会出现这种情况,
再次运行用户创建器就会出现这种情况,
which would have come out of
running user creator again,

105
00:05:26.643 --> 00:05:30.504
我们还是在这里做吧，以防万一,
我们还是在这里做吧，以防万一,
let's actually do it here just in case,

106
00:05:30.504 --> 00:05:36.088
用户701，另一个调用用户 Creator 的结果。
用户701，另一个调用用户 Creator 的结果。
user 701 with a result of
another call to user Creator.

107
00:05:36.088 --> 00:05:42.932
让我们假设 Sarah 和19岁，以及在前面的新的关键词
让我们假设 Sarah 和19岁，以及在前面的新的关键词
Let's say with Sarah and 19 and
the new key word of course in front and

108
00:05:42.932 --> 00:05:47.600
会返回到用户701。
会返回到用户701。
that would have returned
out into user 701.

109
00:05:47.600 --> 00:05:55.019
这次让我们把这个问题解决，得到这个对象
这次让我们把这个问题解决，得到这个对象
And this time let's get this right,
have the object

110
00:05:55.019 --> 00:05:59.350
原始财产达到
原始财产达到
with the proto property up to

111
00:06:02.790 --> 00:06:07.807
共享对象的名字 Sarah,
共享对象的名字 Sarah,
the shared object and then name, Sarah,

112
00:06:07.807 --> 00:06:12.750
19分。
19分。
score 19.

113
00:06:14.360 --> 00:06:17.430
每个人都能得到这部分，我希望这不会让人。
每个人都能得到这部分，我希望这不会让人。
Everyone gets this portion here,
I hope that's not throwing people.

114
00:06:17.430 --> 00:06:24.639
这两个对象，它们都可以访问这些共享的函数、方法。
这两个对象，它们都可以访问这些共享的函数、方法。
Those two objects, they both have access
to these shared functions, methods.

115
00:06:26.230 --> 00:06:28.572
我们把它们保存在同一个功能组合中，但是
我们把它们保存在同一个功能组合中，但是
We're saving them on the same
functional combo, but

116
00:06:28.572 --> 00:06:32.730
我们正在宣布他们，威尔 · 森塔斯: 分开。
我们正在宣布他们，威尔 · 森塔斯: 分开。
we're declaring them,
&gt;&gt; Will Sentance: Separately.

117
00:06:33.860 --> 00:06:35.430
让我们在一个地方做这一切。
让我们在一个地方做这一切。
Let's do it all in one place.

118
00:06:35.430 --> 00:06:38.420
类的结构让我们可以做到这一点。
类的结构让我们可以做到这一点。
And the class construct lets us do that.

119
00:06:38.420 --> 00:06:41.850
在这里，它是句法甜言蜜语，我实际上要直接到这里。
在这里，它是句法甜言蜜语，我实际上要直接到这里。
Here it is, it's syntactic sugar folk,
I'm actually going to go straight to here.

120
00:06:43.779 --> 00:06:45.610
这是我们之前做的两部分，对吗？
这是我们之前做的两部分，对吗？
These were the two parts we did before,
right?

121
00:06:45.610 --> 00:06:47.601
记住，我们创建了函数用户,
记住，我们创建了函数用户,
Remember, we got our
function user created,

122
00:06:47.601 --> 00:06:49.348
创建一个函数对象组合。
创建一个函数对象组合。
which creates a function object combo.

123
00:06:49.348 --> 00:06:54.939
虽然当它运行的时候会在内部创建一个新的关键字,
虽然当它运行的时候会在内部创建一个新的关键字,
Though when it's run Will create
inside of itself with a new keyword,

124
00:06:54.939 --> 00:06:59.773
一个对象首次存储 user1，存储 user701,
一个对象首次存储 user1，存储 user701,
an object storing user1 first time,
storing user 701,

125
00:06:59.773 --> 00:07:05.386
第701次每个人都可以访问这个充满功能的对象。
第701次每个人都可以访问这个充满功能的对象。
701st time that each have access
to this object full of functions.

126
00:07:05.386 --> 00:07:08.170
用户创建器.prototype.increment。
用户创建器.prototype.increment。
User creator.prototype.increment.

127
00:07:08.170 --> 00:07:10.620
用户创建者.prototype.login。
用户创建者.prototype.login。
User creator.prototype.login.

128
00:07:10.620 --> 00:07:11.629
我们在那里拯救他们。
我们在那里拯救他们。
We save them there.

129
00:07:13.329 --> 00:07:16.170
现在一切都没有改变。
现在一切都没有改变。
Now nothing has changed under the hood.

130
00:07:16.170 --> 00:07:21.329
我们只需要做这两个单独的声明或者分配
我们只需要做这两个单独的声明或者分配
We just get to do these two separate
declarations or assignments

131
00:07:21.329 --> 00:07:26.560
在一个结构中，我们称之为类。
在一个结构中，我们称之为类。
in one construct, we call it a class.

132
00:07:26.560 --> 00:07:33.110
我们接受函数的标签，我们让你接受类的标签。
我们接受函数的标签，我们让你接受类的标签。
We take the label of the function and
we make you the label of the class.

133
00:07:33.110 --> 00:07:36.526
一旦你宣布一个类，我们认为我们得到了什么人？
一旦你宣布一个类，我们认为我们得到了什么人？
As soon as you declare a class,
what do we think we get people?

134
00:07:39.370 --> 00:07:40.310
威尔 · 森特斯: 丹 阿丹: 一个物体。
威尔 · 森特斯: 丹 阿丹: 一个物体。
&gt;&gt; Will Sentance: Dan?
&gt;&gt; Dan: An object.

135
00:07:40.310 --> 00:07:41.889
我们得到了一个函数对象组合。
我们得到了一个函数对象组合。
&gt;&gt; Will Sentance: We get
a function object combo.

136
00:07:45.077 --> 00:07:46.040
威尔 · 森特斯: 我们得到一个物体，是的。
威尔 · 森特斯: 我们得到一个物体，是的。
&gt;&gt; Will Sentance: We get an object, yes.

137
00:07:46.040 --> 00:07:49.100
我们得到一个准备好接收函数和对象的对象。
我们得到一个准备好接收函数和对象的对象。
We get an object ready to receive
a function and an object.

138
00:07:49.100 --> 00:07:51.769
一旦我们做到了，我们就要处理里面的第一个部分。
一旦我们做到了，我们就要处理里面的第一个部分。
As soon as we do it we're gonna
deal with the first bit inside it.

139
00:07:51.769 --> 00:07:59.319
所以一旦我们声明它，我们就会得到一个函数对象组合。
所以一旦我们声明它，我们就会得到一个函数对象组合。
So as soon as we declare it,
we get a functional object combo.

140
00:07:59.319 --> 00:08:08.670
如果没有，我们有一个函数对象组合。
如果没有，我们有一个函数对象组合。
If not,
we've got a functional object combo.

141
00:08:08.670 --> 00:08:13.709
函数对象组合的第一位，我们给出了字幕构造函数,
函数对象组合的第一位，我们给出了字幕构造函数,
And the first bit of the function object
combo, we give the subtitle constructor,

142
00:08:13.709 --> 00:08:20.189
这是函数位，也就是函数对象组合。
这是函数位，也就是函数对象组合。
and that's the function bit, or
the function object combo there it is.

143
00:08:20.189 --> 00:08:20.800
我们不知道。
我们不知道。
We don't know.

144
00:08:20.800 --> 00:08:24.792
我们给它一个副标题，构造函数。
我们给它一个副标题，构造函数。
We give it a subtitle, constructor.

145
00:08:28.276 --> 00:08:31.266
Will Sentance: 当然，它是在函数对象组合中出现的
Will Sentance: 当然，它是在函数对象组合中出现的
&gt;&gt; Will Sentance: And of course it gets
on it in the function object combo in

146
00:08:31.266 --> 00:08:35.399
对象位，一个原型属性，它是一个充满函数的对象,
对象位，一个原型属性，它是一个充满函数的对象,
the object bit, a prototype property,
which is an object full of function,

147
00:08:35.399 --> 00:08:38.389
还没有，我们应该立即储存什么
还没有，我们应该立即储存什么
well not yet,
what do we immediately store though, and

148
00:08:38.389 --> 00:08:42.879
我们不再手动分配他们看，我们只是列出了他们。
我们不再手动分配他们看，我们只是列出了他们。
no longer do we manually have to assign
them look we just list them out.

149
00:08:42.879 --> 00:08:45.429
中间甚至没有逗号，我们只是把它们列出来。
中间甚至没有逗号，我们只是把它们列出来。
Not even commas in between,
we just list them out.

150
00:08:45.429 --> 00:08:48.340
我们想列多少就列多少，他们都会一个接一个地被带走
我们想列多少就列多少，他们都会一个接一个地被带走
We can list as many out as we want and
they're all gonna be taken one by one and

151
00:08:48.340 --> 00:08:50.230
在幕后，JavaScript 在运行什么？
在幕后，JavaScript 在运行什么？
behind the scenes what's
JavaScript running?

152
00:08:50.230 --> 00:08:54.376
它会显示用户创建者.prototype.increment 和
它会显示用户创建者.prototype.increment 和
It saying user
creator.prototype.increment, and

153
00:08:54.376 --> 00:08:57.381
它把它们刺进了那个物体。
它把它们刺进了那个物体。
it's sticking them into that object.

154
00:08:57.381 --> 00:09:00.754
伙计们，这里什么都没有改变。
伙计们，这里什么都没有改变。
People, nothing has changed
under the hood here.

155
00:09:00.754 --> 00:09:06.971
在通过声明一个函数来声明一个类之前，我们已经声明了它。
在通过声明一个函数来声明一个类之前，我们已经声明了它。
We have as soon as we declare a class
before we did it by declaring a function.

156
00:09:06.971 --> 00:09:11.047
它隐式创建了一个附加到它的对象，一个函数对象组合
它隐式创建了一个附加到它的对象，一个函数对象组合
Which implicitly created an object
attached to it a function object combo

157
00:09:11.047 --> 00:09:14.879
其中有一个原型属性，这是一个对象本身。
其中有一个原型属性，这是一个对象本身。
into which had a prototype property
which was an object itself.

158
00:09:14.879 --> 00:09:17.320
存储我们共享的函数。
存储我们共享的函数。
Into which we stored our shared functions.

159
00:09:17.320 --> 00:09:24.090
现在，我们创建一个子句，它是一个函数对象组合。
现在，我们创建一个子句，它是一个函数对象组合。
Now, we create a clause which
is a function object combo.

160
00:09:25.490 --> 00:09:28.649
第一部分，我们给出一个字幕构造函数
第一部分，我们给出一个字幕构造函数
And the first bit of it,
we give a subtitle constructor and

161
00:09:28.649 --> 00:09:30.620
你可以看到它们是一样的。
你可以看到它们是一样的。
you can see it's identical.

162
00:09:30.620 --> 00:09:34.299
我们传递给另一个构造函数的第一件事情是在您的路径中，对不起。
在您的路径中，我们首先传递给另一个构造函数的第一件事，对不起。
That first thing we pass into this other
constructor first in your path, sorry.

163
00:09:34.299 --> 00:09:35.919
我们首先要存放在里面。
我们首先要储存在里面。
First thing we store in it.

164
00:09:35.919 --> 00:09:41.509
给自己一个构造函数是函数对象组合的函数位。
给自己一个构造函数是函数对象组合的函数位。
And give ourselves a constructor is the
function bit of the function object combo.

165
00:09:41.509 --> 00:09:43.639
下面列出的所有函数,
下面列出的所有函数,
And then all the functions
we list out below,

166
00:09:43.639 --> 00:09:45.850
我们只是按名字把他们列出来。
我们只是按名字把他们列出来。
we're just gonna literally
list them out by name.

167
00:09:45.850 --> 00:09:48.019
在幕后，乔治，我们采取的第一个和
在幕后，乔治，我们采取的第一个和
Behind the scenes George,
we're taking the first one and

168
00:09:48.019 --> 00:09:53.039
我们上去，然后我们去函数对象组合，那就是类。
我们上去，然后我们去函数对象组合，那就是类。
we're going up, off we go to our
function object combo that is the class.

169
00:09:53.039 --> 00:09:57.110
看看它的对象位，看看它的原型属性和
看看它的对象位，看看它的原型属性和
And look on the object bit of it and
look on its prototype property and

170
00:09:57.110 --> 00:10:00.909
看看这个对象和故事方法，叫做 increment。
看看这个对象和故事方法，叫做 increment。
look at that object and
story method, called increment.

171
00:10:00.909 --> 00:10:04.529
然后下一张幻灯片是登录。
然后下一张幻灯片是登录。
And then the next slide it goes login.

172
00:10:04.529 --> 00:10:07.379
然后我们去一个用户创建类,
我们去一个用户创建类,
Off we go to a user creator class,

173
00:10:07.379 --> 00:10:12.350
它实际上只是一个函数对象组合，看看原型属性。
它实际上只是一个函数对象组合，看看原型属性。
which is really just a function object
combo and look on the prototype property.

174
00:10:12.350 --> 00:10:15.860
我们在它上面插入一个登录属性并分配一个函数。
我们在它上面插入一个登录属性并分配一个函数。
We insert a login property on it and
assign a function.

175
00:10:15.860 --> 00:10:17.240
之后就是一样的了。
之后就一样了。
And after that it's the same.

176
00:10:17.240 --> 00:10:20.509
当我们运行 user create 时，我在这里做了大写，没有改变。
当我们运行用户创建，我已经做了大写在这里没有改变。
When we run user creates I've done
the upper case here no change.

177
00:10:20.509 --> 00:10:24.350
当我们用关键字运行 user creator 时，知道我们运行函数的哪个位
当我们用关键字运行 user creator 时，知道我们运行函数的哪个位
When we run user creator with the key word
knew which bit do we run of the function

178
00:10:24.350 --> 00:10:25.715
对象组合，丹？
对象组合，丹？
object combo, Dan?

179
00:10:25.715 --> 00:10:30.767
当我们运行前面带有关键字 new 的9的 user creator 时,
当我们运行前面带有关键字 new 的9的 user creator 时,
When we run user creator with either a
nine with the keyword new in front of it,

180
00:10:30.767 --> 00:10:33.974
我们运行函数对象组合的哪一部分。
我们运行函数对象组合的哪一部分。
which bit of the function
object combo do we run.

181
00:10:33.974 --> 00:10:34.788
丹: 构造函数。
阿丹: 构造函数。
&gt;&gt; Dan: The constructor.

182
00:10:34.788 --> 00:10:37.294
这个函数，是的，我们现在叫它构造函数，但是
这个函数，是的，我们现在叫它构造函数，但是
&gt;&gt; Will Sentance: The function,
yeah we call it constructor now but

183
00:10:37.294 --> 00:10:39.860
其实功能是一样的。
其实功能是一样的。
it's really just the same function, yeah.

184
00:10:39.860 --> 00:10:42.100
当 out 从中返回一个物体,
当 out 从中返回一个物体,
And when out returns from it an object,

185
00:10:42.100 --> 00:10:45.019
它会链接到函数对象组合的哪一部分，丹？
它会链接到函数对象组合的哪一部分，丹？
it's gonna link to which bit of
the function object combo Dan?

186
00:10:45.019 --> 00:10:47.000
丹: 原型。
丹: 原型。
&gt;&gt; Dan: The prototype.

187
00:10:47.000 --> 00:10:52.549
确切地说，原型对象，什么都没有改变。
确切地说，原型对象，什么都没有改变。
&gt;&gt; Will Sentance: Prototype object
exactly, nothing has changed.

188
00:10:52.549 --> 00:10:57.500
但是它看起来确实更像其他语言。
但是它看起来确实更像其他语言。
But it does look a lot
more like other languages.

189
00:10:57.500 --> 00:11:00.720
但对我来说我不知道,
但对我来说我不知道,
But that to me, I don't even know,

190
00:11:00.720 --> 00:11:03.899
因为它和其他语言一样吗？
因为它和其他语言一样吗？
because is it doing what other
languages are doing under the hood?

191
00:11:03.899 --> 00:11:05.210
不，绝对不是。
不，绝对不是。
No, it's definitely not.

192
00:11:05.210 --> 00:11:11.539
这几乎是更多，我不知道，它再次使更清晰。
这几乎是更多，我不知道，它再次使更清晰。
And that's almost more, I don't know,
it makes again more legible.

193
00:11:11.539 --> 00:11:14.549
这使得它显然更具可读性。
这使得它显然更具可读性。
It makes it more apparently readable.

194
00:11:14.549 --> 00:11:17.519
但在幕后，什么都没有改变。
但在幕后，什么都没有改变。
But behind the scenes, nothing's changed.

195
00:11:17.519 --> 00:11:22.041
意思是如果我们想真正理解和调试
意思是如果我们想真正理解和调试
Meaning if we wanna really understand and
debug and

196
00:11:22.041 --> 00:11:26.456
使用这些技术，会更有针对性
使用这些技术，会更有针对性
use these techniques,
it's even more pertinent

197
00:11:26.456 --> 00:11:31.408
我们现在知道引擎盖下面发生了什么。
我们现在知道引擎盖下面发生了什么。
that we now understand what's
going on under the hood.

198
00:11:31.408 --> 00:11:35.413
因为现在它看起来更像其他语言了。
因为现在它看起来更像其他语言了。
Going on under the hood because even
more now it looks like other languages.

199
00:11:35.413 --> 00:11:39.323
意义将带来我们对其他语言如何实现的所有观点
意义将带来我们对其他语言如何实现的所有观点
Meaning will bring all our views of
how those other languages implement

200
00:11:39.323 --> 00:11:43.299
这些功能，但不是做在现实生活的幕后。
这些功能，但不是做在现实生活的幕后。
these features, but ain't doing
in real life behind the scenes.

201
00:11:43.299 --> 00:11:47.639
顺便说一下，这是完全相同的模型，正如我们所看到的，回到解2。
顺便说一下，这是完全相同的模型，正如我们所看到的，回到解2。
It's exactly the same model by the way,
as we saw all the way back and solution 2.

202
00:11:48.850 --> 00:11:51.940
它刚刚被自动化包装，新的关键井,
它刚刚被自动化包装，新的关键井,
It's just been wrapped by
the automation the new key well,

203
00:11:51.940 --> 00:11:54.187
很多代码都被新的关键词自动化了。
很多代码都被新的关键词自动化了。
it's a lot of the codes been
automated by the new key word.

204
00:11:54.187 --> 00:11:59.010
现在完成了我们函数起始点的设置
现在完成了我们函数起始点的设置
And now wrapped the setting up of
our starting point of our function

205
00:11:59.010 --> 00:12:01.692
当 run 返回对象时。
当 run 返回对象时。
which when run returns out objects.

206
00:12:01.692 --> 00:12:06.280
并且有行为丢失的物体现在有权使用那里的股份或功能,
并且有行为丢失的物体有权使用那里的股份或者功能,
And has act lose objects have access
to the shares or functions there now,

207
00:12:06.280 --> 00:12:11.166
我们现在通过一次性设置的过程，在类构造中,
我们现在通过一次性设置的过程，在类构造中,
we now through the process of setting this
up in one go In the class constructs,

208
00:12:11.166 --> 00:12:12.909
在教室里。
在教室里。
in the class setup.

209
00:12:12.909 --> 00:12:17.070
但是这并没有改变什么，它只是让我们写更少的代码。
但是它并没有改变任何事情，它只是让我们写更少的代码。
But it ain't changing anything under the
hood, it just makes us write less code.

210
00:12:17.070 --> 00:12:20.179
这就是所谓的语法糖让它看起来更漂亮,
这就是所谓的语法糖让它看起来更漂亮,
It's what's called a syntactic sugar,
makes it look prettier,

211
00:12:20.179 --> 00:12:23.830
我猜这就像蛋糕上的糖霜，我不知道。
我猜这就像蛋糕上的糖霜，我不知道。
I'm assuming it's like icing
sugar on a cake, I have no idea.

212
00:12:23.830 --> 00:12:26.259
从语法上来说，你就像，让它看起来更漂亮，但是
从语法上来说，你就像，让它看起来更漂亮，但是
Syntactically you're like,
makes it look prettier, but

213
00:12:26.259 --> 00:12:29.070
这改变不了什么。
这改变不了什么。
it ain't changing anything under the hood.

214
00:12:29.070 --> 00:12:33.409
好了，各位，利益无疑将成为一个新的标准
好了，各位，利益无疑将成为一个新的标准
All right folk, benefits emerging
as a new standard no doubt

215
00:12:33.409 --> 00:12:36.190
感觉更像是其他语言 Python 和 Java 的开始。
感觉更像是其他语言 Python 和 Java 的开始。
feels more like the start of
other languages Python and Java.

216
00:12:36.190 --> 00:12:39.970
它看起来很像其他语言、语言、问题的风格。
它看起来很像其他语言、语言、问题的风格。
It looks a lot like the style of
other languages, languages, problems.

217
00:12:39.970 --> 00:12:47.210
我说95是解决方案3,99% 的开发人员不知道它是如何工作的。
我说95是解决方案3,99% 的开发人员不知道它是如何工作的。
I say 95 for solution 3, 99% of
developers have no idea how it works.

218
00:12:47.210 --> 00:12:48.500
再问一次，为什么是失败面试？
再问一次，为什么是失败面试？
Again, why it's fail interviews?

219
00:12:48.500 --> 00:12:51.539
我不知道这是一个非常但是
我不知道这是一个非常但是
I don't know this is a very but

220
00:12:51.539 --> 00:12:55.519
不能解决他们想要解决的问题。
不能解决他们想要解决的问题。
can't solve the problems that they want
to solve the way they want to solve them.

221
00:12:55.519 --> 00:12:58.490
但你不会成为那些人中的一员。
但你不会成为那些人中的一员。
But you will not be one of those people.
