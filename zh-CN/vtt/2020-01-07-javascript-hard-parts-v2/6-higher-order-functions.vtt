WEBVTT

1
00:00:00.380 --> 00:00:02.229
威尔 · 森特斯: 托德，把它拿开，托德。
&gt;&gt; Will Sentance: Todd,
take it away, Todd.

2
00:00:02.229 --> 00:00:04.209
一号线，我们在干什么，我的朋友？
Line one, what are we doing,
my friend, here?

3
00:00:04.209 --> 00:00:07.750
说话人2: 我们正在定义函数，复制，数组和除以二。
&gt;&gt; Speaker 2: We're defining the function,
copy, array and divide by two.

4
00:00:07.750 --> 00:00:09.460
威尔 · 森特斯: 完美，顺便说一句，我做了最糟糕的事情。
&gt;&gt; Will Sentance: Perfect, by the way,
I did the worst thing there.

5
00:00:09.460 --> 00:00:11.686
你说话的时候我做对了，托德。
I did this right as you're talking, Todd.

6
00:00:11.686 --> 00:00:14.189
我知道马克会为此感到多么沮丧。
I know how upset Mark will be by that.

7
00:00:14.189 --> 00:00:16.309
定义函数，复制数组。
Define the function, copy array.

8
00:00:16.309 --> 00:00:19.789
同志们，我们要再来一遍，因为我想让你们再次感受到
People, we're going to through it all over
again, because again, I want you to feel

9
00:00:19.789 --> 00:00:27.190
从头再来一遍是多么令人沮丧。
in your guts how frustrating it
is to do this all over again.

10
00:00:27.190 --> 00:00:29.609
这又是你从头开始写的代码。
This is code you're writing from scratch,
again.

11
00:00:29.609 --> 00:00:31.480
你感受到了我的痛苦。
And you're feeling my pain of it.

12
00:00:31.480 --> 00:00:33.079
这里没有拷贝和粘贴。
Ain't no copy and pasting here.

13
00:00:33.079 --> 00:00:35.119
事实上，这是一个干净的白板过程。
In fact, it's a clean whiteboard process.

14
00:00:35.119 --> 00:00:39.549
这就是重写代码的难度。
That's how hard it is to rewrite code.

15
00:00:39.549 --> 00:00:42.299
当然，肯定有更好的办法，对吧？
Surely, there must be a better way, right?

16
00:00:42.299 --> 00:00:44.929
当然，现在不行。
Surely, right now, no.

17
00:00:44.929 --> 00:00:46.679
现在，不，它们在做不同的事情。
Right now, no,
these are doing different things.

18
00:00:46.679 --> 00:00:48.119
函数代码是不同的。
The functions codes are different.

19
00:00:48.119 --> 00:00:49.960
所以我们需要重新来过。
And so we need to do it all over again.

20
00:00:49.960 --> 00:00:52.810
我的意思是只有一个字符不同，但它是不同的。
I means only one character different,
but it's different.

21
00:00:52.810 --> 00:00:54.560
好了，托德，下一句。
All right, Todd, next line.

22
00:00:54.560 --> 00:00:56.823
演讲者2: 它将定义常量 myarray。
&gt;&gt; Speaker 2: It'll define
the constant myarray.

23
00:00:56.823 --> 00:00:57.719
签上这个值。
Sign the value.

24
00:00:57.719 --> 00:00:59.420
所以在1,2和3的数组中。
So in the array of 1, 2 and 3.

25
00:00:59.420 --> 00:01:00.590
威尔 · 森塔斯: 太美了。 谢谢你，托德。
&gt;&gt; Will Sentance: Beautiful.
Thank you, Todd.

26
00:01:00.590 --> 00:01:02.030
下一句，托德。
Next line, Todd.

27
00:01:02.030 --> 00:01:04.280
演讲者2: 定义不变的结果
&gt;&gt; Speaker 2: Define
the constant result and

28
00:01:04.280 --> 00:01:10.109
调用函数 copyArrayAndDivideBy2，传入1、2和3的参数。
call the function copyArrayAndDivideBy2,
passing in the argument of 1, 2, and 3.

29
00:01:10.109 --> 00:01:14.719
威尔 · 森坦斯: 非常好，完全正确，调用函数 copyArray。
&gt;&gt; Will Sentance: Very nice, exactly,
call the function copyArray.

30
00:01:14.719 --> 00:01:21.109
如果他不再回答同样的问题，除以2就是真的很糟糕,
Divide by 2 to be really bad if he
doesn't exactly same question again,

31
00:01:21.109 --> 00:01:24.539
向右除以我的数组中的2部分123。
go right divided by 2 parts
in my array one two three.

32
00:01:24.539 --> 00:01:25.489
顺便说一句，很不错,
Very nice by the way,

33
00:01:25.489 --> 00:01:27.960
我们注意到那完整的技术交流有多好了吗？
do we notice how nice that complete
technical communication was?

34
00:01:27.960 --> 00:01:30.010
我很清楚发生了什么。
I knew exactly what was happening.

35
00:01:30.010 --> 00:01:31.299
谢谢你，托德。
Thank you, Todd.

36
00:01:31.299 --> 00:01:34.009
好的，我们进入执行环境。
Okay, we go into the execution context.

37
00:01:34.009 --> 00:01:35.500
没错没错。
Exactly, right.

38
00:01:35.500 --> 00:01:41.150
我们把它放在那里，你把它放在调用堆栈上。
Let's put it on there you go
put it on the call stack.

39
00:01:41.150 --> 00:01:45.569
各位，这是为了我们的长期观众。
People, this is for this is for
our long term audience.

40
00:01:45.569 --> 00:01:46.979
他们喜欢我们完成的时候。
They love it when we complete.

41
00:01:46.979 --> 00:01:51.469
2，it’ s
CompleteArrayAndDivideBy2, it's

42
00:01:51.469 --> 00:01:56.520
全球动力总是在那别担心，丹。
being executed Global's always
there Don't worry, Dan.

43
00:01:56.520 --> 00:01:58.329
还在那里，还在那里。
Also is there, there it is.

44
00:01:58.329 --> 00:02:01.969
很好，让我们进入执行环境。
Excellent.
Let's go into the execution context.

45
00:02:01.969 --> 00:02:09.150
而在当地的记忆里是什么第一凯拉？
And in local memory is what first Kayla?

46
00:02:09.150 --> 00:02:13.719
说话人3: 我们用传入的值123来定义参数数组。
&gt;&gt; Speaker 3: We define the parameter
array with the value passed in of 123.

47
00:02:13.719 --> 00:02:14.939
威尔 · 森特斯: 是的，非常好。
&gt;&gt; Will Sentance: Yeah, very nice.

48
00:02:14.939 --> 00:02:15.967
哪一个是我们的？
Which is known as our?

49
00:02:15.967 --> 00:02:19.615
说话人3: 一个参数。
&gt;&gt; Speaker 3: A parameter.

50
00:02:19.615 --> 00:02:23.539
那么一个参数是分配给我们的，每个人在一起？
&gt;&gt; Will Sentance: So a parameter is
assigned our, everyone together?

51
00:02:23.539 --> 00:02:24.280
讲者2: 论点 威尔 · 句子: 非常
&gt;&gt; Speaker 2: Argument.
&gt;&gt; Will Sentance: Argument very

52
00:02:24.280 --> 00:02:25.370
很好，非常好。
nice, excellent.

53
00:02:25.370 --> 00:02:27.780
Kayla 非常感谢下一句 Kayla,
And Kayla thanks very much
on to the next line, Kayla,

54
00:02:27.780 --> 00:02:30.490
我们在当地记忆里做的第一件事是什么？
what's the fist thing we
do in that local memory?

55
00:02:30.490 --> 00:02:33.270
说话人3: 我们定义一个常量输出为空数组。
&gt;&gt; Speaker 3: We define
a constant output to empty array.

56
00:02:33.270 --> 00:02:33.770
威尔 · 森塔斯: 太美了。
&gt;&gt; Will Sentance: Beautiful.

57
00:02:35.110 --> 00:02:40.389
很好，让我们继续我们的迭代，通过我们的做循环
Excellent let's get moving on our
iteration our looping through our doing

58
00:02:40.389 --> 00:02:43.758
一行代码作为 for 循环的主体。
a line of code the body of the for
loop multiple times.

59
00:02:43.758 --> 00:02:45.795
好吗？
Okay?

60
00:02:45.795 --> 00:02:51.069
还好，我们打到了身体的跟随。
There is all right,
we hit the body of follow.

61
00:02:52.389 --> 00:02:55.050
眼睛的价值是什么，最初的泰勒？
Eyes value is what initially Taylor?

62
00:02:55.050 --> 00:02:56.819
讲者3: Zero 威尔 · 森坦斯: 零，我们取数组
&gt;&gt; Speaker 3: Zero.
&gt;&gt; Will Sentance: Zero we take array

63
00:02:56.819 --> 00:02:59.979
定位 asub 或数组索引为零，然后得到值？
position or asub or
array index zero and get the value?

64
00:03:01.080 --> 00:03:01.780
讲者3: 一 威尔 · 森塔斯: 一个。
&gt;&gt; Speaker 3: One.
&gt;&gt; Will Sentance: One.

65
00:03:01.780 --> 00:03:03.811
我们把它除以2就得到了 Kayla？
We divide it by two, we get, Kayla?

66
00:03:03.811 --> 00:03:05.096
演讲者3:0.5。
[LAUGH]
&gt;&gt; Speaker 3: 0.5.

67
00:03:05.096 --> 00:03:08.780
威尔 · 森塔斯: 0.5，或者用我们国家的话来说，每个人,
&gt;&gt; Will Sentance: 0.5, or
as we say in my country, everybody,

68
00:03:08.780 --> 00:03:13.960
也许你以前看过这些，我们说，也不是0.5，这是真的。
maybe you've watched this all before, we
say nor point five, which is a real thing.

69
00:03:13.960 --> 00:03:17.300
尽管这听起来像是动态的东西。
Even though it sounds like
something from dynamic.

70
00:03:17.300 --> 00:03:21.579
然后点击数组子，或数组索引，或数组位置1,
Then we hit array sub, or
array index, or array position one,

71
00:03:21.579 --> 00:03:26.719
也就是我们除以2得到1的数字2。
which is the number two we
divide by two we get one.

72
00:03:26.719 --> 00:03:28.599
好，我们去那里，它是1.5以及。
Okay, we go it there it is 1.5 as well.

73
00:03:28.599 --> 00:03:30.300
很好，就是这个。
Good, there it is.

74
00:03:30.300 --> 00:03:33.639
功能的最后一行，杰夫，说做什么？
Final line of the function,
Jeff, says to do what?

75
00:03:35.500 --> 00:03:37.159
音箱2: 返回的输出。
&gt;&gt; Speaker 2: Returned output.

76
00:03:37.159 --> 00:03:40.400
威尔 · 森特斯: 是的，我希望它能更精确一点，杰夫。
&gt;&gt; Will Sentance: Yeah, I'd like it
to be more precise in that Jeff.

77
00:03:40.400 --> 00:03:44.900
对我来说，输出是否表示标签或
Is it output which to me output represents
this whole combination of label or

78
00:03:44.900 --> 00:03:48.159
但这并不是全部，不是吗？
identifier and value but
it's not the whole is it?

79
00:03:48.159 --> 00:03:51.650
它只是-Speaker 2: 返回分配的值。
It's just the-
&gt;&gt; Speaker 2: Return the value assigned.

80
00:03:51.650 --> 00:03:52.920
威尔 · 森特斯: 是的，没错。
&gt;&gt; Will Sentance: Yeah, exactly.

81
00:03:52.920 --> 00:03:53.599
非常好。
Very nice.

82
00:03:53.599 --> 00:03:54.280
哪个。
Which.

83
00:03:54.280 --> 00:03:56.944
这是数组0.51,1.5。
Which is the array 0.51, 1.5.

84
00:03:56.944 --> 00:03:58.699
杰夫说得太好了。
Excellent from Jeff.

85
00:03:58.699 --> 00:04:00.740
谢谢。这些数据存储在 global
Thank you.
And that's stored in global

86
00:04:00.740 --> 00:04:01.830
在什么下面，杰夫。
under what constant Jeff.

87
00:04:03.740 --> 00:04:04.460
讲者2: 结果如何？
&gt;&gt; Speaker 2: Result?

88
00:04:04.460 --> 00:04:05.319
威尔 · 森塔斯: 结果，太好了。
&gt;&gt; Will Sentance: Result.
Excellent.

89
00:04:06.479 --> 00:04:07.189
好了。
There we go.

90
00:04:09.150 --> 00:04:10.110
我们喜欢这个功能。
We love this function.

91
00:04:11.849 --> 00:04:13.099
演讲者2: 从云霄飞车上跳下来。
&gt;&gt; Speaker 2: Pop off the coaster.

92
00:04:13.099 --> 00:04:17.149
威尔 · 森特斯: 再说一次，彼得，你必须把它从调用堆栈中取出来,
&gt;&gt; Will Sentance: Again Peter,
you've got to pop it off the call stack,

93
00:04:17.149 --> 00:04:18.689
他说对了。
he's spot on.

94
00:04:18.689 --> 00:04:20.449
我们喜欢这个功能吗? 不，它的功能很好。
Do we like this function,
nah, his function is fine.

95
00:04:20.449 --> 00:04:22.990
我们是否喜欢再次从头开始编写这个函数？
Do we like that we wrote this
function again from scratch?

96
00:04:22.990 --> 00:04:26.677
每个人，谁知道[听不见]看这个，好吗。
Everybody, who knows
[INAUDIBLE] look at that, okay.

97
00:04:26.677 --> 00:04:28.290
我们喜欢这个功能吗？
Do we like this function?

98
00:04:28.290 --> 00:04:30.670
是的，他通常的功能，我们用这个任务很多,
Yes, his usual function we
use this with the task a lot,

99
00:04:30.670 --> 00:04:34.639
但我真的需要从头开始重建吗？
but Did I really have to
rebuild it from scratch?

100
00:04:34.639 --> 00:04:36.100
我想是的。
I guess I did though.

101
00:04:36.100 --> 00:04:38.980
因为任何改变-我不能编辑功能，对不对？
Because any change- I can't
edit functions, right?

102
00:04:38.980 --> 00:04:40.319
我救过他们一次也没有。
Not once I've saved them.

103
00:04:40.319 --> 00:04:45.310
除非，在我们看到之前，让我们先看看另一个函数。
Unless- well, before we see,
let's for now see another function.

104
00:04:45.310 --> 00:04:49.379
假设这次你想获取一个数组，创建一个全新的数组,
Suppose you wanted to take an array
this time, create a brand new array,

105
00:04:49.379 --> 00:04:52.749
每个元素加上三个元素。
fill it with each element
with three added to it.

106
00:04:54.209 --> 00:04:54.930
没错。
Yeah, exactly.

107
00:04:54.930 --> 00:04:58.949
有趣的是，人们确实会轻微地呻吟，这是非常粗鲁的，托德。
It's funny people literally do groan
slightly, which is very rude, Todd.

108
00:04:58.949 --> 00:05:02.300
那么，托德,
[LAUGH]
So, Todd,

109
00:05:02.300 --> 00:05:05.709
你觉得我们违反了什么原则？
which principle are we
breaking here do you think?

110
00:05:05.709 --> 00:05:06.759
演讲者2: 不干。
&gt;&gt; Speaker 2: Not dry.

111
00:05:06.759 --> 00:05:08.439
威尔 · 森特斯: 它不是干的，我们有。
&gt;&gt; Will Sentance: It's not dry, we've got.

112
00:05:08.439 --> 00:05:11.480
原则是不要重复你自己，我们正在重写。
The principle is don't repeat yourself,
we're rewriting.

113
00:05:11.480 --> 00:05:15.300
每次我们这样做的时候，我们都会获得一个数组，创建一个新的输出数组
Every time we do this, we're taking
an array, creating a new output array

114
00:05:15.300 --> 00:05:19.149
循环遍历输入数组，执行一些操作
iterating through the looping through
the input array, doing something

115
00:05:20.220 --> 00:05:24.290
每个元素，返回完整的、完全填充的输出数组。
to each element, returning out of
the full, fully populated output array.

116
00:05:26.240 --> 00:05:29.110
我们看到10的平方，9的平方，8的平方。
We saw that 10 squared,
nine squared, eight squared.

117
00:05:29.110 --> 00:05:31.910
我们最终做得很好。
We in the end made it well.

118
00:05:31.910 --> 00:05:34.709
我们做了一些事情来确保我们不必每次都重写
We did some things to make sure we
didn't have to rewrite each time

119
00:05:34.709 --> 00:05:36.750
我们每次都能根据新数据进行调整。
we were able to adjust for
new data each time.

120
00:05:36.750 --> 00:05:40.540
有人能告诉我我们在这里能做什么吗？
Can anybody tell me what could we do here?

121
00:05:40.540 --> 00:05:44.300
不是像演讲中的一个华丽的标题词，而是
Not in terms of like a fancy
title word from the talk, but

122
00:05:44.300 --> 00:05:46.540
没有更直观的感觉了。
there's no more intuitive sense.

123
00:05:46.540 --> 00:05:50.379
也许，我们能做些什么来拯救我们自己，亚当？
What could we do to save ourselves Adam,
perhaps?

124
00:05:50.379 --> 00:05:53.899
为了避免我们一个接一个地写出这些函数
To save ourselves from writing out
these functions one after another and

125
00:05:53.899 --> 00:05:56.509
我们凭直觉能做些什么？
what can we do in a sort
of intuitive sense here?

126
00:05:56.509 --> 00:05:59.079
演讲者2: 我们准备一个高阶函数。
&gt;&gt; Speaker 2: We teeing up for
a higher order function.

127
00:05:59.079 --> 00:06:02.870
威尔 · 森塔斯: 好吧，我说了不要提到演讲的标题，丹,
&gt;&gt; Will Sentance: Okay, I said don't
mention the title of the talk [LAUGH] Dan,

128
00:06:02.870 --> 00:06:04.089
说话人2: 传递功能为
&gt;&gt; Speaker 2: Pass functionality as

129
00:06:04.089 --> 00:06:05.279
一个参数。
a parameter.

130
00:06:05.279 --> 00:06:06.899
威尔 · 森塔斯: 丹说得很好。
&gt;&gt; Will Sentance: Beautifully put by Dan.

131
00:06:06.899 --> 00:06:07.939
是的，完全正确。
Yes, spot on.

132
00:06:07.939 --> 00:06:12.480
我们可以留下一些功能。
We could leave some of our functionality.

133
00:06:12.480 --> 00:06:18.819
我们可以写这些函数，把它留在空白处。
We could write these function ones,
leave it in a blank where the changes is.

134
00:06:18.819 --> 00:06:22.050
我们不调用 copy123除以2,
We don't call this function copy123 and
divide it by 2,

135
00:06:22.050 --> 00:06:23.310
copy123然后乘以2。
copy123 and multiply it by 2.

136
00:06:23.310 --> 00:06:24.269
我们称之为 copyArray。
We call it copyArray.

137
00:06:24.269 --> 00:06:27.339
然后当我们运行这个函数的时候，我们填充这个参数,
And then when we run the function,
we fill in that parameter,

138
00:06:27.339 --> 00:06:31.019
使用特定的数据使该函数可重用。
With the specific data to
make that function reusable.

139
00:06:31.019 --> 00:06:34.009
民谣，功能性也是一样。
Folk, same thing with functionality.

140
00:06:34.009 --> 00:06:38.060
我们可以在特定的功能和
We can leave a little blank for
the specific functionality and

141
00:06:38.060 --> 00:06:42.620
只有在我们运行函数之后才能填写。
only fill it in once we run the function.

142
00:06:42.620 --> 00:06:44.516
但是我能这样做吗，各位？
But can I do it like this, people?

143
00:06:44.516 --> 00:06:46.949
我能不能离开，我不知道,
Can I just leave, I don't know,

144
00:06:46.949 --> 00:06:52.199
我可以插入 + 3吗，就像这样一个字符串。
can I just insert Plus three,
almost as a string like that.

145
00:06:52.199 --> 00:06:54.620
我是否可以插入这个，然后把它送进去？
Am I allowed to insert that and
have that passed in?

146
00:06:54.620 --> 00:06:59.740
我是否被允许传入一些小字符串的代码并在 JavaScript 中执行它们？
Am I allowed to pass in little strings
of code and execute them in JavaScript?

147
00:06:59.740 --> 00:07:00.250
不。
Nah.

148
00:07:00.250 --> 00:07:01.379
你可以想象一种语言。
You can imagine a language that would.

149
00:07:01.379 --> 00:07:02.810
这并不是说你不能。
It's not saying you can't.

150
00:07:02.810 --> 00:07:05.920
它不是固有的，但不是在 JavaScript 中。
It's not inherently,
but not in JavaScript.

151
00:07:05.920 --> 00:07:08.709
那么，我们应该如何总结功能呢？
So instead,
how do we wrap up functionality?

152
00:07:08.709 --> 00:07:13.800
将功能捆绑起来，这样它就可以执行了
Bundle up functionality,
such that it can execute Such as it can be

153
00:07:13.800 --> 00:07:19.540
然后在另一个函数中运行,
passed through into and be then
executed run inside another function,

154
00:07:19.540 --> 00:07:23.463
我们如何包装用 JavaScript 传递的功能代码？
how can we wrap up functionality code
to be passed around in JavaScript?

155
00:07:23.463 --> 00:07:26.199
布莱登，我们怎么收尾，怎么收尾？
Braden, how can we wrap it up,
wrap it up with?

156
00:07:26.199 --> 00:07:28.459
讲者2: 功能 威尔 · 森塔斯: 在一个功能中，他是点
&gt;&gt; Speaker 2: In function.
&gt;&gt; Will Sentance: In a function he's spot

157
00:07:28.459 --> 00:07:32.709
这正是我们要做的，我们可以泛化函数,
on and that's exactly what we're gonna do,
we could generalize our function,

158
00:07:32.709 --> 00:07:34.750
我们称之为版权，做点什么吧。
let's call it copyright and do something.

159
00:07:34.750 --> 00:07:37.529
复制数组和操作，看看这个。
Copy array and
manipulate and look at this.

160
00:07:37.529 --> 00:07:42.610
我留下了一些空白指令，就像数组一样。
I've left a little blank instructions and
just as array.

161
00:07:42.610 --> 00:07:46.050
只要你看到数组在版权范围内，除以2,
Wherever you saw array inside
of copyright and divide by two,

162
00:07:46.050 --> 00:07:47.180
实际上变成了123。
it literally became 123.

163
00:07:47.180 --> 00:07:52.970
我们会看到说明书会被填满
We're gonna see that instructions
is literally gonna be filled in

164
00:07:52.970 --> 00:07:55.000
乘以二。
with Multiply by two.

165
00:07:55.000 --> 00:07:56.170
看看这个。
Have a look at that.

166
00:07:56.170 --> 00:07:58.819
我们有乘以二的函数，现在我把它保持在一条线上
We've got multiply by two function,
now I've kept it on one line but

167
00:07:58.819 --> 00:08:00.339
这和正常的功能没什么不同。
it's no different to a normal function.

168
00:08:00.339 --> 00:08:02.970
如果跑步得到了数字3，那么它会变成3乘2吗？
If run takes the number three,
will it turn out three by two?

169
00:08:04.600 --> 00:08:08.329
我们乘以2，然后一行一行地走,
We pass in multiply by two, we're
gonna walk through this line by line,

170
00:08:08.329 --> 00:08:08.980
大家别担心。
don't worry people.

171
00:08:08.980 --> 00:08:12.180
但是它会逐渐取代指令这个词
But it's literally gonna replace
the word instructions there

172
00:08:12.180 --> 00:08:17.139
复制数组操作保存声明定义代码,
inside of copy array manipulate
Save declare define the code,

173
00:08:17.139 --> 00:08:21.579
当我们运行的时候它会替换它，代码会填充指令
it's going to replace it when we run that
code is going to fill in instructions

174
00:08:21.579 --> 00:08:26.362
乘以二。
with, multiply by two.

175
00:08:26.362 --> 00:08:29.379
然后看，乘以两个父母。
And then look, multiply by two parenths.

176
00:08:29.379 --> 00:08:34.750
然后一个重新定位的零可以是数字1，乘以二人1。
And then a reposition zeros can be the
number one, multiply by two persons one.

177
00:08:34.750 --> 00:08:39.350
也就是说，运行，乘以2，输入1和
That's to say run,
multiply by two With the input of 1 and

178
00:08:39.350 --> 00:08:42.600
返回1乘2返回2和
return out 1 by 2 return out 2 and

179
00:08:42.600 --> 00:08:48.220
我们的指令数组 i 将成为乘以2数组位置0。
our instructions array I which will
become multiply by 2 array position 0.

180
00:08:48.220 --> 00:08:53.490
也就是说数字1的倍数乘以2的括号
That is to say the number 1
multiple by 2 parentheses 1 will

181
00:08:53.490 --> 00:08:57.889
返回2和2将被推。
return out 2 and that 2 will be pushed.

182
00:08:57.889 --> 00:08:59.360
进入输出。
Into output.

183
00:08:59.360 --> 00:09:03.549
我们要做的和我们在这里做的一样，数组位置为零
We're gonna achieve exactly the same thing
we did here where array position zero with

184
00:09:03.549 --> 00:09:08.590
一号，乘以二，但是
a number one, multiply by two, but

185
00:09:08.590 --> 00:09:11.830
现在我们重新定位0是一个数字，并且
now we do a reposition
zero is a number one, and

186
00:09:11.830 --> 00:09:17.850
然后我们把它插入乘以二，然后在它们返回的内部做一个个乘以二。
then we stick it into multiply by two and
do one by two inside their return out.

187
00:09:17.850 --> 00:09:19.082
两个输入到输出。
The two inputs to output.
