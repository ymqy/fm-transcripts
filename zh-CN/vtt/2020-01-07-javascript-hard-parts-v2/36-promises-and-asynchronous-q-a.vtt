WEBVTT

1
00:00:00.260 --> 00:00:03.165
威尔 · 森特斯: 布雷登，请讲。
&gt;&gt; Will Sentance: Braydon,
go ahead Braydon.

2
00:00:03.165 --> 00:00:08.316
演讲者2: 所以如果我们试图使用存储网络数据的数据
&gt;&gt; Speaker 2: So if we're trying to use
the data storing data from the network

3
00:00:08.316 --> 00:00:14.938
如果你在 JavaScript 中有一行代码，在 global。
request, how does it if you have a line
of code in the JavaScript, in the global.

4
00:00:14.938 --> 00:00:16.528
它怎么知道什么时候可以访问这些信息？
How does it know when it
can kinda access that?

5
00:00:16.528 --> 00:00:19.062
威尔 · 森塔斯: 在现实的幕后,
&gt;&gt; Will Sentance: Behind
the scenes in reality,

6
00:00:19.062 --> 00:00:22.771
这么高的价值实际上从来没有填写。
this high value is never
filled in actually.

7
00:00:22.771 --> 00:00:26.631
直到所有的全球代码完成运行，所以我们甚至不能访问它在那里
Until all global codes finish running, so
we can't even get access to it at that

8
00:00:26.631 --> 00:00:29.579
在找到之前，我们只能从前门进入。
point until we have,
we only get access to it from the front.

9
00:00:29.579 --> 00:00:31.722
那样的话，我的意思是这和回调模式不同，对吗？
And then that way, I mean that different
from the callback model, right?

10
00:00:31.722 --> 00:00:33.765
你只能从我们添加的函数中访问,
You only get access to from
the function that we add,

11
00:00:33.765 --> 00:00:36.332
因为我们不想有一种语言。
we also triggered because we just
don't want to have a language.

12
00:00:36.332 --> 00:00:37.046
我们可以去的地方
Where we can go and

13
00:00:37.046 --> 00:00:40.060
试着接触一些东西，但我们不知道它是否在那里。
try and get access to stuff and we don't
know if it's gonna be there or not.

14
00:00:40.060 --> 00:00:44.043
所以我们不会在幕后自动填充,
So we don't actually fill that in
behind the scenes automatically,

15
00:00:44.043 --> 00:00:46.387
直到所有的全球代码运行完毕。
until all global codes finish running.

16
00:00:46.387 --> 00:00:48.993
好的，在实践中，这有一个小的结果。
Okay, in practice that
has a small consequence.

17
00:00:48.993 --> 00:00:52.012
但是这和我给你们展示的方式有点不同
But it's slightly different to the way I
sort of showed you here where we sort of

18
00:00:52.012 --> 00:00:53.722
暗示它在那一刻被填满。
imply it gets filled in
here at that moment.

19
00:00:53.722 --> 00:00:56.290
但实际上是在最后一刻,
But in reality it's at
the very last minute,

20
00:00:56.290 --> 00:00:58.734
在我们开始排队之前。
before we start going through the queues.

21
00:00:58.734 --> 00:01:01.814
这不会带来任何后果。
That has no consequences in terms of.

22
00:01:01.814 --> 00:01:04.430
我们不会运行这些函数直到它被填满,
We don't run these functions
until it's filled in,

23
00:01:04.430 --> 00:01:07.518
直到我们完成所有的全球代码，所以没有后果。
until we finish all the global
code anyway so no consequences.

24
00:01:07.518 --> 00:01:09.379
马克？
Mark?

25
00:01:09.379 --> 00:01:10.870
演讲者2: 我正在思考如何恰当地表达这句话。
&gt;&gt; Speaker 2: I'm trying to think
of how to phrase this properly.

26
00:01:10.870 --> 00:01:12.878
维尔 · 森坦斯: 你想休息一会儿吗？
&gt;&gt; Will Sentance: Do you
want to take one sec?

27
00:01:12.878 --> 00:01:13.451
演讲者2: 我可以试试。
&gt;&gt; Speaker 2: I can try.

28
00:01:13.451 --> 00:01:19.519
如果它是一个打印 hello 当浏览器有它，是一个引用全局打印 hello。
If it's a print hello when the browser has
it, is a reference to global print hello.

29
00:01:19.519 --> 00:01:21.774
不是打印你好本身。
Is not print hello itself.

30
00:01:21.774 --> 00:01:23.966
威尔 · 森坦斯: 是的，我们不会在网页浏览器中复制
&gt;&gt; Will Sentance: Yeah, we're not
taking into the web browser a copy of

31
00:01:23.966 --> 00:01:24.606
函数。
the function.

32
00:01:24.606 --> 00:01:28.114
我们只是给出一个内存中的引用，这个函数，是的。
We're just giving a reference back
to in memory, this function, yeah.

33
00:01:28.114 --> 00:01:32.145
演讲者2: 可以打印 hello，在你点击的时候要考虑到
&gt;&gt; Speaker 2: Could print hello, take
into consideration by the time you hit

34
00:01:32.145 --> 00:01:36.265
成本文本的东西从全局内存的另一个参数？
the cost text something another
parameter from global memory?

35
00:01:36.265 --> 00:01:38.558
或者一定是可以的。
Or is it must have been can.

36
00:01:38.558 --> 00:01:39.953
威尔 · 森塔斯: 这很难做到，因为。
&gt;&gt; Will Sentance: It will
be hard to do so, because.

37
00:01:39.953 --> 00:01:40.625
演讲者2: 是的 威尔 · 森特斯: 等等,
&gt;&gt; Speaker 2: Yeah.
&gt;&gt; Will Sentance: Hold on,

38
00:01:40.625 --> 00:01:42.323
谁要把父母的照片印出来？
who's putting the parenths on print?

39
00:01:42.323 --> 00:01:44.147
你好，我们在做吗，是的。
Hello, are we doing it, yeah.

40
00:01:44.147 --> 00:01:45.924
我们要把指纹印出来吗？
Are we putting prints on print?

41
00:01:45.924 --> 00:01:46.491
- 喂?-没有。
Hello?
&gt;&gt; Speaker 2: No.

42
00:01:46.491 --> 00:01:48.028
威尔 · 森坦斯: 没有 JavaScript 在做这件事。
&gt;&gt; Will Sentance: No JavaScript's
doing it.

43
00:01:48.028 --> 00:01:51.878
如果我们不把品牌放在我们如何插入任何争论？
If we're not putting brands on
how do we insert any arguments?

44
00:01:51.878 --> 00:01:54.786
我们必须依靠知道。
We have to rely on knowing.

45
00:01:54.786 --> 00:01:58.897
这是一个非常好的观点，在这里是最重要的。
And this is a really good point,
the most making here.

46
00:01:58.897 --> 00:02:00.489
这意味着我们必须知道，比如,
It means we have to know like,
for example,

47
00:02:00.489 --> 00:02:02.254
你可以换个方式回答，马克，等等。
you might answer a different way mark,
hold on.

48
00:02:02.254 --> 00:02:06.150
是否有两个参数传递给我，这两个参数都是关于显示
Could I have two arguments passed to me
that's all about display the function that

49
00:02:06.150 --> 00:02:07.233
得到它的第一个输入。
gets its first input.

50
00:02:07.233 --> 00:02:11.578
返回的数据好像我只能有两个参数。
Data that comes back as if I could only
be have that expect two arguments.

51
00:02:11.578 --> 00:02:13.217
现在我得走了
Now, I've got to go and

52
00:02:13.217 --> 00:02:18.060
看看 web 浏览器的功能到底是怎样的
look at exactly how the feature of
the web browser that this function is

53
00:02:18.060 --> 00:02:23.002
当功能网页浏览器完成工作时，将自动触发。
going to be auto triggered when
the feature web browser finishes work.

54
00:02:23.002 --> 00:02:25.283
它是如何期待网页浏览器和
How it's expecting how the web browser and

55
00:02:25.283 --> 00:02:28.652
疾病的希望，希望这一功能能够得到展示。
the promise of disease expecting
this function to be laid out.

56
00:02:28.652 --> 00:02:30.201
我该去哪里找规则呢？
Where do I go to find
the rules about that?

57
00:02:30.201 --> 00:02:34.913
我在哪里才能知道浏览器是如何期待这个功能的
Where am I gonna find out how
the browser is expecting the function

58
00:02:34.913 --> 00:02:36.549
那将是自动运行。
that will be auto run.

59
00:02:36.549 --> 00:02:40.701
什么时候它的工作完成是会工作，它会采取什么投入？
When its work is done is gonna work and
what inputs it's gonna take?

60
00:02:40.701 --> 00:02:41.974
我怎么才能知道呢？
How do I find that out, everybody?

61
00:02:41.974 --> 00:02:43.561
无论是一个网站。
Whether it's a website.

62
00:02:43.561 --> 00:02:44.395
讲者二: 多媒体网络 威尔 · 森塔斯: 关闭
&gt;&gt; Speaker 2: MDN.
&gt;&gt; Will Sentance: Shutting

63
00:02:44.395 --> 00:02:45.195
就是这个 MDN。
the MDN, exactly.

64
00:02:45.195 --> 00:02:48.187
Mdn 有一个所有这些特性的列表。
MDN has got a list of all these features.

65
00:02:48.187 --> 00:02:49.944
他们不称这些外观函数。
They don't call these facade functions.

66
00:02:49.944 --> 00:02:55.045
他们称之为 API 是一个它代表的接口是任何功能或
They call them API is a it stands for
interface that is any functionality or

67
00:02:55.045 --> 00:03:00.813
通常数据不在我的世界里，而是在别人的世界里，我与之交互。
often data that's not in my world, but
in someone else's and I interface with it.

68
00:03:00.813 --> 00:03:05.651
这些是我的标签，我可以通过它们进行交互
These are my labels by which
I can interface interact with

69
00:03:05.651 --> 00:03:07.473
这个外面的世界。
this outside world.

70
00:03:07.473 --> 00:03:11.983
这和你说的有点关系，马克,
That being said slightly related to
what you're saying, Mark, though,

71
00:03:11.983 --> 00:03:16.289
假设我在执行和其他函数中设置了超时调用。
is suppose I set timeout call inside
the execution and other function.

72
00:03:16.289 --> 00:03:20.710
它想使用一些来自执行上下文的数据。
And it wanted to use some of the data
from that execution context.

73
00:03:20.710 --> 00:03:24.878
等到印刷版 hello 运行的时候它已经在 global 上运行了,
Well, by the time print hello runs,
it runs in global,

74
00:03:24.878 --> 00:03:29.758
设置超时的执行上下文已经消失,
that execution context in which
set timeout with set up has gone,

75
00:03:29.758 --> 00:03:33.064
所有的数据都没了除非...-扬声器2: 背包。
and all its data's gone, unless the-
&gt;&gt; Speaker 2: Backpack.

76
00:03:33.064 --> 00:03:36.539
威尔 · 森特斯: Backpack，确切地说，print hello 有一个链接到它周围的所有地方
&gt;&gt; Will Sentance: Backpack, exactly, print
hello has a link to all its surrounding

77
00:03:36.539 --> 00:03:40.775
可以用在里面的记忆，太棒了，太神奇了。
memory that could ever be used in it,
pretty awesome, that's pretty amazing.

78
00:03:40.775 --> 00:03:43.472
好的，我们还有一个，是的，杰森，拜托？
Okay, we had another one,
yeah, Jason, please?

79
00:03:43.472 --> 00:03:48.127
演讲者2: (咳嗽)对不起，这个例子至少给我们留下了印象
&gt;&gt; Speaker 2: [COUGH] Excuse me, so the
example at least gives us the impression

80
00:03:48.127 --> 00:03:51.576
微任务队列要么是第一个,
that the micro-task queue
is either first in,

81
00:03:51.576 --> 00:03:55.923
最后，它优先使用的地方——威尔 · 森坦斯: 好问题。
last out, where it's used preferentially-
&gt;&gt; Will Sentance: Good question.

82
00:03:55.923 --> 00:03:59.617
扬声器2: 根据你将要接到的电话类型，你会接到哪里
&gt;&gt; Speaker 2: Where you've got depending
on the type of call you're gonna get

83
00:03:59.617 --> 00:04:00.169
排队。
a queue.

84
00:04:00.169 --> 00:04:04.854
我怀疑微任务其实是有自己的发明循环的
My suspicion is the micro-task is
actually has its own invent loop

85
00:04:04.854 --> 00:04:05.657
威尔 · 森塔斯: 因为，不,
&gt;&gt; Will Sentance: Because well no,

86
00:04:05.657 --> 00:04:06.890
这个活动需要处理。
the event needs handling.

87
00:04:06.890 --> 00:04:10.764
让我们来讨论一下微任务队列单词与 Jason 的单词之间的关系
Let's talk a bit about how the micro
task queue words relates to what Jason's

88
00:04:10.764 --> 00:04:11.487
问他们。
asking them.

89
00:04:11.487 --> 00:04:15.049
如果不是真正有趣呢？
What if isn't really interesting?

90
00:04:15.049 --> 00:04:18.800
所以对于承诺对象，我可以直接创建一个。
So it turns out with promise objects,
I can just create one directly.

91
00:04:18.800 --> 00:04:21.016
我不需要通过获取自动创建它,
I don't need to have it
automatically created by fetch,

92
00:04:21.016 --> 00:04:22.410
我只能说创造一个。
I can actually just say create one.

93
00:04:22.410 --> 00:04:28.571
如果我说解决这个问题，也就是说在那一刻，在那一行代码中。
If I then say resolve that, that is to
say in that line of code in that moment.

94
00:04:28.571 --> 00:04:30.641
让它自动完成
Have it automatically complete and

95
00:04:30.641 --> 00:04:33.822
我可以控制这个功能。
have its function at that I
can control that function.

96
00:04:33.822 --> 00:04:34.752
我们可以通过抓取来做到这点。
We can do that with fetch.

97
00:04:34.752 --> 00:04:38.322
因为获取在这里处理关系，但是
Because fetch is handling
the relationship here, but

98
00:04:38.322 --> 00:04:43.302
如果我制作了自己的承诺对象，那么我就可以有附加的功能。
if I make my own promise object, then I
can have the function attached to it.

99
00:04:43.302 --> 00:04:47.778
我可以直接将它插入到微任务队列中
I can directly myself have it stuck
into the microtask queue by having

100
00:04:47.778 --> 00:04:52.036
承诺对象的值属性更新并完整。
the value property of that promise
object updated and complete.

101
00:04:52.036 --> 00:04:55.577
并自动触发该函数在微任务队列中运行。
And automatically trigger the function
to run in the microtask queue.

102
00:04:55.577 --> 00:04:57.704
这里有一个非常有趣的场景。
Here's a really interesting scenario.

103
00:04:57.704 --> 00:05:02.456
如果当我运行微任务中的函数时
If when I'm running the function
that was in my microtask

104
00:05:02.456 --> 00:05:06.425
队列显示，如果在那里面。
queue that was displayed,
If inside of there.

105
00:05:06.425 --> 00:05:10.855
我创建了一个全新的承诺对象，它的相关功能
I create a brand new promise object
that its associated function

106
00:05:10.855 --> 00:05:12.829
当我在里面展示的时候。
while I was inside display.

107
00:05:12.829 --> 00:05:15.622
这个承诺对象完成了，因为我直接告诉它,
That promise object completed
because I told it to directly,

108
00:05:15.622 --> 00:05:19.437
相关的函数将插入到微任务队列的后端
the associated function will be stuck into
the backend of microtask queue while I'm

109
00:05:19.437 --> 00:05:20.528
还在里面展示。
still inside display.

110
00:05:23.550 --> 00:05:24.331
威尔 · 森坦斯: 这是一个真正的
&gt;&gt; Will Sentance: Here's a really

111
00:05:24.331 --> 00:05:26.518
有趣的情况可能会发生。
interesting situation
that can happen then.

112
00:05:26.518 --> 00:05:31.086
我可以在微任务队列的后面填充更多内容
I can be filling in the back of
the micro task queue with more

113
00:05:31.086 --> 00:05:34.641
当我还在里面展示的时候就可以运行了。
functions while I'm still inside display.

114
00:05:34.641 --> 00:05:36.524
事件循环非常有趣
And the event loop is interesting and

115
00:05:36.524 --> 00:05:40.423
如何与微任务队列交互是一个非常非常大的奖励。
how it interacts with the micro task
queue is a very, very big bonus sort of.

116
00:05:40.423 --> 00:05:44.798
如果你想知道节点的硬件部分，我们会进入一些更详细的内容。
If you go to if you want to know the node
hard parts, we go into some more detail.

117
00:05:44.798 --> 00:05:46.560
他们太担心这个了。
They're worried too much about this.

118
00:05:46.560 --> 00:05:50.346
但我感觉如果我想，我在里面展示和
But I am feeling if I want
I'm inside display and

119
00:05:50.346 --> 00:05:53.480
在这后面填充新的功能。
filling in new functions behind here.

120
00:05:53.480 --> 00:05:56.199
他们自己也在建立一个新的功能。
And they themselves
are building a new functions.

121
00:05:56.199 --> 00:05:59.254
这些都是新的函数，几乎是递归的。
And then those are pretty new
function almost recursively.

122
00:05:59.254 --> 00:06:03.603
我将永远不会离开微剂量队列，因为事件循环
I will never leave the microdose
queue because the event loop

123
00:06:03.603 --> 00:06:07.194
总是在调用堆栈上执行。
will always take in and
execute on the call stack.

124
00:06:07.194 --> 00:06:08.447
它总是会回到过去
It will always go back and

125
00:06:08.447 --> 00:06:11.567
在进入回调队列之前检查微任务。
check the microtask before it
moves on to the callback queue.

126
00:06:11.567 --> 00:06:15.274
这与进入回调队列后完成所有任务的回调队列是不同的
That is in distinction to the callback
queue which once it enters does all

127
00:06:15.274 --> 00:06:17.656
里面的东西，然后再转一圈。
the stuff in there and
then moves round again.

128
00:06:17.656 --> 00:06:20.415
一旦进入微任务队列,
The microtask queue once it enters,

129
00:06:20.415 --> 00:06:24.694
如果你在后面加油，就别想离开。
if you are refilling in the back,
you ain't leaving it.

130
00:06:24.694 --> 00:06:29.591
在 Node 中，您得到了所谓的饿死回调队列。
You get what's called starve
the callback queue and in Node.

131
00:06:29.591 --> 00:06:33.963
这一点特别重要，因为您希望，您知道，生产应用程序。
This is particularly important because you
want to, you know, production application.

132
00:06:33.963 --> 00:06:38.379
这就是为什么在使用时要小心谨慎
And this is why there's some
caution around around using

133
00:06:38.379 --> 00:06:40.771
过程下一滴答方法。
the process next tick method.

134
00:06:40.771 --> 00:06:43.939
在这个队列中插入一些东西
Which sticks stuff in this queue, and

135
00:06:43.939 --> 00:06:49.696
可以递归地使您无法处理来自用户的请求。
can recursively starve you handling
your requests from your users.

136
00:06:49.696 --> 00:06:52.992
瓦朗斯我的话题，但去看节点哈珀的，你感兴趣的，但
Valence I topic, but go watch the Node
Harper's, you're interested in that, but

137
00:06:52.992 --> 00:06:56.024
有趣的是，它们的行为方式略有不同。
it's an interesting nature that these
are behaving slightly differently.

138
00:06:56.024 --> 00:07:00.468
正如杰森暗示的那样，还有一个布雷登，是不是
Just as Jason was hinting,
there was one more Brayden, was it or

139
00:07:00.468 --> 00:07:02.151
是 Peter 还是 Kayla？
was it Peter or Kayla?

140
00:07:02.151 --> 00:07:03.983
丹，是丹，说吧，丹。
Dan, it was Dan, yeah, go ahead, Dan.

141
00:07:03.983 --> 00:07:07.814
扬声器2: 是的，当你可能已经提到这一点，但是。
&gt;&gt; Speaker 2: Yeah when you may
have already mentioned this, but.

142
00:07:07.814 --> 00:07:10.838
什么项目进入微任务队列，什么项目进入。
What items go into the microtask queue and
what items go into.

143
00:07:10.838 --> 00:07:11.591
威尔 · 森塔斯: 很好，很好。
&gt;&gt; Will Sentance: Great, great point.

144
00:07:11.591 --> 00:07:13.920
让我们把话说清楚。
Let's just be really, really clear.

145
00:07:13.920 --> 00:07:18.540
任何通过这两个分支之一连接到承诺对象的函数
Any function that is attached to a promise
object by one of these two prongs for

146
00:07:18.540 --> 00:07:19.755
存储函数。
stored functions.

147
00:07:19.755 --> 00:07:23.026
这就给了 add 一个 promise 对象，我们用它们给它附加了一个函数。
Which gives add a promise object we
attach a function to it using them.

148
00:07:23.026 --> 00:07:26.675
这些功能都会进入到你的微任务中。
Those functions all go
into the micro-task you.

149
00:07:26.675 --> 00:07:31.000
任何直接传递给 facade 函数的函数都会触发 web
Any function that's passed in directly
to a facade function that triggers a web

150
00:07:31.000 --> 00:07:35.079
浏览器功能，你看到的参考，链接到这里的功能。
browser feature you see the reference
that link to the function down here.

151
00:07:35.079 --> 00:07:37.682
这些功能，当他们完成或
Those functions when they complete or

152
00:07:37.682 --> 00:07:42.975
对不起，当后台任务的计时器完成这个函数回调。
sorry when the background task the timer
completes this function callback.

153
00:07:42.975 --> 00:07:44.542
所以我们必须进入 MDN
So we have to go into MDN and

154
00:07:44.542 --> 00:07:49.481
看，我们特殊的正面功能，能触发背景中的东西吗？
see, does our particular facade function
that trigger stuff in the background?

155
00:07:49.481 --> 00:07:51.927
它包含一个函数吗？
Does it take in a function?

156
00:07:51.927 --> 00:07:54.401
那个会进入回调队伍吗？
That one's going to go
into the callback queue?

157
00:07:54.401 --> 00:07:57.665
或者它会返回去提出一个承诺对象
Or does it return out to
promed a promise object and

158
00:07:57.665 --> 00:08:02.199
他们抛出的背景，但没有抛出一个函数在这里。
they toss to the background but
doesn't throw a function down here.

159
00:08:02.199 --> 00:08:06.387
Promise 对象上的关联函数，即-微任务队列。
The associative function on the promise
object, that- microtask queue.

160
00:08:06.387 --> 00:08:07.689
好的，亲爱的。
Okay, sweet.
