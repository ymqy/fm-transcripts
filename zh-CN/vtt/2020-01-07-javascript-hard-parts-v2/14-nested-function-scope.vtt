WEBVTT

1
00:00:00.050 --> 00:00:02.669
威尔 · 森坦斯: 所以我们看到 a 函数可以返回
&gt;&gt; Will Sentance: So we saw there
that A function can be returned

2
00:00:02.669 --> 00:00:04.049
从运行与其他功能,
from the running with other function,

3
00:00:04.049 --> 00:00:09.519
存储在全局标签中，通过新的全局标签在函数中使用它。
stored in the global label, used that in
the function by its new global label.

4
00:00:09.519 --> 00:00:13.419
它与函数的原始运行没有任何关系
And it has nothing to do with
the original running of the function that

5
00:00:13.419 --> 00:00:16.289
从中创建内部功能，然后返回。
from which that inner function
was created, was returned.

6
00:00:17.559 --> 00:00:18.390
现在我们来看看。
Let's now see.

7
00:00:19.429 --> 00:00:21.199
稍微接近的东西。
Something slightly adjacent.

8
00:00:21.199 --> 00:00:23.910
在我们结束之前，我们需要明白的最后一件事。
And the last thing we need to understand,
before we hit closure.

9
00:00:23.910 --> 00:00:29.480
在同一个函数调用中调用一个函数，就像它被定义的那样。
Calling a function in the same
function call, as it was defined.

10
00:00:29.480 --> 00:00:30.079
我看着这个。
I look at this.

11
00:00:30.079 --> 00:00:32.469
我要去拯救外部，还没有做它的任何代码,
I'm gonna save outer,
not do any of its code yet,

12
00:00:32.469 --> 00:00:36.740
运行外部，创建计数器作为0内，存储它。
run outer,
create counter as 0 inside, store it.

13
00:00:36.740 --> 00:00:42.170
保存 incrementCounter 函数，存储它，然后调用该函数。
Save the function incrementCounter
Store it, and then call that function.

14
00:00:42.170 --> 00:00:44.009
然后，看起来，我们要寻找
And then, by the looks of it,
we're gonna look for

15
00:00:44.009 --> 00:00:47.820
不在 incrementCounter 函数中的一些数据。
some data that is not inside
that incrementCounter function.

16
00:00:47.820 --> 00:00:50.840
但是我们要跳出一个层次的外部的呼唤。
But we're gonna step out one
layer to the call of outer.

17
00:00:51.869 --> 00:00:53.939
使用罚款调用同一函数角中的函数。
Calling a function in the same
function corners with a fine.

18
00:00:53.939 --> 00:00:56.630
增量计数器是通过保存 outer 和
Increment counter was defined
with saving the call of outer and

19
00:00:56.630 --> 00:00:57.619
那就马上用。
then use immediately.

20
00:00:57.619 --> 00:00:58.320
马上打电话。
Call immediately.

21
00:01:00.850 --> 00:01:04.109
这会产生非同寻常的后果。
This is gonna have
extraordinary consequences.

22
00:01:04.109 --> 00:01:08.030
还有我们自己，我们在想是什么决定了我跑步的时候
And also ourselves we thinking what
determines the fact that when I run

23
00:01:08.030 --> 00:01:10.439
外层内增量计数器。
increment counter inside of outer.

24
00:01:10.439 --> 00:01:13.430
在增量计数器里面没有找到计数器,
And I don't find counter
inside of increment counter,

25
00:01:13.430 --> 00:01:16.680
我不知道为什么会有存储在外部的计数器。
I'm somehow going to have access
to counter stored in outer.

26
00:01:16.680 --> 00:01:18.689
每个人都知道答案。
Everyone already knows the answer.

27
00:01:20.069 --> 00:01:21.010
那你呢？
Well, do you?

28
00:01:21.010 --> 00:01:22.620
好了我们开始吧。
All right, here we go.

29
00:01:22.620 --> 00:01:23.180
一号线。
Line one.

30
00:01:23.180 --> 00:01:27.689
我们在马太福音第一行做什么,
What are we doing in
line one over to Matthew,

31
00:01:27.689 --> 00:01:30.049
马修今晚我们要做什么？
Matthew tonight What are we doing?

32
00:01:30.049 --> 00:01:32.479
扬声器2: 您正在定义外部函数全局作用域。
&gt;&gt; Speaker 2: You're defining
the outer function global scope.

33
00:01:32.479 --> 00:01:37.120
Will Sentance: Beautiful 定义了外部函数。
&gt;&gt; Will Sentance: Beautiful define
defining the outer function.

34
00:01:38.150 --> 00:01:38.799
讲者2: 在哪里？
&gt;&gt; Speaker 2: Where?

35
00:01:38.799 --> 00:01:40.780
威尔 · 森坦斯: 让我们称之为全局记忆。
&gt;&gt; Will Sentance: Let's
call it in a global memory.

36
00:01:40.780 --> 00:01:45.129
为了准确起见，我想告诉你具体是什么
Just to keep precise I wanna
give you what specifically

37
00:01:45.129 --> 00:01:49.950
作用域最持久的东西是在这篇文章的最后。
JavaScript scope's most permanent thing
is towards the end of this piece.

38
00:01:49.950 --> 00:01:53.939
所以现在让我们只说 outer 是在我们的全局执行上下文内存中找到的
So for now let's just say outer is to find
in our global execution context memory in

39
00:01:53.939 --> 00:01:56.027
我们的全球记忆，就在那里。
our global memory, there it is.

40
00:01:56.027 --> 00:02:00.293
好极了。
Excellent.

41
00:02:00.293 --> 00:02:07.370
现在轮到你了 Kayla 我们接下来要做什么？
Now, what do we do next,
over to you, Kayla, we are going to?

42
00:02:08.560 --> 00:02:10.090
说话人3: 执行外部功能。
&gt;&gt; Speaker 3: Execute the outer function.

43
00:02:10.090 --> 00:02:11.419
威尔 · 森特斯: 很好，意思是每个人,
&gt;&gt; Will Sentance: Excellent,
meaning everybody,

44
00:02:11.419 --> 00:02:14.819
我们要创造一个全新的-演讲者4: 执行上下文。
we're gonna create a brand new-
&gt;&gt; Speaker 4: Execution context.

45
00:02:14.819 --> 00:02:16.020
威尔 · 森特斯: 好极了。
&gt;&gt; Will Sentance: Excellent, all right.

46
00:02:16.020 --> 00:02:21.569
进入执行上下文，我们去，很酷的堆栈真的很重要，因为我们在这里
Into the execution context we go,
cool stack really important here cuz we're

47
00:02:21.569 --> 00:02:25.289
现在调用函数内部的函数，这样会更有趣。
now calling a function inside of function
so it's always gonna be more interesting.

48
00:02:25.289 --> 00:02:27.629
所以我们有全球性的，总是在底部。
So we've got global as
always on the bottom.

49
00:02:29.990 --> 00:02:33.329
然后我们现在在顶部添加了外部。
Then we have now outer added on top.

50
00:02:35.240 --> 00:02:36.920
很好，很好，准备好了，对吗？
Nicely.
Nice and ready, right?

51
00:02:36.920 --> 00:02:38.770
我自己也很惊讶。
Is this is surprised myself.

52
00:02:38.770 --> 00:02:47.550
在六月，我们去我们的本地记忆彼得，我们首先存储什么？
In June, we go In our local memory Peter,
what are we storing first?

53
00:02:47.550 --> 00:02:49.199
演讲者2: 我们正在存储可变计数器。
&gt;&gt; Speaker 2: We're storing
the variable counter.

54
00:02:49.199 --> 00:02:50.449
我们的值是0。
We have values 0.

55
00:02:50.449 --> 00:02:52.770
威尔 · 森特斯: 是的，我知道人们在变量，所以
&gt;&gt; Will Sentance: Yeah,
I know people at the variable so

56
00:02:52.770 --> 00:02:54.550
我们可以改变里面的价值。
we can alter the value stored in it.

57
00:02:54.550 --> 00:03:00.439
现在我们到了布拉登旁边的哪条夜线，接下来我们做什么？
Now we hit what night line next
over to Braden, what do we do next?

58
00:03:00.439 --> 00:03:03.000
说话人2: 你在定义函数增量计数器。
&gt;&gt; Speaker 2: You're defining
the function increment counter.

59
00:03:03.000 --> 00:03:06.590
是的，在哪个执行上下文的本地内存中？
&gt;&gt; Will Sentance: Yeah, inside of
which execution context local memory?

60
00:03:06.590 --> 00:03:08.800
只要提醒我们，我知道我们可以看到它，但只要提醒我们。
Just remind us, I know we can see it,
but just remind us.

61
00:03:10.370 --> 00:03:12.750
我们在哪个执行环境中定义它？
We're defining it inside
which execution context?

62
00:03:12.750 --> 00:03:13.500
演讲者2: 内在外在。
&gt;&gt; Speaker 2: Inside the outer.

63
00:03:13.500 --> 00:03:14.919
在外部的执行上下文中,
&gt;&gt; Will Sentance: Inside
outer's execution context,

64
00:03:14.919 --> 00:03:17.300
我们把它保存在外层的执行上下文中。
we're saving it inside of
outer's execution context.

65
00:03:17.300 --> 00:03:18.800
我们在使用它吗？
And are we using it?

66
00:03:18.800 --> 00:03:19.759
是的。
Yeah, we are.

67
00:03:19.759 --> 00:03:21.129
布莱登，接下来我们该怎么办？
Braden, what are we gonna do next?

68
00:03:21.129 --> 00:03:24.870
扬声器2: 你要增加计数器变量。
&gt;&gt; Speaker 2: You're going to
increment the counter variable.

69
00:03:24.870 --> 00:03:26.449
是的，我们要执行什么函数？
&gt;&gt; Will Sentance: Yeah we're
gonna execute what function?

70
00:03:28.270 --> 00:03:30.060
瑞典的下一个职能是什么？
What function next Sweden?

71
00:03:30.060 --> 00:03:33.009
是的，所以布拉登看起来像布拉登可能会跳
Yes, so Braden do you see
looked like Braden might jump

72
00:03:33.009 --> 00:03:35.920
直接进入函数，我们保存函数的代码。
straight into the function we
save the code of the function.

73
00:03:35.920 --> 00:03:39.199
计数器加号存储在标签增量计数器下。
Counter plus plus was stored under
the label increment counter.

74
00:03:39.199 --> 00:03:41.579
然后我们继续做什么，布莱登？
And we moved on to do what, Braden?

75
00:03:41.579 --> 00:03:42.969
说话人2: 调用递增计数器。
&gt;&gt; Speaker 2: To call increment counter.

76
00:03:42.969 --> 00:03:44.740
是的，是什么让我们这么叫它的？
&gt;&gt; Will Sentance: Yeah,
what told us to call it?

77
00:03:44.740 --> 00:03:45.340
说话人2: 括号。
&gt;&gt; Speaker 2: The parentheses.

78
00:03:45.340 --> 00:03:47.189
威尔 · 句子: 括号，确切地说是朋友和
&gt;&gt; Will Sentance: Parentheses,
exactly friends and

79
00:03:47.189 --> 00:03:49.310
我们创造一种全新的水，每个人。
we create a brand new water everybody.

80
00:03:50.319 --> 00:03:52.360
行动联系非常好。
Action contacts excellent.

81
00:03:52.360 --> 00:03:54.670
在它的本地内存中，这变得非常小。
And in its local memory
This is getting very small.

82
00:03:54.670 --> 00:03:57.765
在他当地的记忆里，我打破了我的规则。
I'm breaking my rules
here in his local memory.

83
00:03:57.765 --> 00:03:58.960
很酷的堆栈。
Cool stack.

84
00:03:58.960 --> 00:04:01.469
在冷却的一面会发生什么？
What happens on the cool side down?

85
00:04:01.469 --> 00:04:03.689
我们增加了增量计数器。
We add increment counter.

86
00:04:03.689 --> 00:04:06.319
是的，我们有很酷的增量计数器。
Yeah we got the cool to increment counter.

87
00:04:06.319 --> 00:04:09.659
这就是调用堆栈，因为它是在外部记录的。
Onto the call stack there it is,
because recording it inside of outer.

88
00:04:09.659 --> 00:04:13.229
当我们运行完它，全局我们将返回到外部，对不对？
When we finished running it,
global we'll go back to outer, right?

89
00:04:13.229 --> 00:04:15.129
这是一种很好的记录一切的方式。
It's kind of nice it
keeps track of it all.

90
00:04:15.129 --> 00:04:19.957
好的，现在 incrementCounter 内部的实际代码行是什么
Okay, what is the actual line of code
toward inside of incrementCounter that now

91
00:04:19.957 --> 00:04:20.954
被处决了？
gets executed?

92
00:04:20.954 --> 00:04:22.694
所以你只要告诉我确切的词。
So you just give me the exact words.

93
00:04:23.855 --> 00:04:25.105
讲者2: 描述计数器。
&gt;&gt; Speaker 2: An incriment counter.

94
00:04:25.105 --> 00:04:26.404
威尔 · 森特斯: 是的，你们都很有想象力。
&gt;&gt; Will Sentance: Yeah,
you're all very fancy.

95
00:04:26.404 --> 00:04:27.314
直接告诉我,
Just give me the literally,

96
00:04:27.314 --> 00:04:30.264
我只是想说清楚，因为我的名字和我的功能有很大的模糊性。
just to be clear because it's a big
ambiguous with my name of my functions.

97
00:04:30.264 --> 00:04:31.954
那么字面上来说，到底什么样的词才能被运用呢？
So literally what is
the exact words that get run?

98
00:04:31.954 --> 00:04:33.822
确切的数字是多少?-说话人2: 它会加上
What's the exact-
&gt;&gt; Speaker 2: It'll add

99
00:04:33.822 --> 00:04:34.944
一个人对他们的威尔 · 森特斯说: 看,
one to their-
&gt;&gt; Will Sentance: See,

100
00:04:34.944 --> 00:04:39.451
通讯非常好，但是字面意思是加强计数器。
the communication's so good, but
literally it says counter plus plus.

101
00:04:39.451 --> 00:04:43.132
不，别担心，托德，你的意义远远不止是是计数器
No don't worry Todd, you're being much
more meaningful than just yeah counter

102
00:04:43.132 --> 00:04:45.651
再加上，也就是说要在计数器上加一。
plus plus, which means add one to counter.

103
00:04:45.651 --> 00:04:47.651
好了，该查查了。
Okay, time to do some look up.

104
00:04:47.651 --> 00:04:52.699
我要用绿色笔来查找我要用绿色底片当我抬头看的时候,
I'm gonna use green pen for my lookup And,
I'm gonna use green film when I look up,

105
00:04:52.699 --> 00:04:57.050
我该先去哪里找柜台，马特？
and where do I look for
counter first, Matt?

106
00:04:57.050 --> 00:04:59.480
扬声器2: 你要在增量计数器的上下文中查找。
&gt;&gt; Speaker 2: You're gonna look in
the context of increment counter.

107
00:04:59.480 --> 00:05:00.029
威尔 · 森特斯: 是的，很漂亮。
&gt;&gt; Will Sentance: Yeah, beautiful.

108
00:05:00.029 --> 00:05:01.170
我能找到柜台吗？
Do I find counter?

109
00:05:01.170 --> 00:05:01.720
讲者二: 没有 威尔 · 森塔斯: 不，是这样
&gt;&gt; Speaker 2: No.
&gt;&gt; Will Sentance: No, so

110
00:05:01.720 --> 00:05:03.339
接下来我该往哪里看？
where do I look out next?

111
00:05:03.339 --> 00:05:04.889
演讲者2: 上到外部语境。
&gt;&gt; Speaker 2: Go up to the outer context.

112
00:05:04.889 --> 00:05:07.660
威尔: 进入外层，我会找到反面吗？
&gt;&gt; Will Sentance: Into outer,
do I find counter?

113
00:05:07.660 --> 00:05:08.379
当然了。
You bet I do.

114
00:05:11.040 --> 00:05:11.769
当然了。
You bet I do.

115
00:05:11.769 --> 00:05:14.416
我找到了计数器，并把它增加到什么马特？
I find counter, and
increment it to what Matt?

116
00:05:14.416 --> 00:05:16.009
讲者二: 一 威尔 · 森特斯: 为了一个人，为了我,
&gt;&gt; Speaker 2: One.
&gt;&gt; Will Sentance: To one, what I;m up,

117
00:05:16.009 --> 00:05:17.029
没错。
exactly.

118
00:05:17.029 --> 00:05:20.370
换句话说，现在所有的事情都在暗示着
In other words,
everything would suggest right now

119
00:05:20.370 --> 00:05:24.839
我第一次看我的呼叫栈顶部，没有找到我要找的东西。
that I first looked top of my call stack,
didn't find what I was looking for.

120
00:05:24.839 --> 00:05:29.540
所以我猜，因为我运行的是递增计数器，在 outer 的运行中。
So I guess, because I'm running increment
counter, inside the running of outer.

121
00:05:29.540 --> 00:05:32.069
我该怎么办，我往下走了一层。
What do I do, I went down one layer.

122
00:05:32.069 --> 00:05:35.470
在我的酷栈，失去了外部的权利，听起来是正确的，不是吗？
Down my cool stack and losing the outer
right that sounds right isn't it?

123
00:05:36.590 --> 00:05:38.970
嗯，在我看来是对的。
Hmm, it seems right to me.

124
00:05:38.970 --> 00:05:42.980
我想我从内部到外部运行它看起来并没有错
I guess I'm running it inside of
outside doesn't seem wrong and yet

125
00:05:42.980 --> 00:05:48.319
现在的食物，这是一个真正的谜，是否。
food right now,
that is genuinely a mystery as to whether.

126
00:05:49.930 --> 00:05:55.240
这是一个事实，我正在运行增量计数器在运行的外部
It's a fact that I'm running increment
counter inside the running of outer that

127
00:05:55.240 --> 00:05:59.379
当我在本地内存的增量计数器中找不到计数器的时候给我访问
gives me access when I don't find counter
in local memory of increment counter to go

128
00:05:59.379 --> 00:06:06.610
还是因为我保存了。
out to outers local memory, or
is it the fact that I saved.

129
00:06:06.610 --> 00:06:10.560
外部运行中的增量计数器
Increment counter inside
the running of outer

130
00:06:10.560 --> 00:06:14.910
我定义它，我字面上保存了它的代码在运行的外部。
that I defined it that I literally saved
its code inside the running of outer.

131
00:06:15.959 --> 00:06:20.759
现在，我不知道，实际上我现在不能告诉你。
Right now, I can't tell,
I actually couldn't tell you right now.

132
00:06:20.759 --> 00:06:23.670
所以我用增量计数器做了两件事。
So I did two things with
increment counter inside about.

133
00:06:23.670 --> 00:06:26.230
(1)我在外层运行它。
(1) I ran it inside of outer.

134
00:06:26.230 --> 00:06:31.730
跑进里面的外面，我把它保存在里面的外面。
running inside of outer into,
I saved it inside of outer.

135
00:06:31.730 --> 00:06:34.850
可能是因为我看到了外部世界的内部。
It could be the fact that I
see that inside of outer.

136
00:06:34.850 --> 00:06:38.269
这意味着它在运行时以某种方式有一个连接
That means somehow it has
a connection when it gets run

137
00:06:38.269 --> 00:06:40.680
放在柜台旁边。
to the counter that was
stored adjacent to it.

138
00:06:40.680 --> 00:06:44.519
或者可能是因为我现在在外层运行它。
Or it could be the fact that I
run it inside of outer right now.

139
00:06:44.519 --> 00:06:46.060
我不知道。
I can't tell.

140
00:06:46.060 --> 00:06:50.680
然而，这将是理解闭包的基础。
And yet it's going to be fundamental
to understanding closure.

141
00:06:50.680 --> 00:06:51.949
答案是什么
What the answer to that is
