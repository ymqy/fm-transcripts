WEBVTT

1
00:00:00.000 --> 00:00:01.470
威尔 · 森坦斯: 但是还有一点。
&gt;&gt; Will Sentance: But
there's one more bit.

2
00:00:01.470 --> 00:00:04.334
如果我们正如彼得所说,
If we're filling in, as Peter says,

3
00:00:04.334 --> 00:00:08.900
用来自 Twitter 的数据，字符串 hi,
that value property with
the data from Twitter, string hi,

4
00:00:08.900 --> 00:00:14.380
然后我们希望能够以某种方式使用它，展示它，利用它。
then we wanna be able to use that in
some way, display it, make use of it.

5
00:00:14.380 --> 00:00:15.859
马克，你能帮帮我吗？
Mark, can you help me out?

6
00:00:18.210 --> 00:00:21.213
如果我知道值属性更新时,
If I know that when that
value property gets updated,

7
00:00:21.213 --> 00:00:25.439
它会自动运行这个未完成数组中的任何函数。
it's going to automatically run any
function in this unfulfilled array.

8
00:00:25.439 --> 00:00:29.181
如何将函数添加到这个隐藏的未实现数组中？
How do I get a function into
this hidden unfulfilled array?

9
00:00:29.181 --> 00:00:32.899
我应该用什么方法把一个函数放到这个未完成的数组中，马克？
What method am I given to get a function
into that unfulfilled array, Mark?

10
00:00:32.899 --> 00:00:35.570
离开银幕。 那么，威尔 · 森坦斯: 。 然后是 then 方法。
&gt;&gt; off-screen male: .then
&gt;&gt; Will Sentance: .then, the then method.

11
00:00:35.570 --> 00:00:36.490
完全正确。
Exactly right.

12
00:00:36.490 --> 00:00:40.243
它的承诺是由 JavaScript 设计的自动触发
The promise of it is designed by
JavaScript to automatically trigger

13
00:00:40.243 --> 00:00:43.543
以此值作为输入运行该数组中的函数
the functions in this array to
run with this value as its input

14
00:00:43.543 --> 00:00:47.249
当这个值被 JavaScript 自动更新的时候。
when that value gets updated
automatically by JavaScript, okay.

15
00:00:47.249 --> 00:00:50.405
现在我们来做这个附件。
So let's do that attachment right now.

16
00:00:50.405 --> 00:00:57.228
然后，我们传入整个引用,
FutureData.then, we pass
in the entire reference,

17
00:00:57.228 --> 00:01:02.875
我们会连接到整个显示功能。
we'll link to the entire display function.

18
00:01:02.875 --> 00:01:06.801
这就是整个显示功能。
There it is, the entire display function.

19
00:01:06.801 --> 00:01:11.891
我们要把它抓起来放进去，我要在这里吸一口吗？
We're gonna grab it and store it into,
should I do a line here?

20
00:01:11.891 --> 00:01:14.269
然后抓起来放进去，我知道该怎么做了。
And grab it and store it into,
I know what I'll do.

21
00:01:14.269 --> 00:01:18.243
然后把它存储进去，所以未来的数据就是这个粉红色的物体。
Gonna grab it and store it into, so
future data is this pink object here.

22
00:01:18.243 --> 00:01:24.890
我们要抓取它，并将其存储到未实现的数组中，在那个承诺对象中。
We're gonna grab it and store it into
array unfulfilled, in that promise object.

23
00:01:24.890 --> 00:01:29.819
所以我们要抓住显示器和[声音]使用声音效果，对不对？
So we're gonna grab display and
[SOUND] using sound effects, right?

24
00:01:29.819 --> 00:01:36.146
进入未完成的数组，它就在那里。
In it goes into the unfulfilled array,
there it is.

25
00:01:36.146 --> 00:01:39.412
显示功能。
The display function.

26
00:01:39.412 --> 00:01:42.819
这意味着当后台工作完成后,
So that means that when
the background work completes,

27
00:01:42.819 --> 00:01:47.600
value 属性会更新，它会自动触发显示
the value property gets updated,
it's automatically gonna trigger display

28
00:01:47.600 --> 00:01:50.860
运行，其中显示的输入被返回或
to run, where display's
input being the returned or

29
00:01:50.860 --> 00:01:55.215
响应对象就是 Tweet，字符串 hi。
the response object which is gonna
be just that Tweet, the string hi.

30
00:01:55.215 --> 00:01:57.770
看起来它会被展示出来,
And it's gonna fill in by
the looks of it into display,

31
00:01:57.770 --> 00:01:59.979
他们已经准备好了一些参数。
they've got a little parameter waiting.

32
00:01:59.979 --> 00:02:02.694
数据可以用字符串 hi，参数填充。
Data can be filled in with the string hi,
the argument.

33
00:02:02.694 --> 00:02:03.411
非常好。
Very nice.

34
00:02:03.411 --> 00:02:10.324
[声音]很好，我们已经准备好了两个背景作品。
[SOUND] Good, we have set up
two pieces of background work.

35
00:02:10.324 --> 00:02:14.067
其中一个已经完成并且在队列中，相关的函数,
One of them's already complete and landed
in the queue, the associated function,

36
00:02:14.067 --> 00:02:14.710
准备跑。
ready to run.

37
00:02:16.560 --> 00:02:17.930
我肯定它随时都会播出。
I'm sure it's gonna run any moment now.

38
00:02:19.490 --> 00:02:23.977
当我们接近2毫秒的时候,
As we head on to at 2 milliseconds,

39
00:02:23.977 --> 00:02:29.072
我们要执行什么功能？
we're going to execute what function?

40
00:02:29.072 --> 00:02:32.298
Jason 在2毫秒的时间里我们刚刚完成了未来,
Jason, at 2 milliseconds,
we just finished our FutureDays.then,

41
00:02:32.298 --> 00:02:35.055
我们要在2毫秒内运行什么函数，杰森？
we're gonna run what function
at 2 milliseconds, Jason?

42
00:02:35.055 --> 00:02:38.936
我们将进行显示或假设我们在下面一行,
&gt;&gt; off-screen male: We are going to run
display or assuming we're one line below,

43
00:02:38.936 --> 00:02:40.286
blockfor300ms.
BlockFor300ms.

44
00:02:40.286 --> 00:02:43.223
威尔 · 森塔斯: 阻塞300毫秒，他说对了。
&gt;&gt; Will Sentance: BlockFor300ms,
he's spot on.

45
00:02:43.223 --> 00:02:50.062
就是这个，BlockFor300ms。
There it is, BlockFor300ms.

46
00:02:50.062 --> 00:02:50.731
全新的。
Brand new.

47
00:02:50.731 --> 00:02:52.609
[笑声]演讲者3: 执行环境。
[LAUGH]
&gt;&gt; Speaker 3: Execution context.

48
00:02:52.609 --> 00:02:54.745
威尔 · 森特斯: 美丽的人，没错！
&gt;&gt; Will Sentance: Beautiful people,
exactly!

49
00:02:54.745 --> 00:02:58.990
运行 BlockFor300ms 的全新执行环境。
Brand new execution context for
running BlockFor300ms.

50
00:02:58.990 --> 00:03:01.937
我们的电话记录我们要通过人员,
It's going on our call stack,
we're gonna go through people,

51
00:03:01.937 --> 00:03:03.775
很快就能抹去它了。
it's gonna fun to erase it in a moment.

52
00:03:03.775 --> 00:03:11.882
300毫秒，我们进入它。
BlockFor300ms, into it we go.

53
00:03:11.882 --> 00:03:18.816
然后，我们开始，它会增加300毫秒，但是你不会相信。
And, in we go, it's gonna add 300
milliseconds, but you won't believe it.

54
00:03:18.816 --> 00:03:22.759
当我们在里面的时候，你不会相信这里发生了什么。
While we're inside there,
you won't believe what happens down here.

55
00:03:24.120 --> 00:03:25.699
好消息。
Good news people.

56
00:03:25.699 --> 00:03:26.350
好消息。
Good news.

57
00:03:28.700 --> 00:03:33.121
威尔 · 森塔斯: 我们亲爱的推特朋友骑马回来了
&gt;&gt; Will Sentance: Our dear friend
from Twitter has come riding back and

58
00:03:33.121 --> 00:03:38.552
大约在270毫秒的时候说，嘿，我有微博。
said at roughly 270 milliseconds,
hey, I've got tweets.

59
00:03:38.552 --> 00:03:46.240
我得到了 tweets，在270毫秒的时间里，它就完成了。
I've got tweets and at 270 milliseconds,
there it is, it's complete.

60
00:03:46.240 --> 00:03:47.409
我们带回了什么？
And what do we bring back?

61
00:03:47.409 --> 00:03:48.974
我们的推特是什么，彼得？
What's our tweet, Peter?

62
00:03:48.974 --> 00:03:49.951
屏幕外的男性: 字符串 hi。
&gt;&gt; off-screen male: The string hi.

63
00:03:49.951 --> 00:03:51.802
威尔 · 森塔斯: 当然是这根绳子了。
&gt;&gt; Will Sentance: The string hi,
of course it is.

64
00:03:51.802 --> 00:03:54.418
就是这个，绳子 hi。
There it is, the string hi.

65
00:03:54.418 --> 00:03:58.420
好了，现在，事情变得有趣了。
Okay, now, stuff gets interesting.

66
00:03:58.420 --> 00:04:03.034
当他回来或者从互联网上得到回复时,
When hi returns or gets responded
back from speaking to the Internet,

67
00:04:03.034 --> 00:04:06.018
马克，什么自己的完成会发生？
Mark, what own completion is gonna happen?

68
00:04:06.018 --> 00:04:07.163
屏幕外雄: FutureData.value。
&gt;&gt; off-screen male: FutureData.value.

69
00:04:07.163 --> 00:04:09.760
威尔 · 森塔斯: 这将是[相声]精确的,
&gt;&gt; Will Sentance: It's gonna
be [CROSSTALK] exactly,

70
00:04:09.760 --> 00:04:15.051
会触发 Kayla 在调用堆栈上运行什么函数？
which is gonna trigger, Kayla,
what function to run on the call stack?

71
00:04:15.051 --> 00:04:16.459
没有。
No.

72
00:04:16.459 --> 00:04:19.035
屏幕外的女性: 不，在排队。
&gt;&gt; off-screen female: No, on the queue.

73
00:04:19.035 --> 00:04:23.101
威尔 · 森塔斯: 这听起来非常合理，这肯定是一个迹象。
&gt;&gt; Will Sentance: That's sounds eminently
reasonable, which is surely a sign.

74
00:04:23.101 --> 00:04:26.290
(笑)威尔 · 森坦斯: 我们确定的是
&gt;&gt; [LAUGH]
&gt;&gt; Will Sentance: What we're sure is that

75
00:04:26.290 --> 00:04:28.569
它不会直接进入调用堆栈，不可能。
it doesn't go straight on the call stack,
no way.

76
00:04:28.569 --> 00:04:32.619
这是不可能的，对吧，因为我们有300毫秒的阻塞。
There's no way it can, right, because
we've got BlockFor300ms right there.

77
00:04:32.619 --> 00:04:34.408
我们现在大概是，会是多少？
We're right now at roughly,
what would it be?

78
00:04:34.408 --> 00:04:38.795
我们大概在，我不知道，这里是什么，270毫秒，或者
We're at roughly, I don't know,
what is it, 270 milliseconds in here, or

79
00:04:38.795 --> 00:04:39.903
周围的东西。
something around.

80
00:04:39.903 --> 00:04:42.610
这就是我们现在所处的情况。
That's at the point that
we're in right now.

81
00:04:42.610 --> 00:04:46.370
等等，我们不能突然在调用堆栈上显示。
Hold on, we can't suddenly throw
display on the call stack.

82
00:04:46.370 --> 00:04:50.620
所以现在，我们注意到，是的，没错。
So let's for now,
let's note, yes, exactly.

83
00:04:50.620 --> 00:04:53.409
然后进入回调队列。
On to the callback queue it goes.

84
00:04:53.409 --> 00:04:55.149
我肯定那是正确的。
I'm sure that must be correct.

85
00:04:56.509 --> 00:04:58.894
这听起来很合逻辑。
That sounds very logical.

86
00:04:58.894 --> 00:05:03.487
这相当于270毫秒。
And that's like 270 milliseconds.

87
00:05:03.487 --> 00:05:08.103
好的，BlockFor300ms 继续运行。
Okay, BlockFor300ms continues running.

88
00:05:08.103 --> 00:05:11.531
我们退出，大家会怎么想,
We exit out, and
what would that be everybody,

89
00:05:11.531 --> 00:05:14.545
大概是302毫秒。
302 milliseconds, yeah, roughly.

90
00:05:14.545 --> 00:05:16.560
可能，确切地说，大致地说，不管怎样。
Probably, exactly, roughly, whatever.

91
00:05:16.560 --> 00:05:20.411
302毫秒，我们把这个从调用堆栈上取下来。
302 milliseconds,
let's get this off the call stack.

92
00:05:20.411 --> 00:05:23.170
让我们从调用堆栈中获取 BlockFor300ms。
Let's get BlockFor300ms
off the call stack.

93
00:05:23.170 --> 00:05:26.600
顺便说一句目前为止大家都很好,
By the way everybody, all so good so far,

94
00:05:26.600 --> 00:05:31.418
在302毫秒的时间里，没有我们没见过的东西。
nothing we haven't seen
before at 302 milliseconds.

95
00:05:31.418 --> 00:05:35.728
已经坐在那里等了302毫秒。
printHello has been sitting there
waiting for literally 302 milliseconds.

96
00:05:35.728 --> 00:05:38.144
我想现在它可以跑了，对吧？
I assume now it's allowed to run, right?

97
00:05:38.144 --> 00:05:38.762
男性: 没有。
&gt;&gt; off-screen male: No.

98
00:05:38.762 --> 00:05:41.627
威尔 · 桑特斯: 没有？
&gt;&gt; Will Sentance: No?

99
00:05:41.627 --> 00:05:43.947
这太疯狂了，现在该怎么办，布雷登？
This is insane, so
what's gonna run at this point, Brayden?

100
00:05:46.954 --> 00:05:49.750
屏幕外男: 我先来，在显示器上。
&gt;&gt; off-screen male: The me first,
on the display.

101
00:05:49.750 --> 00:05:51.391
威尔 · 森坦斯(笑) : 我看到了大脑
[LAUGH]
&gt;&gt; Will Sentance: I see brain

102
00:05:51.391 --> 00:05:52.622
现在敏感了。
sensitization now.

103
00:05:52.622 --> 00:05:57.057
在这一点上，控制台肯定会首先记录我的日志，是的，绝对会。
Definitely the console is gonna log me
first at this point, yeah, absolutely.

104
00:05:57.057 --> 00:06:01.610
因此，我们首先知道，我们的异步代码将获得优先权。
So the me first., we know that our
asynchronous code is gonna get priority.

105
00:06:01.610 --> 00:06:03.834
我们可以做一百万件这样的事情，总是优先处理。
We could do a million of those,
always priority.

106
00:06:03.834 --> 00:06:10.827
所以在302毫秒，我们先得到我。
So at 302 milliseconds, we get me first.

107
00:06:10.827 --> 00:06:15.858
就是这样，对，三百零二毫秒,
That is it, right, at 302 milliseconds,

108
00:06:15.858 --> 00:06:20.000
我们得到了 console.log (我先!)。
we get console.log(Me first!).

109
00:06:20.000 --> 00:06:22.550
现在，事情变得有趣了。
Now, things get interesting.
