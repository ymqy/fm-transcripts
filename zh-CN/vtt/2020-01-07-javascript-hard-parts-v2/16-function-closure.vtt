WEBVTT

1
00:00:00.860 --> 00:00:02.490
威尔 · 森塔斯: 所以它屈服了，但是
&gt;&gt; Will Sentance: And
so it cave whereas but

2
00:00:02.490 --> 00:00:05.790
当他得到返回的函数增量计数器定义
when he got returned up the function
increment counters definition

3
00:00:05.790 --> 00:00:09.807
从运行中返回到我的新功能，并带来了它。
got returned out of the running into
my new function and brought with it.

4
00:00:09.807 --> 00:00:16.539
它周围的所有本地数据都附加到函数定义上。
All its surrounding local data
attached onto the function definition.

5
00:00:16.539 --> 00:00:19.538
我们马上就会知道这是怎么回事了。
We'll see all about how
this works in a moment.

6
00:00:19.538 --> 00:00:25.079
现在，这里有一个美丽的小有它是一个美丽的
For now, here's a beautiful
little there it is a beautiful

7
00:00:25.079 --> 00:00:29.559
背包的数据，这里就是,
backpack of data such that here it is,

8
00:00:29.559 --> 00:00:34.079
当我运行我的新函数之前
such that when I run
my new function before

9
00:00:35.670 --> 00:00:41.439
我全面调查了全球。
I look into global in full.

10
00:00:41.439 --> 00:00:43.619
你认为我们调查的马克在哪里？
Where do you think Mark
that we look into the?

11
00:00:43.619 --> 00:00:45.271
马克: 背包 威尔 · 森特斯: 放进背包,
&gt;&gt; Mark: Backpack.
&gt;&gt; Will Sentance: Into the backpack,

12
00:00:45.271 --> 00:00:46.337
作者: Mark。
spot on by Mark.

13
00:00:51.426 --> 00:00:56.829
威尔 · 森特斯: 我们走进背包，发现了什么，凯拉？
&gt;&gt; Will Sentance: Into the backpack we go,
where what do we find, Kayla?

14
00:00:56.829 --> 00:00:57.969
计数器是零。
&gt;&gt; Kayla: The counter is zero.

15
00:00:57.969 --> 00:00:59.350
威尔 · 森特斯: 那我们该怎么处理它呢？
&gt;&gt; Will Sentance: And what do we do to it?

16
00:00:59.350 --> 00:01:00.429
我们增加它。
&gt;&gt; Kayla: We increment it.

17
00:01:00.429 --> 00:01:04.120
威尔 · 森特斯: 我们把它增加到1，她说对了。
&gt;&gt; Will Sentance: We increment it to one,
she's spot on.

18
00:01:04.120 --> 00:01:05.299
她确实是
She was so

19
00:01:05.299 --> 00:01:09.000
完全正确，我们必须删掉之前的部分，因为她泄露了游戏。
spot on, we have to cut the earlier
bit because she gave away the game.

20
00:01:09.000 --> 00:01:10.510
让我们继续奔跑。
And let's keep running.

21
00:01:10.510 --> 00:01:11.069
我们继续跑吧。
Let's keep running.

22
00:01:11.069 --> 00:01:13.700
我们稍后会进一步讨论这个问题，但是我们先不谈这个执行上下文。
We'll talk more about it in a moment but
let's get out of this execution context.

23
00:01:13.700 --> 00:01:16.530
顺便说一下，如果本地内存中有任何东西，它就会被删除。
By the way, if there had been anything in
local memory, it would've been deleted.

24
00:01:16.530 --> 00:01:20.789
我有种感觉这些数据附加在函数定义上,
I have a feeling this data over here
attached to the function definition,

25
00:01:20.789 --> 00:01:22.030
那东西哪儿也去不了。
that ain't going anywhere.

26
00:01:22.030 --> 00:01:25.480
这是函数定义的一部分，不会有任何改变。
That stuck on the function definition,
that ain't going anywhere.

27
00:01:25.480 --> 00:01:29.950
让我们继续运行，出来我们进入我的新函数，我们从调用堆栈中弹出它。
Let's keep running, out we come in my new
function, we pop it off the call stack.

28
00:01:29.950 --> 00:01:33.060
实际上我必须这么做即使我们要再来一遍
I'm actually gonna have to, even though
we're gonna run it again just so

29
00:01:33.060 --> 00:01:34.900
我们不认为这是一回事,
that we don't think it's the same,

30
00:01:34.900 --> 00:01:38.120
我将从调用堆栈中取出它，然后再次添加它。
I'm literally gonna take it off
the call stack and add it again.

31
00:01:39.189 --> 00:01:40.030
就是这个。
There it is.

32
00:01:40.030 --> 00:01:43.829
返回到全局，在那里我们点击调用什么函数。
Go back out to global where
we hit calling what function.

33
00:01:43.829 --> 00:01:45.200
我该找谁呢，丹。
Who should I call on, Dan.

34
00:01:45.200 --> 00:01:47.460
丹，当我们点击调用时，什么函数？
Dan, when we hit calling, what function?

35
00:01:47.460 --> 00:01:48.049
丹: 我的新功能。
&gt;&gt; Dan: MyNewfunction.

36
00:01:48.049 --> 00:01:49.950
我的新功能。
&gt;&gt; Will Sentance: MyNewfunction.

37
00:01:49.950 --> 00:01:51.599
全新的什么丹？
Brand new what Dan?

38
00:01:51.599 --> 00:01:52.460
布兰: 执行环境。
&gt;&gt; Bran: Execution context.

39
00:01:52.460 --> 00:01:56.026
句子: 执行上下文，很酷的堆栈，那，发生了什么，丹？
&gt;&gt; Will Sentance: Execution context,
cool stack, that, what happens, Dan?

40
00:01:56.026 --> 00:01:58.490
丹: 我的新功能已经启动了。
&gt;&gt; Dan: MyNewfunction is pushed on.

41
00:01:58.490 --> 00:02:00.670
威尔 · 森塔斯: 继续，说得很好。
&gt;&gt; Will Sentance: Pushed on,
very nicely put.

42
00:02:00.670 --> 00:02:03.530
让我们为 MyNewfunction 创建执行上下文。
Let's create that execution context for
MyNewfunction.

43
00:02:04.730 --> 00:02:09.479
我们走进去，本地记忆里没有任何声明。
Into it we go,
nothing in the local memory declared.

44
00:02:09.479 --> 00:02:11.953
我们要运行的代码是什么，托德？
And what is our line of
code we got to run, Todd?

45
00:02:11.953 --> 00:02:13.219
托德: 柜台柱子。
&gt;&gt; Todd: Counter post post.

46
00:02:13.219 --> 00:02:14.485
威尔 · 森特斯: 说得好，托德，太棒了。
&gt;&gt; Will Sentance: Well on Todd, excellent.

47
00:02:14.485 --> 00:02:19.027
托德，我们先去哪里找柜台？
Where Todd do we look for counter first?

48
00:02:19.027 --> 00:02:19.740
托德: 在当地的记忆里。
&gt;&gt; Todd: In the local memory.

49
00:02:19.740 --> 00:02:21.639
威尔 · 森塔斯: 在当地的记忆里。
&gt;&gt; Will Sentance: In the local memory.

50
00:02:21.639 --> 00:02:22.659
我们能找到柜台吗？
Do we find counter?

51
00:02:22.659 --> 00:02:23.840
托德: 没有 威尔 · 森塔斯: 我们不知道。
&gt;&gt; Todd: No.
&gt;&gt; Will Sentance: We don't.

52
00:02:23.840 --> 00:02:26.099
陶德，我们接下来去哪里？
Todd, where do we go and look out to next?

53
00:02:26.099 --> 00:02:27.575
托德: 背包 威尔 · 森特斯: 放进背包,
&gt;&gt; Todd: Backpack.
&gt;&gt; Will Sentance: Into the backpack,

54
00:02:27.575 --> 00:02:28.420
他说对了。
he's spot on.

55
00:02:28.420 --> 00:02:30.759
我们来看看 myNewFunction 的定义,
We go look at myNewFunction's definition,

56
00:02:30.759 --> 00:02:35.020
我们看看它和永久储存的数据，背包之间的联系。
we look at the little connection to its
permanent stored data, the backpack.

57
00:02:35.020 --> 00:02:36.001
然后我们就去了。
And off we go to it.

58
00:02:41.162 --> 00:02:42.957
托德: (笑)威尔 · 森塔斯: 就是这样，而且
&gt;&gt; Todd: [LAUGH]
&gt;&gt; Will Sentance: There it is and

59
00:02:42.957 --> 00:02:44.409
进去吧。
in we go.

60
00:02:44.409 --> 00:02:49.199
我们过去常常这样，我们去，它是一，我们做什么？
We used to be that bit up in the and in we
go and it's one and we do what with it?

61
00:02:49.199 --> 00:02:55.099
我们把它增加到，看看那个人。
We increment it to, to look at that folk.

62
00:02:55.099 --> 00:02:58.699
第一次，我们的函数 myNewFunction,
For the very first time,
our function myNewFunction,

63
00:02:58.699 --> 00:03:03.509
一个函数定义不只是有它的本地内存，逐字逐句地得到我应该
a function definition doesn't just have it
local memory that gets literally I should

64
00:03:03.509 --> 00:03:08.599
真的做到了这一点，真的做到了，每次都被删除。
have actually done this,
literally gets right, deleted each time.

65
00:03:08.599 --> 00:03:12.099
我们现在不仅有暂时的局部记忆,
We now have not only
the temporary local memory,

66
00:03:12.099 --> 00:03:15.979
如果我们不把存储全球的东西还回去，它就永远消失了。
that if we don't return something out
in storing global, it's gone forever.

67
00:03:15.979 --> 00:03:18.479
我们也有一个非常明确的定义,
We also have the very
definition the label,

68
00:03:18.479 --> 00:03:23.069
功能存储器附加了一个永久存储器。
the function storage has attached
to it a permanent memory.

69
00:03:23.069 --> 00:03:24.840
这真是不可思议。
That is remarkable.

70
00:03:24.840 --> 00:03:28.474
也就是说，这个标签不再只是一个函数的代码保存,
That is a say no longer is this a label
for just a function from code saved,

71
00:03:28.474 --> 00:03:32.400
这是关闭基金的标签，还有一些永久存储的数据。
it's a label for funds in closing and
some permanent store data attached.

72
00:03:33.860 --> 00:03:37.819
真的非常非常，这是所有 JavaScript 中最优雅的特性。
Genuinely very very, this is the most
elegant feature of all of JavaScript.

73
00:03:37.819 --> 00:03:41.370
优雅的意思是，我知道那是什么意思，有点像有趣的,
Elegant meaning like, I know what that
means it was sort of like interesting,

74
00:03:41.370 --> 00:03:45.590
有趣而且令人惊讶的，精心制作的功能。
intriguing and surprisingly
kind of nicely crafted feature.

75
00:03:45.590 --> 00:03:47.090
这就是我所说的优雅。
And that's what I mean by elegant.

76
00:03:47.090 --> 00:03:47.659
我喜欢用这个词,
I like using that word,

77
00:03:47.659 --> 00:03:50.789
人们不知道自己在说什么的时候，就会这么说。
that's one of those words people use
when they don't know what they mean.

78
00:03:50.789 --> 00:03:52.319
掩饰自己不知道它们的意思。
To mask not knowing what they mean.

79
00:03:52.319 --> 00:03:54.659
他们不知道为什么他们认为这是好的，他们觉得这是优雅的。
They're not sure why they think it's good,
and they're like that's elegant.

80
00:03:55.680 --> 00:04:00.330
那么，让我们开始讨论一些注意事项,
So, let's start talking about
some caveats around this,

81
00:04:00.330 --> 00:04:02.409
包括我们称之为。
including what do we call this.

82
00:04:02.409 --> 00:04:07.449
首先我想说的是，函数是如何抓取的
The first bit I want to talk about though
is, how does the function get to grab

83
00:04:07.449 --> 00:04:11.759
然后用函数定义返回？
onto what it surrounding data and return
it out with the function definition?

84
00:04:11.759 --> 00:04:13.460
这是什么？
What is like this?

85
00:04:13.460 --> 00:04:17.310
一旦，我甚至没有足够的空间来容纳这个，但是
As soon as,
I never quite even have room for this, but

86
00:04:17.310 --> 00:04:21.000
一旦我们声明增量计数器。
as soon as we declare increment counter.

87
00:04:21.000 --> 00:04:24.379
这实际上是存储在计算机的内存中，存储在计算机存储中
That is literally saving in the computer's
memory, in the computer store

88
00:04:24.379 --> 00:04:28.089
函数和数据，一个标签，还有函数的代码。
of functions and data, a label, and
the code of the function kinda plus plus.

89
00:04:28.089 --> 00:04:29.759
这就是现在的情况。
That's what this is here.

90
00:04:29.759 --> 00:04:33.439
在引擎盖下，如果您有一个控制台日志，将看到函数定义。
Under the hood, if you had a console log
that would see the function definition.

91
00:04:33.439 --> 00:04:37.060
根据控制台的复杂程度，我们可以看到它的整个代码，或者
Depending on how sophisticated a console
is, we'd see the whole code of it, or

92
00:04:37.060 --> 00:04:39.459
在更传统的控制台上，你可能会看到类似的功能。
in more traditional console,
you'd might see like function.

93
00:04:41.189 --> 00:04:47.100
在后台，在 JavaScript 中，会立即得到一个隐藏属性。
That behind the scenes, in JavaScript,
immediately gets a hidden property.

94
00:04:47.100 --> 00:04:49.730
当它们有小方括号时，你总是知道它们是隐藏属性
You always know they're hidden properties
when they have little square brackets

95
00:04:49.730 --> 00:04:52.790
之前和之后，在规范中，在 JavaScript 的规则中。
before and after them, in the spec,
in the rules of JavaScript.

96
00:04:52.790 --> 00:04:56.639
它得到一个隐藏属性，方括号，方括号,
It gets a hidden property,
square bracket, square bracket,

97
00:04:56.639 --> 00:04:59.029
也就是说这里有隐藏的财产。
that means there's a hidden property.

98
00:04:59.029 --> 00:05:02.769
范围方括号方括号,
Scope, square bracket, square bracket,

99
00:05:02.769 --> 00:05:09.480
它是一个隐藏属性，链接到所有周围数据存储的地方。
it is a hidden property that links to
where all this surrounding data is stored.

100
00:05:09.480 --> 00:05:11.800
它提供了一个与周围所有数据的链接。
It gives a little link to
all that surrounding data.

101
00:05:12.810 --> 00:05:16.550
意思是当我返回那个函数时，增量计数器
Meaning when I return that function out,
increment counter

102
00:05:16.550 --> 00:05:21.420
我的新功能，你打赌它带来了它的隐藏属性和
out of out of into my NewFunction,
you bet it brings it's hidden property and

103
00:05:21.420 --> 00:05:27.055
通过隐藏的方括号获取数据,
pulls that data with it through
its hidden square bracket,

104
00:05:27.055 --> 00:05:32.420
方括号，范围，性质。
square bracket, scope, property.

105
00:05:32.420 --> 00:05:36.800
当我们给这个函数贴上新的全局标签时，它还是附着着的,
It's still attached when we give
that function its new global label,

106
00:05:36.800 --> 00:05:38.189
我的新功能。
my new function.

107
00:05:38.189 --> 00:05:42.110
当我运行在本地内存计数器中找不到的新函数时,
And when I run my new function I don't
find in the local memory counter,

108
00:05:42.110 --> 00:05:44.000
算是介入吧。
it kind of intercedes.

109
00:05:44.000 --> 00:05:50.879
在我们去环球旅行之前，它被困在了路上，因为环球旅行会先检查我们的背包。
It gets stuck in the way before we go out
to global, which first check the backpack.

110
00:05:50.879 --> 00:05:54.990
这就是我们看到我们的计数器存放的地方，它不会去任何地方。
And that's where we see our counter is
stored and it ain't going anywhere.

111
00:05:54.990 --> 00:05:57.290
它不像执行上下文临时内存。
It's not like an execution
context temporary memory.

112
00:05:57.290 --> 00:06:00.810
只要函数定义没有被覆盖，它就是永久的,
It's permanent as long as its function
definitions they're not overwritten,

113
00:06:00.810 --> 00:06:02.889
这个一直留在那里，一直都在。
this stuck around,
is still there permanently.

114
00:06:03.980 --> 00:06:10.269
但是除了运行这个函数之外，我们不能以任何其他方式访问它
We can't get access to it though in any
other way besides running this function

115
00:06:10.269 --> 00:06:14.290
希望代码是这样写的，当它被定义，当它出生,
and hoping the code was written in such
a way when it was defined, when was born,

116
00:06:14.290 --> 00:06:18.139
最初被保存，它寻找一些本地记忆，它不在那里。
was initially saved, that it looks for
something a local memory, it ain't there.

117
00:06:18.139 --> 00:06:20.639
它指的不是局部的记忆。
It refers to something
is not a local memory.

118
00:06:20.639 --> 00:06:24.930
然后它出去，并查看范围属性进入背包。
Then it goes out and looks on
the scope property into the backpack.

119
00:06:24.930 --> 00:06:28.329
当我们保存这个函数的时候，有一些东西被拿出来了
And there was something from when we save
that function that's being pulled out

120
00:06:28.329 --> 00:06:29.240
在背包里。
in the backpack.

121
00:06:29.240 --> 00:06:30.829
我们不能这样做，这是不允许的。
We cannot do this, this is not allowed.

122
00:06:30.829 --> 00:06:36.389
没有比 MyNewFunction.backpack.counter 更好的了。
There's no like
MyNewFunction.backpack.counter.

123
00:06:36.389 --> 00:06:38.139
这不是说我们不能通过这种方式获得它。
That is not we can't get
access to it that way.

124
00:06:38.139 --> 00:06:41.120
我们甚至不能使用我的新功能。
We can't go MyNewFunction even.scope.

125
00:06:41.120 --> 00:06:42.870
这是一个隐藏属性，我们不能访问它。
This is a hidden property,
we can't access it.

126
00:06:42.870 --> 00:06:47.329
它就在那里，在幕后，但我们甚至不能使用 myNewFunction.scope.counter。
It's ther, behind the scenes, but we can't
even go myNewFunction.scope.counter.

127
00:06:47.329 --> 00:06:50.449
获取数据的唯一方法是运行这个函数,
The only way to get to that data
is by running this function,

128
00:06:50.449 --> 00:06:53.840
在当地的记忆中，它指的是一些不存在的东西
having it refer to something not in
local memory of it, and going out to

129
00:06:53.840 --> 00:06:57.389
这个函数的定义就是在它的背包里找到计数器。
the function's definition looking in
its backpack and finding counter there.

130
00:06:59.129 --> 00:07:02.420
绝对是一个非常非常特别的功能。
Absolutely a very, very special feature.

131
00:07:02.420 --> 00:07:08.509
我们现在有了永久的，但是顺便说一下，我们称之为私人数据。
We now have permanent, but also by
the way, let's call it private data.

132
00:07:08.509 --> 00:07:11.879
除了运行我们创建的函数之外，没有其他人可以访问它
No one else can access it besides by
running the function that we created to

133
00:07:11.879 --> 00:07:14.310
在我们的应用程序里找到它。
get access to it in our application.

134
00:07:14.310 --> 00:07:19.019
你知道吗，事实上我现在不想再多说什么了
And you know what, I'm actually gonna save
for now any further words on this besides

135
00:07:19.019 --> 00:07:23.220
说，只是想想，如果我现在有一个函数有一个永久的记忆,
to say, just be thinking, if I have a
function now that has a permanent memory,

136
00:07:23.220 --> 00:07:24.550
想想我能做些什么。
think what sort of things I can do.

137
00:07:24.550 --> 00:07:27.129
我不会谈论我们能做的所有事情
I won't talk about all
the things we can do, but for

138
00:07:27.129 --> 00:07:30.750
只是一个提示，我可以有这个函数的第二次运行,
just a hint, I can have this
function the second time it runs,

139
00:07:30.750 --> 00:07:35.029
检查如果计数器是一，假设我增加它第一次。
check if counter is one,
suppose I increment it first time.

140
00:07:35.029 --> 00:07:40.800
如果柜台是一个然后返回，对不起，你不能运行我超过一次。
If counter is one then return, sorry,
you can't run me more than once.

141
00:07:40.800 --> 00:07:44.572
也就是说，这个函数通过它的永久内存来记住以前的运行。
That is to say this function remembers the
previous running via its permanent memory.
