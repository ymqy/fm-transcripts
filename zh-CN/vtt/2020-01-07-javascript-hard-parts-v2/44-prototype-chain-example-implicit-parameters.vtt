WEBVTT

1
00:00:00.056 --> 00:00:02.355
威尔 · 森特斯: 伊森会的，因为它会传到更远的地方给伊森。
&gt;&gt; Will Sentance: Ethan's gonna because
it's gonna down further over to Ethan.

2
00:00:02.355 --> 00:00:04.911
Ethan: 所以用户函数存储一个对象，但是
&gt;&gt; Ethan: So
user function stores an object but

3
00:00:04.911 --> 00:00:08.798
它可以包含除了函数以外的任何东西，对吗？
it can contain anything other
than functions to right?

4
00:00:08.798 --> 00:00:10.762
威尔 · 森特斯: 是的，当然，当然。
&gt;&gt; Will Sentance: Yeah,
absolutely, absolutely.

5
00:00:10.762 --> 00:00:12.973
伊森: 你也会用同样的方式引用它。
&gt;&gt; Ethan: And
you'd reference it the same way.

6
00:00:12.973 --> 00:00:18.239
威尔 · 森特斯: 是的，是的，顺便说一下，我们一会儿见
&gt;&gt; Will Sentance: Yeah, yeah,
it also by the way, we'll see you later

7
00:00:18.239 --> 00:00:23.678
可能还有一个隐藏的原型财产。
on may also have a hidden
proto property on it as well.

8
00:00:23.678 --> 00:00:25.272
我的天啊，是后来的伊森，继续。
My goodness,
it was the later on Ethan go ahead.

9
00:00:25.272 --> 00:00:30.939
伊森: 所以 object.create 接受的论点是,
&gt;&gt; Ethan: So the argument that
object.create accepts is that the,

10
00:00:30.939 --> 00:00:33.747
一直都是原型吗？
that is always the Proto?

11
00:00:33.747 --> 00:00:36.344
威尔 · 森塔斯: 首先，在原始文学中，人们总是认为。
&gt;&gt; Will Sentance: Well first that
is always thought in the Proto.

12
00:00:36.344 --> 00:00:38.792
说得好，谢谢。
Yeah, very well put, thank you.

13
00:00:38.792 --> 00:00:39.844
你想继续调查吗？
You want to follow up on that?

14
00:00:39.844 --> 00:00:43.624
伊森: 没有，只是澄清一下。
&gt;&gt; Ethan: No, just clarifying.

15
00:00:43.624 --> 00:00:44.531
威尔 · 森坦斯: 是的，这是一个很好的澄清问题。
&gt;&gt; Will Sentance: Yeah,
that's a great clarification question.

16
00:00:44.531 --> 00:00:47.320
换句话说。
Putting it another way.

17
00:00:50.685 --> 00:00:53.588
伊森: 我现在不是在引用 MDN，而是在问你。
&gt;&gt; Ethan: Instead of referencing MDN
at this moment, I'm just ask you.

18
00:00:53.588 --> 00:00:56.274
[ LAUGH }威尔 · 森塔斯: 这是事实,
[LAUGH}
&gt;&gt; Will Sentance: It's a true fact,

19
00:00:56.274 --> 00:00:59.805
create 创建一个带有隐藏 proto 属性的空对象。
object.create creates an empty
object with a hidden proto property.

20
00:00:59.805 --> 00:01:04.942
现在，我要说的是，这个属性不像我们的词法范围属性那样隐藏。
Now, I will say this, that property is not
as hidden as our Lexical scope property.

21
00:01:04.942 --> 00:01:07.959
那个你看不到，或者是我们自己的实现数组。
That one you can't see, or
our own fulfilled array.

22
00:01:07.959 --> 00:01:09.963
由于某种原因，没有任何控制台显示这一点。
No console shows that for some reason.

23
00:01:09.963 --> 00:01:15.557
这个隐藏属性如果你在 Chrome Dev 工具中控制台日志用户1,
This hidden property if you in the Chrome
Dev tools were to console log user1,

24
00:01:15.557 --> 00:01:20.237
你会在 Chrome 开发工具控制台上看到一个小小的向下箭头。
you'd see the little down arrow
in the Chrome Dev tools console.

25
00:01:20.237 --> 00:01:22.680
如果你点击它，你会看到这个原型属性和
If you click that,
you'd see this proto property and

26
00:01:22.680 --> 00:01:24.099
用户功能存储的链接。
a link to user function store.

27
00:01:24.099 --> 00:01:27.781
所以这是一个隐藏的，但你可以看到它。
So this is one that's hidden but
you can see it.

28
00:01:27.781 --> 00:01:29.370
是的，继续，继续。
Yeah, more, go ahead.

29
00:01:29.370 --> 00:01:33.697
伊森: 所以技术上来说，这是不赞成的，但是你可以使用。 我认为 getPrototype,
&gt;&gt; Ethan: So technically it's deprecated
but you can use .getPrototype of I think,

30
00:01:33.697 --> 00:01:36.950
这是一种新的办法，实际上得到它正式。
which is a new method of
actually getting it officially.

31
00:01:36.950 --> 00:01:37.844
威尔 · 森塔斯: 太好了。
&gt;&gt; Will Sentance: Excellent.

32
00:01:37.844 --> 00:01:42.671
伊森: 但是浏览器的书呆子们可能是因为它是原始的
&gt;&gt; Ethan: But the browser wonks
probably move __proto because it's

33
00:01:42.671 --> 00:01:44.854
有点像内置的永久。
kinda built-in forever.

34
00:01:44.854 --> 00:01:50.127
Will Sentance: 太好了，我们保持了 JavaScript 历史的一致性。
&gt;&gt; Will Sentance: Perfect, we maintain the
consistency of the history of JavaScript.

35
00:01:50.127 --> 00:01:52.748
非常好，一直都在工作。
Excellent, always working with it.

36
00:01:52.748 --> 00:01:58.927
好了，各位，我们现在,
All right, people, so let's now,

37
00:01:58.927 --> 00:02:05.108
是啊，我们现在就去吧
yeah, let's now actually go ahead and

38
00:02:05.108 --> 00:02:09.621
运行增量方法。
run that increment method.

39
00:02:09.621 --> 00:02:12.271
这是我的执行环境，我已经准备好了。
There's my execution context,
I'm ready to go.

40
00:02:12.271 --> 00:02:15.402
让我们一如既往地说清楚,
Let' just be really clear, as always,

41
00:02:15.402 --> 00:02:20.019
这个执行上下文消失了，从代码中弹出。
this execution context is gone,
popped off the code side.

42
00:02:20.019 --> 00:02:21.335
让我们进入并运行 increment。
Let's go in and run increment.

43
00:02:21.335 --> 00:02:23.628
本地内存是常见的。
Local memory is usual.

44
00:02:23.628 --> 00:02:24.663
我们就把它放在那儿吧。
Let's just put it there.

45
00:02:24.663 --> 00:02:29.685
我想问一些事情，增量代码，我们可以看到我
I want to ask something,
increments code we can see I

46
00:02:29.685 --> 00:02:35.292
把它放在一行里但是 Braden 它的代码是什么？
put it in one line there, but,
Braden, what is its code?

47
00:02:35.292 --> 00:02:37.370
只要给我准确的话，我有时候会要求的话
Just give me the exact words,
what I've sometimes asked for

48
00:02:37.370 --> 00:02:38.680
用精确的词语来描述，对吗？
to relate in the exact words, right?

49
00:02:38.680 --> 00:02:39.477
它的代码是什么？
What is its code?

50
00:02:39.477 --> 00:02:40.950
布雷登: This.score + + 。
&gt;&gt; Braydon: This.score ++.

51
00:02:40.950 --> 00:02:45.271
威尔 · 森特斯: This.scorel + 。
&gt;&gt; Will Sentance: This.scorel++.

52
00:02:45.271 --> 00:02:51.647
问题是，这个递增函数不需要在用户1上运行,
Here's the problem, this increment
function doesn't need to work on user 1,

53
00:02:51.647 --> 00:02:57.288
不需要在用户2上工作，不需要在用户403上工作。
doesn't need to work on user 2,
doesn't need to work on user 403.

54
00:02:57.288 --> 00:02:58.709
没错。
Yeah, exactly.

55
00:02:58.709 --> 00:02:59.923
所有人。
All of them.

56
00:02:59.923 --> 00:03:03.319
所以这个增量方法。
So this increment method.

57
00:03:03.319 --> 00:03:06.123
我想如果我想在 user1上工作，在 user1里面,
I guess if I wanted to work on user1,
inside of it,

58
00:03:06.123 --> 00:03:08.818
我需要写 user1.score + + 。
I'm going to need to write user1.score ++.

59
00:03:08.818 --> 00:03:14.070
这样他们就可以去找我们，找到学校的财产并实施它。
So that they can go and look for us one
find the school property and implement it.

60
00:03:14.070 --> 00:03:18.521
但是问题是当时运行 user2.increment 和
But then the problem is by then
run it user2.increment and

61
00:03:18.521 --> 00:03:23.153
1.score + + .
inside running inside of
increment ran user1.score++.

62
00:03:23.153 --> 00:03:30.908
所以我需要这个方法使这个函数在 user1或 user1上工作
So I need this method this
function to be working on user1 or

63
00:03:30.908 --> 00:03:35.260
User2or user4 or user405.
user2or user4 or user405.

64
00:03:35.260 --> 00:03:40.230
不要惊慌，我有一个惊人的东西。
Don't panic, I have an amazing thing.

65
00:03:40.230 --> 00:03:42.275
我在当地的记忆中太渺小了。
I'm in my local memory too small with me.

66
00:03:42.275 --> 00:03:45.110
我有一个神奇的东西叫做隐含参数。
I've an amazing thing called
an implicit parameter.

67
00:03:45.110 --> 00:03:47.159
这意味着一个，我甚至没有指定。
That means one, I don't even specify.

68
00:03:47.159 --> 00:03:51.918
这是一个自动存在并自动填补我的空白。
It's one that's automatically there and
automatically filled in for me.

69
00:03:51.918 --> 00:03:53.871
它叫做这个。
And it's called this.

70
00:03:53.871 --> 00:03:58.722
一旦我开始在本地内存中运行这个方法,
As soon as I start running this
method increment in my local memory,

71
00:03:58.722 --> 00:04:00.175
你知道我得到了什么吗？
you know what I get?

72
00:04:00.175 --> 00:04:04.022
不需要自动解析视图,
Without parsing the view
just automatically,

73
00:04:04.022 --> 00:04:07.492
我得到一个隐式参数占位符。
I get an implicit parameter placeholder.

74
00:04:07.492 --> 00:04:12.239
隐含的意思是我没有写它，它在那里等着我，这个，还有
Implicit meaning I didn't write it,
it's there for me, this and

75
00:04:12.239 --> 00:04:17.266
你觉得它会自动分配给它什么呢 Todd？
what do you think it's gonna have
automatically assigned to it Todd?

76
00:04:17.266 --> 00:04:17.877
用户1。
&gt;&gt; Todd: User1.

77
00:04:17.877 --> 00:04:20.970
威尔 · 森特斯: 用户1，不管那个点左边是什么,
&gt;&gt; Will Sentance: User1, whatever is
to the left hand side of that dot,

78
00:04:20.970 --> 00:04:23.740
重要的是在那个物体上运行。
that matters being run on that,
on that object.

79
00:04:23.740 --> 00:04:29.690
不管左边是什么对象，都会有 User1。
Whatever object's on left hand side,
there will be User1.

80
00:04:29.690 --> 00:04:34.158
事实上所有函数和全局自动然而这个但是
In fact all functions and
global automatically however this but

81
00:04:34.158 --> 00:04:38.956
除了我们今天要看的其他几个有趣的案子
besides a couple of other interesting
cases we're going to see today

82
00:04:38.956 --> 00:04:42.031
总是有人在谈论这件事。
that this is always there
is a talk about it.

83
00:04:42.031 --> 00:04:43.937
在用户创建中我们有这个，但是
In user creates we had of this, but

84
00:04:43.937 --> 00:04:46.713
它指的是一些不太有用的东西。
it referred to something
that was not too useful.

85
00:04:46.713 --> 00:04:50.622
这是 JavaScript 窗口中一个有趣的全局对象概念
This is a funny global object
concept in JavaScript window or

86
00:04:50.622 --> 00:04:53.774
全局对象，你可能见过一两次。
global object you may have seen it once or
twice.

87
00:04:53.774 --> 00:04:57.353
所以如果我们试着在用户创建者内部使用它,
And so if we were to try and
use this, inside a user creator,

88
00:04:57.353 --> 00:05:00.658
我们会指向一些有趣的全局对象。
we'd be pointing off some
funny global object thing.

89
00:05:00.658 --> 00:05:03.598
某种随机的小东西。
Some sort of random little object thing.

90
00:05:03.598 --> 00:05:11.088
它没有多少用处，但是当它是一个函数增量时,
It wouldn't have not much use, but
when instead it's a function increment,

91
00:05:11.088 --> 00:05:16.430
因此调用用户1或用户2对象。
thus being called upon the user 1 or
the user 2 object.

92
00:05:16.430 --> 00:05:22.461
但是因此需要对每个对象都是通用的，可重用的。
But therefore needs to be general,
reusable on each of these objects.

93
00:05:22.461 --> 00:05:24.634
谢天谢地，我们有了这个隐含的参数。
Thank goodness we have
this implicit parameter.

94
00:05:24.634 --> 00:05:30.154
这个小小的占位器，这是我们的一个关键规则，它总是连着它自己
This little place holder, here's our one
key rule, it always attaches to itself

95
00:05:30.154 --> 00:05:35.439
对象的左手边的点，这个函数正在运行。
the object to the left hand side of the
dots on which that function is being run.

96
00:05:35.439 --> 00:05:40.463
那么这个. score + Todd，计算变成了什么？
So what does this .score++ Todd,
evaluate to turn into?

97
00:05:40.463 --> 00:05:41.983
1.score + + .
&gt;&gt; Todd: User1.score++.

98
00:05:41.983 --> 00:05:43.509
威尔 · 森特斯: 干得好，托德。
&gt;&gt; Will Sentance: Very nice one, Todd.

99
00:05:43.509 --> 00:05:49.800
1.score + + .
Use1.score++.

100
00:05:49.800 --> 00:05:54.588
用户1不在本地内存中，我们前往全局，它在那里。
User 1 not in local memory,
we head out to global, there it is.

101
00:05:54.588 --> 00:05:59.009
得分，增加到4。
Score, increment it to 4.

102
00:05:59.009 --> 00:06:03.199
漂亮，是的。
Beautiful, yeah.

103
00:06:03.199 --> 00:06:05.466
老乡们，我们将会看到这个的另一个主要用途。
Folk, we're gonna see
another major use of this.

104
00:06:05.466 --> 00:06:11.283
关键词，又来了，每次都有一个主要用户在一瞬间。
Keyword, there we go,
every time another major user in a moment.

105
00:06:11.283 --> 00:06:15.918
但是现在这是我们的关键用途，运行一个共享或者
But for now this is our key use,
run a function that shared or

106
00:06:15.918 --> 00:06:21.593
可以通过原始链接对许多不同的对象使用。
going to be available to many different
objects through the proto link.

107
00:06:21.593 --> 00:06:26.350
并且确保我们用关键字 this 来写它，以访问对象
And make sure we write it with the keyword
this to access the object on which that

108
00:06:26.350 --> 00:06:31.055
方法，那个函数被执行到点的右边。
method, that function is being executed
to the right-hand side of the dot.

109
00:06:31.055 --> 00:06:33.600
对这些人竖起大拇指。
Thumbs on this people.

110
00:06:38.071 --> 00:06:38.730
威尔 · 森特斯: 是的，杰森。
&gt;&gt; Will Sentance: Yeah, Jason.

111
00:06:38.730 --> 00:06:40.129
我们去找马克。
We'll go to Mark.

112
00:06:40.129 --> 00:06:40.963
先是杰森，然后是马克。
Jason first, then Mark.

113
00:06:40.963 --> 00:06:41.678
说吧，杰森。
Go ahead, Jason.

114
00:06:41.678 --> 00:06:48.531
杰森: 当这个操作符运行时，我们是否显式地使用名称空间,
&gt;&gt; Jason: Are we explicitly working with
namespaces when this operator is in play,

115
00:06:48.531 --> 00:06:55.728
因为要找到我们的价值，就必须去寻找范围的要求。
because of the scoping requirements where
it has to go look to find our value.

116
00:06:55.728 --> 00:07:00.677
威尔 · 森特斯: 我们都完全知道这里面是什么
&gt;&gt; Will Sentance: We all absolutely
knowing that the this inside of here is

117
00:07:00.677 --> 00:07:05.644
只有在这个执行上下文中。
related to,
it is only within this execution context.

118
00:07:05.644 --> 00:07:09.187
不过，这是从哪里来的呢？
Where is the this coming from though?

119
00:07:09.187 --> 00:07:14.987
我们马上就会看到，我们可以用一些有趣的方式来玩它。
We'll see in just a moment that we can
play with it in some interesting ways.

120
00:07:14.987 --> 00:07:16.817
马克，我们一会儿就知道了？
We'll see in a moment, Mark?

121
00:07:16.817 --> 00:07:19.596
这是本地执行上下文吗？
&gt;&gt; Mark: Is this local execution context?

122
00:07:19.596 --> 00:07:21.329
我们正在明确地讨论这个问题。
We're explicitly talking about this.

123
00:07:21.329 --> 00:07:24.786
但它正在访问全局内存中的分数，或者
But it's accessing score
up in global memory, or

124
00:07:24.786 --> 00:07:30.074
不用返回值就可以改变它，这是我们传统的做法。
changing it without say a return value,
which we've done traditionally.

125
00:07:30.074 --> 00:07:33.797
威尔 · 森特斯: 当然，所以你是说这可能像一个,
&gt;&gt; Will Sentance: Sure, so
you're saying this might be like a,

126
00:07:33.797 --> 00:07:38.957
你对这种副作用很谨慎。
you're cautious about this as
a sort of side effect type thing.

127
00:07:38.957 --> 00:07:41.694
是的，绝对的，绝对的，这就是为什么，但是
Yeah, absolutely, absolutely,
and that's why, but

128
00:07:41.694 --> 00:07:43.807
这是这个型号的标准配置。
it's totally standard within this model.

129
00:07:43.807 --> 00:07:45.812
这并不是天生的问题。
And it's not inherently problematic.

130
00:07:45.812 --> 00:07:49.834
但这就是为什么我们必须接受如果我们采用这种模式,
But it is why we have to accept that,
if we're taking this model,

131
00:07:49.834 --> 00:07:53.365
如果我们要组织代码，就要权衡利弊。
if we're organizing our code,
there's trade-offs.

132
00:07:53.365 --> 00:07:55.807
巨大的好处，我的数据或我的功能或
Huge benefit, my data or
my functionality or

133
00:07:55.807 --> 00:07:59.231
这个功能捆绑在一个地方的可用性。
the availability of that
functionality bundled in one place.

134
00:07:59.231 --> 00:08:03.747
问题是，在功能方面，它可能在我的代码中的任何地方产生影响
Problem, around the functionality, it can
have consequences anywhere in my code

135
00:08:03.747 --> 00:08:07.759
但是，理想情况下，只有在我试图瞄准的目标物体内部。
base, ideally, though, only within
the object I'm trying to target.

136
00:08:07.759 --> 00:08:12.579
但是，维护这种代码库肯定会有起伏。
But maintaining this sort of code base
can be definitely have its ups and downs.

137
00:08:12.579 --> 00:08:14.220
马克问得很好。
Very fair question from Mark.
