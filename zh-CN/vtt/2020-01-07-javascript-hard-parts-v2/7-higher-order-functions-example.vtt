WEBVTT

1
00:00:00.000 --> 00:00:01.480
威尔 · 森特斯: 同志们，让我们一起走过这个但是
&gt;&gt; Will Sentance: People,
let's walk through this but

2
00:00:01.480 --> 00:00:07.309
我已经感觉到这可能使我们的代码更加可重用,
I can already feel that this may be
making our code profoundly more reusable,

3
00:00:07.309 --> 00:00:12.060
想一想，除了倍增 by2之外，还有什么可以传递给它呢？
have a think, whatever else I could
pass to this besides multiplyBy2?

4
00:00:12.060 --> 00:00:13.939
好了，开始了，伙计们。
All right, here we go, people.

5
00:00:13.939 --> 00:00:15.480
1号线，我们在做什么，我的朋友，在这里？
Line 1, what are we doing,
my friend, here?

6
00:00:15.480 --> 00:00:17.730
演讲者2: 我们正在定义函数，copyArrayAndManipulate？
&gt;&gt; Speaker 2: We're defining the function,
copyArrayAndManipulate?

7
00:00:17.730 --> 00:00:23.649
威尔 · 森塔斯: 这是绝对正确的，让我们把它变得美丽
&gt;&gt; Will Sentance: That's absolutely
correct, let's just get that beautiful so

8
00:00:23.649 --> 00:00:28.160
定义，奇妙的 copyArray 和
definition, fantastic copyArray and

9
00:00:29.179 --> 00:00:34.770
在那里，它被保存在全局内存中。
manipulate, there it is
saved in global memory.

10
00:00:34.770 --> 00:00:38.149
现在注意，当它运行时接受两个输入,
Note now,
takes in two inputs when it gets run,

11
00:00:38.149 --> 00:00:42.250
一个数组和一些实际的代码，是不是很疯狂？
both an array and some actual code,
isn't that crazy?

12
00:00:42.250 --> 00:00:46.200
好吧，下一行，马特，我们接下来节省什么？
All right say, next line Matt,
what are we saving next?

13
00:00:46.200 --> 00:00:49.530
演讲者2: 我们要在全局内存中定义，乘法 by2函数。
&gt;&gt; Speaker 2: We're gonna define in the
global memory, the multiplyBy2 function.

14
00:00:49.530 --> 00:00:52.740
威尔 · 森特斯: 漂亮，就是这个，multplyBy2，小婴儿功能,
&gt;&gt; Will Sentance: Beautiful, there it is,
multplyBy2, little baby function,

15
00:00:54.020 --> 00:00:57.579
这时候我要采取希望的数字和
that is when run I'm gonna
take hopefully a number and

16
00:00:57.579 --> 00:01:00.088
把这个数字输出到2我们希望它能这样。
return out that number by 2,
that's what we hope it does.

17
00:01:01.509 --> 00:01:03.780
下一行是伊森的左手边。
Next line over to Ethan left hand side.

18
00:01:03.780 --> 00:01:07.930
伊森: 我们在定义最常见的结果，然后
&gt;&gt; Ethan: We're defining the const result,
which then

19
00:01:09.250 --> 00:01:13.230
调用数组 copyArrayAndManipulate。
calling the array copyArrayAndManipulate.

20
00:01:13.230 --> 00:01:19.739
威尔 · 森特斯: 是的，所以我们必须去调用 copyarrayremanage。
&gt;&gt; Will Sentance: Yeah, so we've got
to go and call copyArrayManipulate.

21
00:01:19.739 --> 00:01:22.519
希望我们这里有足够的空间，因为这是我写的，亲爱的。
Hopefully we've got enough room here,
because I wrote this in, dear.

22
00:01:22.519 --> 00:01:28.569
第一个输入是数组1,2,3,
CopyArrayManipulate with the first
input being the array 1,2,3,

23
00:01:28.569 --> 00:01:32.670
伊森，你怎么形容我们经过的第二个东西？
and Ethan, how do you describe
the second thing we're passing in there?

24
00:01:32.670 --> 00:01:36.150
伊森: 这是一个被乘法的函数。
&gt;&gt; Ethan: It is the function multiplyBy2.

25
00:01:36.150 --> 00:01:40.520
威尔 · 森坦斯: 是的，这是整个函数的定义,
&gt;&gt; Will Sentance: Yeah, it's
the entire function definitionnpeople,

26
00:01:40.520 --> 00:01:46.170
整个过程都是被抓住插进去的。
the whole thing is being grabbed and
inserted in.

27
00:01:46.170 --> 00:01:49.640
所以我们会看到，无论你在哪里看到指令这个词，它都是完整的
So we're gonna see that wherever you see
the word instruction it's gonna be fully

28
00:01:49.640 --> 00:01:52.200
被 multilyby2取代。
replaced by multiplyBy2.

29
00:01:52.200 --> 00:01:55.960
好了，大家，等等，等等。
Okay, so everybody, hold on, hold on.

30
00:01:55.960 --> 00:02:01.876
我知道我们唱了很多我最喜欢的歌,
I know we're doing enough
of my favorite chant,

31
00:02:01.876 --> 00:02:04.617
这是 Stack 的电话,
here's a call Stack,

32
00:02:04.617 --> 00:02:10.103
我们要加入 copyarrayray 和 manipulate,
we're gonna add copyArrayAndManipulate,

33
00:02:10.103 --> 00:02:15.169
就是这样，我们要创造。
there it is to it and we're gonna create.

34
00:02:15.169 --> 00:02:18.670
我会非常高兴，我们要创造一个全新的。
I'm gonna be very happy,
we're gonna create a brand new.

35
00:02:18.670 --> 00:02:21.039
执行上下文。
&gt;&gt; Ethan: Execution context.

36
00:02:21.039 --> 00:02:26.050
威尔 · 森特斯: 美丽，那是一种光芒四射的声音，充沛的能量和
&gt;&gt; Will Sentance: Beautiful, that's
a radiant sound, abundant energy and

37
00:02:26.050 --> 00:02:27.319
从你的声音。
sound from your.

38
00:02:27.319 --> 00:02:29.680
好的，让我们创建它，它就在那里。
Alright, let’s create it, there it is.

39
00:02:29.680 --> 00:02:35.219
要运行 copyArrayAndManipulate,
To run copyArrayAndManipulate,

40
00:02:35.219 --> 00:02:42.096
我很难理解垂直的线条
I had very hard time
with vertical lines and

41
00:02:42.096 --> 00:02:46.110
进去，我们走，去哪？
into it, we go, where?

42
00:02:48.030 --> 00:02:51.250
我们的线程会编织进来然后开始运行 copyarrayray 和 manipulate,
Our thread's gonna weave in, and
start running copyArrayAndManipulate,

43
00:02:51.250 --> 00:02:52.139
我忘了什么，丹？
what did I forget, Dan?

44
00:02:52.139 --> 00:02:53.271
伊森: 全球在底部。
&gt;&gt; Ethan: Global at the bottom.

45
00:02:53.271 --> 00:02:56.310
威尔 · 森坦斯: 全球在底部，是的，完全正确。
&gt;&gt; Will Sentance: Global at the bottom,
yep, exactly.

46
00:02:56.310 --> 00:03:02.270
在那里，我们进入它，在我们的本地记忆，看看这支可爱的新钢笔。
There it is, and into it we go, and in our
Local Memory, look at this lovely new pen.

47
00:03:02.270 --> 00:03:05.020
在我们当地的记忆中，第一件事是什么？
In our local memory,
what is the first thing in there?

48
00:03:05.020 --> 00:03:07.895
后面的亚当，我们首先要插入的是什么
Adam at the back, what is the first
thing we're gonna stick in that

49
00:03:07.895 --> 00:03:12.400
操作，执行上下文，本地内存？
copyArrayAndManipulate, execution context,
local memory?

50
00:03:12.400 --> 00:03:14.000
Adam: 数组的参数。
&gt;&gt; Adam: The parameter of array.

51
00:03:14.000 --> 00:03:17.229
威尔 · 桑特斯: 是的，法布有什么指定的论点？
&gt;&gt; Will Sentance: Yeah,
Fab with what assigned argument?

52
00:03:17.229 --> 00:03:18.789
亚当: 数组1,2,3。
&gt;&gt; Adam: The array 1,2,3.

53
00:03:18.789 --> 00:03:19.800
威尔 · 森塔斯: 美丽而且
&gt;&gt; Will Sentance: Beautiful and

54
00:03:19.800 --> 00:03:22.819
有趣的是，下一个参数是什么？
now the interesting bit,
what's that next parameter?

55
00:03:23.860 --> 00:03:24.689
亚当: 说明？
&gt;&gt; Adam: Instructions?

56
00:03:24.689 --> 00:03:26.930
是的，布置什么？
&gt;&gt; Will Sentance: Yes, assign what?

57
00:03:26.930 --> 00:03:30.189
整个函数，multilyby2。
&gt;&gt; Adam: The entire function, multiplyBy2.

58
00:03:30.189 --> 00:03:34.599
威尔 · 森坦斯: 说得很好，但是如果我们不知道它叫什么呢？
&gt;&gt; Will Sentance: Very nicely put, but
what could it be called, if we don't know?

59
00:03:34.599 --> 00:03:36.599
确切地说，没有人知道。
Nobody knows, exactly.

60
00:03:36.599 --> 00:03:40.329
2，整个函数定义,
MultiplyBy2, the entire
function definition,

61
00:03:40.329 --> 00:03:43.920
在那里，它被存放在劳动说明书下。
there it is stored under
the labor instructions.

62
00:03:43.920 --> 00:03:48.805
如果我现在想在这个执行上下文中运行这个 multilyby2函数,
If I now want to run that multiplyBy2
function inside of this execution context,

63
00:03:48.805 --> 00:03:52.909
凯拉，我用什么劳动力来处理多个 by2函数？
Kayla what labor will I use for
the multiplyBy2 function?

64
00:03:52.909 --> 00:03:55.219
威尔 · 森特斯: 指示，她产卵了。
&gt;&gt; Kayla: Instructions
&gt;&gt; Will Sentance: Instructions, she spawn.

65
00:03:55.219 --> 00:03:58.384
所以我必须在这里写上乘法 by2,
So I would have to write in order
to execute multiplyBy2 inside here,

66
00:03:58.384 --> 00:03:59.969
我会写什么，凯拉？
I will write what, Kayla?

67
00:03:59.969 --> 00:04:01.879
指令然后是素数。
&gt;&gt; Kayla: Instructions and then primes.

68
00:04:01.879 --> 00:04:04.810
威尔 · 森塔斯: 太棒了，如果我想提供一个大概的论点
&gt;&gt; Will Sentance: Fantastic,
If I wanna provide presumably an argument

69
00:04:04.810 --> 00:04:07.758
因为它期待一个输入，我把像你知道，像指令。
because it's expecting an input,
I put like you know, be like instruction.

70
00:04:07.758 --> 00:04:11.802
我不想写它，因为我们要做一个完整的暂停和擦拭，但
I don't wanna write it because we got
to do a full pause and wipe down but

71
00:04:11.802 --> 00:04:15.713
我会按照指示做素数会运行多个 by2,
I'm gonna do it instructions,
primes is gonna run multiplyBy2,

72
00:04:15.713 --> 00:04:20.055
输入3会这样运行，这是真正的运行，凯拉。
input 3 is gonna run it like that,
that's really running, Kayla again.

73
00:04:20.055 --> 00:04:21.819
凯拉: 乘法-将句子: 乘法 by2
&gt;&gt; Kayla: MultiplyBy-
&gt;&gt; Will Sentance: MultiplyBy2

74
00:04:21.819 --> 00:04:23.259
只要输入三个，没错。
with the input of three, exactly.

75
00:04:23.259 --> 00:04:24.449
我犯了一个可怕的错误。
I made a horrible mistake here.

76
00:04:24.449 --> 00:04:32.819
所以如果你在 copyarraymanage 的代码中看到任何指令,
So if you see instructions anywhere
inside the code of copyArrayManipulate,

77
00:04:32.819 --> 00:04:34.975
知道吗，这真的让大家团结在一起，什么？
know that it's really running
everybody together what?

78
00:04:34.975 --> 00:04:37.029
2.
MultiplyBy2.

79
00:04:37.029 --> 00:04:40.199
优秀的美国执行得到了它没有，多倍的 by2，优秀。
Excellent us execution got it for
no, MultiplyBy2, excellent.

80
00:04:40.199 --> 00:04:43.819
好现在我们进入尸体交给马克,
Okay, now let's get into
the body to over to Mark,

81
00:04:43.819 --> 00:04:46.231
标记函数在身体里说的第一件事是什么？
Mark what's the first thing in
the body the function say to do?

82
00:04:46.231 --> 00:04:49.000
标记: 查找输出。
&gt;&gt; Mark: Find output.

83
00:04:49.000 --> 00:04:49.975
是的，然后我们就完成了？
Yeah, and then we'll complete?

84
00:04:49.975 --> 00:04:50.778
Will Sentance: 空数组。
&gt;&gt; Will Sentance: Empty array.

85
00:04:50.778 --> 00:04:53.240
空数组，是的，没错。
Empty array, well yeah, exactly.

86
00:04:53.240 --> 00:04:58.699
好，现在我们开始处理这个函数
Okay, now we're gonna start
working through this function and

87
00:04:58.699 --> 00:05:02.980
我知道我们正在接受这个，也许对某些人来说，这是一个耐心的节奏,
I know we're taking this, maybe for
some people and a patient pace,

88
00:05:02.980 --> 00:05:05.800
但我们要确保这里的一切都安全,
but we wanna really make sure
everything covered here,

89
00:05:05.800 --> 00:05:09.509
以一定的速度在中间，越来越难的东西，我们去。
at a measured pace in the middle to
a more and more hard stuff as we go.

90
00:05:09.509 --> 00:05:12.399
好了，这是输出空数组，数组1,2,3。
All right, there it is output empty array,
array 1,2,3.

91
00:05:12.399 --> 00:05:13.949
让我们进入那四个循环。
Let's get into that four loop.

92
00:05:15.529 --> 00:05:18.709
好了我们进入了四环的主体第一次进入的时候,
All right, we entered the body of the four
loop, the first time we entered it,

93
00:05:18.709 --> 00:05:21.480
丹，我的价值是什么？
Dan, I's value is what?

94
00:05:21.480 --> 00:05:23.899
是的，0，数组位置0是 Dan: 1。
Yeah, 0, array position 0 is
&gt;&gt; Dan: 1.

95
00:05:23.899 --> 00:05:27.504
威尔 · 森塔斯: 1，我们取1，我们要,
&gt;&gt; Will Sentance: 1,
we take the 1, and we're going to,

96
00:05:27.504 --> 00:05:31.326
上面会写什么，是说明书吗？
what it's gonna say, is it instructions?

97
00:05:31.326 --> 00:05:34.310
丹，会怎样？
Dan, is gonna be what?

98
00:05:34.310 --> 00:05:35.105
丹: MultipliedBy2。
&gt;&gt; Dan: MultipliedBy2.

99
00:05:35.105 --> 00:05:39.213
所以我们会有多个 by2输入,
&gt;&gt; Will Sentance: MultiplyBy2, so
we're gonna have multiplyBy2 input,

100
00:05:39.213 --> 00:05:44.887
0 primes around number multipliedBy2，which was previously.
array position 0 primes around number
multipliedBy2, which was previously.

101
00:05:44.887 --> 00:05:47.442
凯拉又提醒我们了之前？
Kayla remind us again, previously?

102
00:05:47.442 --> 00:05:48.192
说明书。
&gt;&gt; Kayla: Instructions.

103
00:05:48.192 --> 00:05:48.944
威尔 · 句子: 指导，对吗？
&gt;&gt; Will Sentance: Instruction, right?

104
00:05:48.944 --> 00:05:52.774
数组位置0的输入，也就是1，我们得到了,
Input of the array position 0 which is 1,
into it we've got,

105
00:05:52.774 --> 00:05:57.709
在我看来，我们要创造一个全新的什么，各位。
that looks to me much like we're gonna
create a brand new what, everybody.

106
00:05:57.709 --> 00:05:58.350
演讲者2: 执行情境。
&gt;&gt; Speaker 2: Execution context.

107
00:05:58.350 --> 00:06:00.490
执行上下文，完全正确。
&gt;&gt; Will Sentance: Execution context,
exactly.

108
00:06:00.490 --> 00:06:04.470
这是我们要运行的执行上下文1将被放入,
It's our execution context to run and
that 1 is gonna be thrown into,

109
00:06:04.470 --> 00:06:09.230
1会被放入指令中
the 1 is gonna be thrown
into instructions which

110
00:06:09.230 --> 00:06:13.449
被放入 multilyby2作为输入，让我们看看。
is thrown into multiplyBy2 as the input,
well let's see.

111
00:06:13.449 --> 00:06:15.644
让我们创建一个执行上下文,
Let's create that execution context,

112
00:06:15.644 --> 00:06:20.149
让我们把它放在调用堆栈，威尔森塔斯: 在那里
let's put it on the call Stack,
&gt;&gt; Will Sentance: There it

113
00:06:20.149 --> 00:06:24.792
在调用时，输入是1的多个 by2,
is multiplyBy2 input of
1 on the calls that,

114
00:06:24.792 --> 00:06:30.540
我们走进去，在当地的记忆里，我们有我们的1。
into it we go folk and
in the local memory, we have our 1.

115
00:06:30.540 --> 00:06:36.029
让我们有杰夫，杰夫什么是我们的参数名称
Let's have Jeff,
Jeff what is our parameter name for

116
00:06:36.029 --> 00:06:37.909
这个标签的值是1？
that label for that value 1?

117
00:06:37.909 --> 00:06:38.560
杰夫: 输入。
&gt;&gt; Jeff: Input.

118
00:06:38.560 --> 00:06:42.909
威尔 · 森坦斯: 他是对的，这是输入参数，这就是它。
&gt;&gt; Will Sentance: He is right,
it's the input parameter and there it is.

119
00:06:42.909 --> 00:06:47.925
然后我们输入2,1乘以2，我们得到2，我们返回它然后
We then do input by 2, 1 by 2,
we get 2, we return it out and

120
00:06:47.925 --> 00:06:52.942
看看这些家伙，指令是多个 by2,
look at that folks,
instructions which is, multiplyBy2,

121
00:06:52.942 --> 00:06:58.360
输入的1乘以输入的1是字面上要评价。
input of 1 multiply by input of 1
is literally going to evaluate.

122
00:06:58.360 --> 00:07:03.300
所以会变成2的输出,
So is gonna become the output of 2,

123
00:07:03.300 --> 00:07:08.040
这是2的结果，凯拉，我们怎么处理这个2？
there it is an outcomes of 2 and
Kayla what do we do with that 2?

124
00:07:08.040 --> 00:07:09.819
我们已经把它放到输出数组中了。
&gt;&gt; Kayla: We've pushed it
into the output array.

125
00:07:09.819 --> 00:07:13.050
Will Sentance: 我们将它推入输出数组。
&gt;&gt; Will Sentance: We push
it into the output array.

126
00:07:13.050 --> 00:07:15.870
有人，进入输出数组，然后
There is people,
into the output array it goes and

127
00:07:15.870 --> 00:07:18.069
死刑会导致什么后果 Kayla？
there's execution causes
what happens with it, Kayla?

128
00:07:18.069 --> 00:07:18.949
它消失了。
&gt;&gt; Kayla: It goes away.

129
00:07:18.949 --> 00:07:21.529
威尔 · 森坦斯: 我们把它从调用堆栈上取下来，它就消失了,
&gt;&gt; Will Sentance: We pop it off
the call Stack, it goes away,

130
00:07:21.529 --> 00:07:24.990
也引导你除了返回值。
also lead you besides
the returned out value.

131
00:07:24.990 --> 00:07:32.779
完美我们从 Stack 那里得到的更有活力的清除,
Perfect we get it off the call Stack,
more energetic erasing,

132
00:07:32.779 --> 00:07:40.180
这不是有点粗暴，不是坏在所有。
there is this is not as kinda
roughing not bad at all.

133
00:07:41.459 --> 00:07:45.069
现在我们点击数组，进入四个循环，再来一次，这次,
Now we hit the array, into the four
loop we go again and this time,

134
00:07:45.069 --> 00:07:47.909
我的价值 Brayden 是什么？
i's value, Brayden, is what?

135
00:07:47.909 --> 00:07:49.269
布雷顿: 1 威尔 · 森塔斯: 是1,
&gt;&gt; Braydon: 1.
&gt;&gt; Will Sentance: It's 1,

136
00:07:49.269 --> 00:07:51.290
位置1的数组是2号。
array at position 1 is number 2.

137
00:07:51.290 --> 00:07:55.769
我们用那2号球，布雷登，然后我们把它塞进什么，布雷登？
We take that 2, Brayden, and
we stick it into what, Brayden?

138
00:07:55.769 --> 00:07:56.439
布雷顿: 说明。
&gt;&gt; Braydon: Instructions.

139
00:07:56.439 --> 00:07:57.340
威尔 · 森塔斯: 哪一个是真的？
&gt;&gt; Will Sentance: Which is really?

140
00:07:57.340 --> 00:07:57.939
2.
&gt;&gt; Braydon: multiplyBy2.

141
00:07:57.939 --> 00:07:59.500
威尔 · 森塔斯: 太棒了，它有多个 by2。
&gt;&gt; Will Sentance: Fantastic,
it's multiplyBy2.

142
00:08:00.579 --> 00:08:06.470
然后哪个会回来，哪个会进去，哪个会出来，布拉登？
Which will then return out,
in goes the 2, what returns out, Braden?

143
00:08:06.470 --> 00:08:07.540
布雷顿: 4 威尔 · 森塔斯: 4，没错,
&gt;&gt; Braydon: 4.
&gt;&gt; Will Sentance: 4, exactly,

144
00:08:07.540 --> 00:08:10.589
创建执行上下文，将其放到调用堆栈上。
the execution context is created,
put it on the call stack.

145
00:08:12.180 --> 00:08:14.040
好了，我们开始吧-演讲者2: [笑]
Okay, we do it-
&gt;&gt; Speaker 2: [LAUGH]

146
00:08:14.040 --> 00:08:15.160
威尔 · 森塔斯: 就在那儿，在电话里
&gt;&gt; Will Sentance: There it is on the call

147
00:08:15.160 --> 00:08:19.292
堆栈，这是它的2，所以我只是画它,
stack, there it is with the 2,
so I'll just draw it,

148
00:08:19.292 --> 00:08:23.189
结果4它会被存储在哪里，布莱登？
outcomes 4 and
it's gonna be stored where, Braden?

149
00:08:23.189 --> 00:08:24.600
Braydon: 推入输出数组
&gt;&gt; Braydon: Pushed on
into the output array

150
00:08:24.600 --> 00:08:25.589
推入输出
&gt;&gt; Will Sentance: Pushed into the output

151
00:08:25.589 --> 00:08:26.189
数组。
array.

152
00:08:28.220 --> 00:08:32.539
2里面的标签是什么，布拉登？
The label for
2 inside multiplyBy2 was what, Braden?

153
00:08:32.539 --> 00:08:33.149
讲者二: 输入法 威尔 · 斯坦斯: 输入,
&gt;&gt; Speaker 2: Input.
&gt;&gt; Will Sentance: Input,

154
00:08:33.149 --> 00:08:38.529
这就是参数名，没错，一点没错，我得到了6，有2,4,6，很好。
that was the parameter name, exactly, spot
on, I got 6, there is 2, 4, 6, excellent.

155
00:08:38.529 --> 00:08:44.659
现在，伊森，我们完成了四个循环，我们最后要做什么？
And now Ethan, we finished our four loop,
we're gonna do what finally?

156
00:08:44.659 --> 00:08:48.460
伊森: 我们要返回输出值。
&gt;&gt; Ethan: We're gonna
return the value of output.

157
00:08:48.460 --> 00:08:53.626
Will Sentance: Beautiful，返回输出值，数组，2,
&gt;&gt; Will Sentance: Beautiful,
return the value of output, the array, 2,

158
00:08:53.626 --> 00:08:59.143
4,6，到结果，就是这个数组2,4,6。
4, 6, into results,
there it is, the array 2, 4, 6.

159
00:08:59.143 --> 00:09:06.840
很好，我们已经构建了一个函数，看看这个，我们不需要这样做
Fork wonderful, we've built out a function
that, look at this we didn't have to

160
00:09:06.840 --> 00:09:11.899
以任何方式预先确定我们要对数组的每个元素做什么。
in any way predetermine what we're
gonna do to each element of the array.

161
00:09:11.899 --> 00:09:14.049
我们把它留给了机构，并且
We left it blank with institutions, and

162
00:09:14.049 --> 00:09:18.720
就像我们让我们的地方，把我们的参数安排在最佳位置一样。
just like we had our place order
our parameter in our best position.

163
00:09:18.720 --> 00:09:23.259
它是否有一个占位符参数用于传递数组1,2,3，它可以
Does it have a placeholder parameter for
passing in that array 1,2,3, which could

164
00:09:23.259 --> 00:09:28.370
是1,2,3,4,5,6，可能是7,8,9，可能是其他的。
have been 1, 2, 3, 4, 5, 6, could have
been 7, 8, 9, could have been whatever.

165
00:09:28.370 --> 00:09:33.429
所以2，我们留了一个占位符，表示我们要对数组中的每个元素做什么,
So 2, we left a placeholder for what we're
gonna do to each element of that array,

166
00:09:33.429 --> 00:09:37.940
一个小空白，我们填写了一个函数，接受了一个输入,
a little blank, and we filled it in
with a function that took in one input,

167
00:09:37.940 --> 00:09:41.629
我们已经准备好了，我们使用了它，我们接受了输入,
we were ready for it,
we used it, we took that input,

168
00:09:41.629 --> 00:09:45.100
我们将结果返回，并将其输出。
we returned out the result and
we pushed it into output.

169
00:09:45.100 --> 00:09:49.360
因为我们已经复制了一个操作函数
For we've made our copy
of a manipulate function

170
00:09:49.360 --> 00:09:53.960
通用可重用，我们现在可以编辑它的代码，因为我们
general reusable,
we can now edit its code because we

171
00:09:53.960 --> 00:09:57.559
留下了一些空白，我们可以稍后再填写，你不能编辑函数。
left a little blank bit that we can fill
in later on, you can't edit functions.

172
00:09:57.559 --> 00:10:00.870
但是如果你为他们的代码留下一点空间一点占位符,
But if you leave a little space, a little
placeholder for some of their code,

173
00:10:00.870 --> 00:10:05.500
你可以编辑函数，保存一次，然后反复使用。
you can edit functions, save them once,
use it again and again.
