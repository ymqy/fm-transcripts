WEBVTT

1
00:00:00.140 --> 00:00:02.100
威尔 · 森塔斯: 我们要执行代码了。
&gt;&gt; Will Sentance: We're
about to execute code.

2
00:00:03.189 --> 00:00:05.000
我说过执行代码有两件事。
I said there's two things
to executing code.

3
00:00:05.000 --> 00:00:10.800
两部分，一部分，按照给定的代码，一行一行地检查，然后执行。
Two parts to it, one, going through the
code as given, line by line, and doing it.

4
00:00:10.800 --> 00:00:13.310
第二，有一个可以看到数据的地方。
Two, having a place to see
stuff that shows up, data.

5
00:00:13.310 --> 00:00:15.599
这正是运行代码所需要的。
That is literally what
it takes to run code.

6
00:00:15.599 --> 00:00:19.484
正在运行的函数就像一个迷你程序。
A function being run is
like a mini program.

7
00:00:19.484 --> 00:00:24.809
像一个迷你应用程序，像一些代码运行，因此，我们需要这两个东西。
Like a mini-app, like it's some code to
run therefore, we need those two things.

8
00:00:24.809 --> 00:00:29.309
执行线程，一行一行地执行代码的能力。
The thread of execution, the ability to go
through the code line-by-line and do it.

9
00:00:29.309 --> 00:00:30.719
还有一点数据存储,
And a little store of data,

10
00:00:30.719 --> 00:00:35.229
存储器，用来存储我们在这个函数中出现的任何东西。
the memory, to store anything that shows
up while we're inside that function.

11
00:00:35.229 --> 00:00:38.880
任何函数、变量、常量只能存储在那个函数中。
Any functions, variables,
constant stored inside that function only.

12
00:00:40.140 --> 00:00:43.418
这两件事加在一起有一个非常，非常深刻的名字。
Those two things together have a very,
very profound sounding name.

13
00:00:44.740 --> 00:00:45.899
有人知道吗？
Does anybody happen to know?

14
00:00:45.899 --> 00:00:51.439
如果我把手臂这样举起来，那该叫什么呢？
If I put my arms up like this,
what that might be called?

15
00:00:51.439 --> 00:00:53.969
一个全新的演讲者2: 执行竞赛。
A brand new
&gt;&gt; Speaker 2: Execution contest.

16
00:00:53.969 --> 00:00:56.729
威尔 · 森特斯: 天啊，如果人们第一次看到这个,
&gt;&gt; Will Sentance: My, okay if people
are watching this the very first time,

17
00:00:56.729 --> 00:00:59.000
第一次见面的时候，他们会说，好吧。
this first encounter, they're like, okay.

18
00:00:59.000 --> 00:01:01.780
好的，没错，一个执行上下文。
All right, exactly, an execution context.

19
00:01:01.780 --> 00:01:03.820
这是完全正确的人。
That is exactly right people.

20
00:01:03.820 --> 00:01:09.185
创建来运行一个函数的代码，有两个部分，我们已经看到了。
Created to run the code of a function,
has two parts, we've seen them already.

21
00:01:09.185 --> 00:01:12.025
执行线程，因为我们现在要去
Thread of execution because
we're now gonna be going

22
00:01:12.025 --> 00:01:16.635
通过乘以两个行和一个内存的代码,
through the code of multiplied by
two line by line and a memory,

23
00:01:16.635 --> 00:01:22.094
一个小空间来存储数据和函数，以便在函数内部声明。
a little space to store data and functions
to get declared inside that function.

24
00:01:22.094 --> 00:01:26.575
所以这是正确的，在我们能够继续前进之前，跑步乘以2
So that's right for running multiplied by
two before we're able to move on to any

25
00:01:26.575 --> 00:01:30.810
进一步的代码，我们要创建一个全新的执行环境。
further code, we're gonna create
a brand new execution context.

26
00:01:30.810 --> 00:01:33.000
在这里，我要画一个大盒子。
Here it is, I'm gonna draw the big box.

27
00:01:33.000 --> 00:01:34.740
看看这个，就是这个。
Look at this, this is what it is.

28
00:01:34.740 --> 00:01:36.129
顺便说一句，我们已经看到一个了。
We, by the way, see one already.

29
00:01:36.129 --> 00:01:38.520
这是个大问题，这个叫做全球问题。
This was the big one,
this is called the global one.

30
00:01:38.520 --> 00:01:42.579
这是一个一旦我们开始运行我们的代码文件，我们创建什么’
This is the one that as soon as we start
running our file of code, we create what's

31
00:01:42.579 --> 00:01:46.780
称为全局执行上下文，用于运行整个代码文件。
called a global execution context for
running the overall file of code.

32
00:01:46.780 --> 00:01:48.770
那东西是主程序。
That thing is the main program.

33
00:01:48.770 --> 00:01:52.539
一旦我们开始运行一个小函数，一小段代码,
As soon as we start running a little
function, a little mini bit of code,

34
00:01:52.539 --> 00:01:56.840
我们创建一个迷你程序，一个迷你执行环境。
we create a mini program,
a mini execution context.

35
00:01:56.840 --> 00:01:59.159
就是这个，我把它做得很大。
Here it is, I've made this very big.

36
00:01:59.159 --> 00:02:03.549
就是这样，正如我所说，它分为两部分。
There it is, and
it has as I say, two parts.

37
00:02:03.549 --> 00:02:06.209
第一，记忆,
One, the memory,

38
00:02:06.209 --> 00:02:10.250
一个用来存放被申报在里面的东西的地方。
a place to store things that get
declared inside multiplied by two.

39
00:02:10.250 --> 00:02:16.079
我们称之为本地记忆，因为它只是，本地的意思是附近。
We call it the local memory because
it's just, local means nearby.

40
00:02:16.079 --> 00:02:19.569
只是在我们运行代码的时候可以使用的东西
It's just stuff that's gonna be available
while we're running the code and

41
00:02:19.569 --> 00:02:22.270
再乘以二，这里没有。
multiply it by two,
not available out here.

42
00:02:22.270 --> 00:02:26.069
任何我们在这个函数中宣布或声明的东西，任何
And anything which we announce or declare
inside this function, any variable for

43
00:02:26.069 --> 00:02:27.170
明白了吗？
it, you got it?

44
00:02:27.170 --> 00:02:31.710
存在这里，而不是这里，好吧。
Stored in here, not in here, all right.

45
00:02:31.710 --> 00:02:34.090
在这个函数中
So, into this function we go and

46
00:02:35.189 --> 00:02:39.050
我们在里面要做的第一件事是什么？
what is the first thing that
we're going to do inside of here?

47
00:02:39.050 --> 00:02:41.610
伊森，我们进去第一件事要做什么？
Ethan, what is the first
thing we're gonna do inside?

48
00:02:41.610 --> 00:02:43.569
伊森: 声明第一个结果。
&gt;&gt; Ethan: Declare the const result.

49
00:02:43.569 --> 00:02:46.370
威尔 · 森塔斯: 伊桑几乎是对的，这是我们要做的第二件事。
&gt;&gt; Will Sentance: Ethan's almost right,
that's the second thing we're going to do.

50
00:02:46.370 --> 00:02:49.409
但是 Ethan 只要我们在函数中运行代码,
But Ethan,
whenever we run code in a function,

51
00:02:49.409 --> 00:02:52.120
我们处理 Ethan 的第一件事是什么？
the first thing we always
handle Ethan is what?

52
00:02:54.439 --> 00:02:58.129
在我们触及身体我们处理的功能之前，我们得到了一些东西
Before we hit the body the function we
handle, we've got some stuff with sort of

53
00:02:58.129 --> 00:03:01.139
插入到本地内存中的函数中。
inserting into the function that's going
to show up inside the local memory.

54
00:03:01.139 --> 00:03:01.759
那是什么？
And that is?

55
00:03:01.759 --> 00:03:03.500
伊森: 那么输入号码。
&gt;&gt; Ethan: So input number.

56
00:03:03.500 --> 00:03:08.289
威尔 · 森塔斯: 太好了。 会被设置成什么？
&gt;&gt; Will Sentance: Excellent.
It's gonna be set to what?

57
00:03:08.289 --> 00:03:09.289
伊森: 三个。
&gt;&gt; Ethan: Three.

58
00:03:09.289 --> 00:03:11.719
威尔 · 森塔斯: 他说对了，数字是3。
&gt;&gt; Will Sentance: He's spot on,
to num which evaluated to 3.

59
00:03:11.719 --> 00:03:14.349
这就是标签，价值。
There it is, label, value.

60
00:03:14.349 --> 00:03:16.120
在这里没什么不同。
No different to out here.

61
00:03:16.120 --> 00:03:18.400
但是这些都有特殊的名字。
But these ones have special names.

62
00:03:18.400 --> 00:03:20.520
这个叫做人的是什么？
What's this one known as people?

63
00:03:20.520 --> 00:03:21.120
讲者2: 参数。
&gt;&gt; Speaker 2: Parameter.

64
00:03:21.120 --> 00:03:23.599
威尔 · 森特斯: 这个呢，伙计们？
&gt;&gt; Will Sentance: And this one here folks?

65
00:03:23.599 --> 00:03:24.460
讲者2: 论点。
&gt;&gt; Speaker 2: Argument.

66
00:03:24.460 --> 00:03:25.530
威尔 · 森塔斯: 没错。
&gt;&gt; Will Sentance: Exactly.

67
00:03:25.530 --> 00:03:30.199
所以当函数结束时，占位符输入的数字将会被接收
So the placeholder input number that's
gonna receive when the function ends up

68
00:03:30.199 --> 00:03:33.409
运行一个实际输入，实际值，实际数字。
being run an actual input,
actual value, actual number.

69
00:03:33.409 --> 00:03:36.579
这个被传入的数字就是我们的论点。
That number that gets passed
in is known as our argument.

70
00:03:36.579 --> 00:03:39.849
等待它的占位符称为我们的参数。
The placeholder that awaits
it is known as our parameter.

71
00:03:39.849 --> 00:03:41.400
他们是完全不同的。
They are fundamentally different.

72
00:03:41.400 --> 00:03:43.659
我指的是同一枚硬币的两面，但是
I mean that two sides of the same coin,
but

73
00:03:43.659 --> 00:03:45.060
它们是完全不同的东西。
they are fundamentally different things.

74
00:03:45.060 --> 00:03:48.430
一个是标签，一个是存储在标签里的东西。
One is the label,
one is the thing stored in that label.

75
00:03:48.430 --> 00:03:52.539
好的，然后我们点击结果并分配它，伊森，什么？
Okay, then we hit result and
assign it, Ethan, what?

76
00:03:53.680 --> 00:03:57.539
当它解决的时候也会有一个存储在里面吗？
When it's resolved gonna
also have a stored in it?

77
00:03:57.539 --> 00:03:59.050
伊森: 输入数字乘以2。
&gt;&gt; Ethan: Input number times two.

78
00:03:59.050 --> 00:04:01.159
维尔 · 森坦斯: 哪一个会是？
&gt;&gt; Will Sentance: Which is gonna be?

79
00:04:01.159 --> 00:04:02.283
伊森: 六个 威尔 · 森特斯: 三乘二将会是
&gt;&gt; Ethan: Six.
&gt;&gt; Will Sentance: Three by two is gonna be

80
00:04:02.283 --> 00:04:04.639
6号，太好了，谢谢。
six, excellent, thank you.

81
00:04:04.639 --> 00:04:07.409
对于伊森和最后的决赛来说，这是一场有趣的比赛。
To Ethan and
then the final it was an interesting one.

82
00:04:07.409 --> 00:04:13.090
我们已经得到了丹，返回，实际上等待丹，我已经要求你很多时间。
We've got Dan, return, actually hold
on Dan, I've asked you lots of time.

83
00:04:13.090 --> 00:04:18.389
所以我要把它混合起来，我要转向杰森。
So I'm going to mix it up,
I'm going to turn to Jason.

84
00:04:18.389 --> 00:04:21.750
杰森，这最后一句话是什么意思？
Jason, what is this
final line saying here?

85
00:04:21.750 --> 00:04:27.649
杰森: 意思是找到被绑定的内存块
&gt;&gt; Jason: It's saying that locate
the block of memory that is bound

86
00:04:27.649 --> 00:04:32.519
威尔 · 森坦斯: 是的，我喜欢。
to the label resolve and ship it out of-
&gt;&gt; Will Sentance: Yeah, I like that.

87
00:04:32.519 --> 00:04:34.509
我，好吧，你真的很喜欢。
I, all right, you really like that.

88
00:04:34.509 --> 00:04:37.490
它说，去看看，这个词解决是什么意思？
It says, go look at,
what does this word resolve mean?

89
00:04:37.490 --> 00:04:41.769
不会自动知道，所以它会在我们的本地内存中寻找它。
Javachip doesn't know automatically, so it
goes hunting for it in our local memory.

90
00:04:41.769 --> 00:04:46.610
找到一个数字6，然后接受这个数字
Finds it's a number six and
then takes that number and

91
00:04:46.610 --> 00:04:49.350
运输它返回它射出它。
ships it returns it shoots it out.

92
00:04:49.350 --> 00:04:50.949
接下来会发生什么
What's literally gonna happen people

93
00:04:52.649 --> 00:04:57.759
是因为运行调用做同样的事情很酷还是
is that the cool to the running of
the invocation doing the same thing or

94
00:04:57.759 --> 00:05:01.439
乘以2等于3。
multiply by two and
number three is gonna evaluate to.

95
00:05:01.439 --> 00:05:05.980
这意味着它会逐渐转化为,
That means it's gonna literally
turn into the value that,

96
00:05:05.980 --> 00:05:10.410
人们看重的是这个，这里存储的任何东西。
people value is this this,
this the anything that's stored.

97
00:05:11.610 --> 00:05:13.920
不是我们称之为标识符的标签,
Not the label,
which we fancy called the identifier,

98
00:05:13.920 --> 00:05:16.069
就是存储为一个值的东西。
is the thing stored as a value.

99
00:05:16.069 --> 00:05:20.129
我们要评估，也就是说我们要转动这个命令
We're going to evaluate, that is to
say we're going to turn this command

100
00:05:20.129 --> 00:05:24.490
你不能存储到结果值中的东西
the thing you can't store
into the result value and

101
00:05:24.490 --> 00:05:28.300
看，你要计算到数字6。
look at that is that you're going
to evaluate into the number six.

102
00:05:28.300 --> 00:05:31.339
然后输出等于6
And then that output is equal to six and

103
00:05:31.339 --> 00:05:36.899
就是这样，返回并分配到输出端。
there it is, returned out and
assigned to output.

104
00:05:36.899 --> 00:05:41.850
我的天啊，好了，我们的执行线程。
My goodness.
All right, so our thread of execution.

105
00:05:41.850 --> 00:05:47.100
因为在 JavaScript 中，有多少线程需要执行？
Wove in because by the way in JavaScript,
how many threads of execution?

106
00:05:47.100 --> 00:05:50.149
就是这样，我想说我们一次能做多少事情，人们？
That's it, I'd say how many things
can we do at a time people?

107
00:05:50.149 --> 00:05:52.790
我提出了两个不同的问题,
Well, I've asked two different
questions to pronounce is there,

108
00:05:52.790 --> 00:05:54.920
我们有多少执行线程 Adam？
how many threads of
execution do we have Adam?

109
00:05:54.920 --> 00:05:55.470
亚当: 只有一个。
&gt;&gt; Adam: Just one.

110
00:05:55.470 --> 00:05:58.360
威尔: 一，这意味着我们一次做多少件事？
&gt;&gt; Will Sentance: One, that means
how many things we do at a time?

111
00:05:58.360 --> 00:06:00.110
同样的事情发生的可能性有多大。
What are the odds with the same.

112
00:06:00.110 --> 00:06:03.850
好了，我们已经有了一个执行线程。
Okay, so
we have already one thread of execution.

113
00:06:03.850 --> 00:06:08.319
一旦你想启动和执行一个函数，我们必须有一个线程编织
As soon as you want to start and execute
a function, we have to have a thread weave

114
00:06:08.319 --> 00:06:11.759
然后开始运行这些代码行，然后它会迂回回来。
in and start running those lines of code
and then it's going to weave back out.

115
00:06:11.759 --> 00:06:15.060
当我们运行这个函数时，我们不能继续在页面下方运行。
We can't continue on down the page
while we're running that function.

116
00:06:15.060 --> 00:06:16.920
我们不能同时做两件事。
We don't do two things simultaneously.

117
00:06:16.920 --> 00:06:19.870
我们将在明天的同步 JavaScript 中看到更多这方面的内容。
We're gonna see more about that with
a synchronous JavaScript to come tomorrow.

118
00:06:19.870 --> 00:06:25.160
好吧，那么我们的执行线程就编织在里面了
All right, so
our thread of execution weaves in it then

119
00:06:25.160 --> 00:06:32.509
我们在全球范围内碰到了什么线，不是吗，马克？
weaves back out with into global where
we hit what line, wasn't it Mark?

120
00:06:32.509 --> 00:06:33.189
马克: 马克 威尔 · 森特斯: 马克,
&gt;&gt; Mark: Mark.
&gt;&gt; Will Sentance: Mark,

121
00:06:33.189 --> 00:06:35.209
对不起，马克，我们撞到什么线了，马克？
sorry Mark, we hit what line Mark?

122
00:06:36.279 --> 00:06:36.980
标记: Const new output。
&gt;&gt; Mark: Const new output.

123
00:06:36.980 --> 00:06:40.860
威尔 · 森坦斯: 宣布新的产出，就是这样。
&gt;&gt; Will Sentance: Declaring new outputs,
there it is.

124
00:06:42.199 --> 00:06:45.949
马克，我们知道怎么分配新的产出吗？
Mark, do we know what
to assign new output?

125
00:06:45.949 --> 00:06:48.920
我们知道在新产品中存储什么了吗？
Do we know what to store
in new output yet?

126
00:06:48.920 --> 00:06:50.050
马克: 没有 威尔 · 森坦斯: 因为我们要
&gt;&gt; Mark: No.
&gt;&gt; Will Sentance: Because we gonna

127
00:06:50.050 --> 00:06:51.319
去做什么？
go and do what?

128
00:06:51.319 --> 00:06:53.100
马克: 我们必须创造另一个环境。
&gt;&gt; Mark: We have to
create another context.

129
00:06:53.100 --> 00:06:57.029
句子: 执行上下文，我们要去执行什么功能马克？
&gt;&gt; Will Sentance: Execution context, we
gonna go and execute what function Mark?

130
00:06:57.029 --> 00:06:57.949
马克: 乘以二。
&gt;&gt; Mark: Multiply by two.

131
00:06:57.949 --> 00:06:59.788
威尔 · 桑特斯: 用？
&gt;&gt; Will Sentance: With the argument of?

132
00:06:59.788 --> 00:07:00.951
马克: 10 威尔 · 森特斯: 太好了,
&gt;&gt; Mark: 10.
&gt;&gt; Will Sentance: Excellent,

133
00:07:00.951 --> 00:07:05.839
我会督促马克尽可能完整地进行技术交流。
I'm gonna push Mark to be as complete as
possible with his technical communication.

134
00:07:05.839 --> 00:07:08.100
这就是我们美丽的执行环境。
There it is,
there's our beautiful execution context.

135
00:07:09.160 --> 00:07:10.860
比上一个好多了。
That's better than the last one.

136
00:07:10.860 --> 00:07:13.110
然后我们进入它
And into it we go and

137
00:07:13.110 --> 00:07:19.009
我知道这是难以置信的重复，这就是功能的本质。
I know this is incredibly repetitive,
well, that's the nature of function.

138
00:07:19.009 --> 00:07:22.009
我们保存它一次，我们可以一次又一次地使用它，就是这样。
We save it once, we can use it again and
again, there we go.

139
00:07:22.009 --> 00:07:26.839
进我们去输入数字大家，分配什么，我们的论点值多少？
Into we go and input number everybody, is
assigned what, our argument of the value?

140
00:07:26.839 --> 00:07:27.569
马克: 10 威尔 · 森坦斯: 10,
&gt;&gt; Mark: 10.
&gt;&gt; Will Sentance: 10,

141
00:07:27.569 --> 00:07:31.339
做得好，结果是10乘以2得到20。
well done, and then result is
assigned 10 by two, which is 20.

142
00:07:31.339 --> 00:07:38.590
然后，我们将结果的值返回到全局标记的新输出中。
Then we return the value of results
out into that global label new output.

143
00:07:40.340 --> 00:07:41.629
就是这样，伙计们。
And there it is, people.

144
00:07:41.629 --> 00:07:42.980
我的天啊，好吧。
My goodness, all right.

145
00:07:42.980 --> 00:07:47.470
这是我们 JavaScript 平台三个部分中的两个核心部分。
That is the core two out of three
parts of our JavaScript platform.
