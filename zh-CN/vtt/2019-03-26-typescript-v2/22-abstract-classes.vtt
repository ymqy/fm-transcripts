WEBVTT

1
00:00:00.060 --> 00:00:02.890
迈克 · 诺斯: 这个，虽然我不知道该怎么说，但我还是想告诉你
&gt;&gt; Mike North: This, I kinda feel
abrogated to show you this although I

2
00:00:02.890 --> 00:00:06.790
我没有发现我经常使用抽象类。
don't find that I use it all that often,
abstract classes.

3
00:00:06.790 --> 00:00:12.996
抽象类不能直接实例化，它们只是作为基类。
Abstract classes cannot be instantiated
directly, they just serve as base classes.

4
00:00:12.996 --> 00:00:17.734
所以不像在接口中，它也不能实例化,
So unlike in interface,
which also can't be instantiated,

5
00:00:17.734 --> 00:00:21.931
抽象类可以有实现，对吗？
abstract classes can have implementations,
right?

6
00:00:21.931 --> 00:00:26.408
在本例中，我有一个带有一些 param 属性的构造函数，因此 name 和
In this case, I have a constructor with
some param properties ,so name and

7
00:00:26.408 --> 00:00:29.850
电子邮件会在那里，它的服务作为一个基本类。
email will be there,
it's serving as a base class.

8
00:00:29.850 --> 00:00:32.420
但是我也有一个抽象的方法
But I also have an abstract method here,
and

9
00:00:32.420 --> 00:00:36.009
必须由任何子类实现。
that must be implemented by any subclass.

10
00:00:36.009 --> 00:00:40.429
所以我认为这是一种半类半接口的方式。
So I think of this as sort of half class,
half interface.

11
00:00:40.429 --> 00:00:42.429
这样我们就可以四处传阅了。
And this lets us pass around.

12
00:00:42.429 --> 00:00:46.520
我们仍然可以通过它们的抽象基类引用两个事物。
We can still refer two things
by their abstract base class.

13
00:00:46.520 --> 00:00:49.979
但具体的实现可能看起来非常非常不同。
But concrete implementations
may look very, very different.

14
00:00:49.979 --> 00:00:53.390
在这里你所要做的就是把类抽象化
All you have to do here is
make the class abstract and

15
00:00:53.390 --> 00:00:57.496
然后你可以把字段和方法都抽象化。
then you can make both fields and
methods abstract as well.

16
00:00:57.496 --> 00:01:05.890
因此需要类来实现具有兼容访问修饰符的类。
And so classes are required to implement
those with a compatible access modifier.

17
00:01:05.890 --> 00:01:11.201
比如，你可以拿一些受保护的东西，我想知道你是否可以这样做。
Like, you could take something protected,
I wonder if you can even do that.

18
00:01:13.260 --> 00:01:13.929
迈克 · 诺斯: 是的。
&gt;&gt; Mike North: Yep.

19
00:01:16.658 --> 00:01:18.567
迈克 · 诺斯: 不，看起来他们已经修好了这里。
&gt;&gt; Mike North: No, it looks like
that they've fixed this here.

20
00:01:18.567 --> 00:01:23.450
所以必须把事情公开，因为抽象有点奇怪
So gotta make things public because
it'd be kinda strange to have abstract

21
00:01:23.450 --> 00:01:25.859
一些私人的事情，比如怎么做？
things that are private, like how?

22
00:01:25.859 --> 00:01:29.879
这样你就不能真正了解子类了。
You don't really have visibility
into subclasses in that way.

23
00:01:31.859 --> 00:01:34.349
这是一个实现的例子，你可以看到,
So here's an example of an implementation,
and you can see,

24
00:01:34.349 --> 00:01:38.484
如果我们移除 sendEmail 它会告诉我们,
if we were to remove sendEmail,
it's gonna tell us,

25
00:01:38.484 --> 00:01:44.310
非抽象类 ConcreteContact 不实现
non-abstract class,
ConcreteContact, does not implement

26
00:01:44.310 --> 00:01:49.420
继承的继承抽象成员 sendEmail。
inherited inherited
abstract member sendEmail.

27
00:01:49.420 --> 00:01:52.835
因此，我们还没有达到我们需要满足的所有要求。
So we have not met all of
the requirements we need to meet.
