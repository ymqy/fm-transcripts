WEBVTT

1
00:00:00.080 --> 00:00:01.847
&gt；&gt；Steve：幸运的是有一些解决方案
&gt;&gt; Steve: Luckily there
are some solutions for

2
00:00:01.847 --> 00:00:06.663
这个。&gt；&gt；steve：所以
this.
&gt;&gt; Steve: So

3
00:00:06.663 --> 00:00:12.836
我使用的是ES 2015语法或ES 2015预设，
what I was using was called the ES
2015 syntax or the ES 2015 preset,

4
00:00:12.836 --> 00:00:18.829
它基本上支持所有ES 2015，适用于不支持的浏览器。
which basically supports all of ES 2015,
for browsers that don't.

5
00:00:20.410 --> 00:00:26.106
这意味着就像所有版本的Internet Explorermso等等，对吧。
Which means like all versions of Internet
Explorermso on and so forth, right.

6
00:00:26.106 --> 00:00:29.300
所以我们要看一堆工具，所有这些都可能被使用。
And so we're gonna look a bunch of tools,
all these fall under maybe use.

7
00:00:29.300 --> 00:00:33.359
但第一个可能是最有可能在所有这些情况下使用的，对吧。
But the first one is probably the most
likely to use under all of those, right.

8
00:00:33.359 --> 00:00:37.439
那就是你需要看看你的用户在使用什么浏览器，
Which is you need to look at what
browsers are your users are using,

9
00:00:37.439 --> 00:00:42.490
因为像Chrome、Firefox、Safari、Edge一样，它们都支持该类语法。
because like Chrome, Firefox, Safari,
Edge, they all support that class syntax.

10
00:00:42.490 --> 00:00:44.509
它们都支持该语法。
They all support that syntax.

11
00:00:44.509 --> 00:00:45.909
这是不是意味着你需要转移它？
Does that mean you need to transpile it?

12
00:00:46.950 --> 00:00:47.700
你可能不知道。
You probably don't.

13
00:00:47.700 --> 00:00:53.020
你就是不交那个税，这比交好，对吧。
You just not pay that tax,
which is better than paying it, right.

14
00:00:53.020 --> 00:00:57.460
所以Babel-preset-env所做的，它有效地，
And so what babel-preset-env does,
it it effectively,

15
00:00:57.460 --> 00:01:00.670
你用它而不是2015年之类的。
you use it instead of AS2015 or whatever.

16
00:01:00.670 --> 00:01:03.340
基本上你可以明确你支持的是什么。
And you can basically get
specific about what you support.

17
00:01:04.620 --> 00:01:08.590
这将支持每个浏览器的最后两个版本，以及它们支持的任何内容，
This will support the last two versions of
every browser, and whatever they support,

18
00:01:08.590 --> 00:01:11.810
这意味着它不会转换类，最后两个浏览器。
which means it won't transpile the class,
the last two browsers.

19
00:01:11.810 --> 00:01:12.730
我是说，Safari 7，
I mean, Safari 7,

20
00:01:12.730 --> 00:01:15.340
你基本上是在转移一切，Safari目前是11。
you're basically transpiling everything,
Safari's currently at 11.

21
00:01:15.340 --> 00:01:18.569
而且它们通常每年更新一次。
And they usually update on a yearly basis.

22
00:01:18.569 --> 00:01:23.859
因此，根据我的数学计算，到2014年，也许是2013年，这取决于我们在哪里划定这条线。
So that gets you to 2014 by my math, 2013
maybe, depends on where we draw that line.

23
00:01:23.859 --> 00:01:26.689
但是如果你说像，上两个版本，如果你看你的指标，
But if you said like, last two versions,
if you look at your metrics,

24
00:01:26.689 --> 00:01:31.310
看看你的用户正在使用什么浏览器，你可以开始说，我不需要
figure what browser your users are using,
you can begin to say like, I don't need to

25
00:01:31.310 --> 00:01:36.390
支持，我不需要转换所有客户使用的语法，
support, I don't need to transpile
syntax used by all of my customers,

26
00:01:36.390 --> 00:01:38.920
对，有些就像看数据一样。
right, And
some of that is like looking at the data.

27
00:01:38.920 --> 00:01:40.460
其中一部分是由产品驱动的，
Some of that is driven by product,

28
00:01:40.460 --> 00:01:44.060
在LIKE产品中保留了他们支持的浏览器的列表。
at like product keeps a list
of what browsers they support.

29
00:01:44.060 --> 00:01:46.930
这意味着我不需要支付喋喋不休的税
That means I don't need
to pay the babble tax for

30
00:01:46.930 --> 00:01:49.409
我们并不正式支持的浏览器，对吧。
browsers that we don't officially support,
right.

31
00:01:50.609 --> 00:01:52.280
所以思考这些事情是有用的。
So it's useful thinking
about those things.

32
00:01:52.280 --> 00:01:55.433
很多时候我们可以用更好的工具来解决这个问题。
And a lot of times we can solve
this problem with better tooling.

33
00:01:55.433 --> 00:01:56.000
很多时候，
And alot of times,

34
00:01:56.000 --> 00:01:59.229
如果你的工具让你失败了，可能有一个解决方案。
if your tooling is failing you, there is
probably a solution out there for it.

35
00:01:59.229 --> 00:02:00.829
你不需要接受这是命运。
You don't have to accept that as a fate.

36
00:02:00.829 --> 00:02:04.019
但重要的是要考虑你愿意承担的成本
But it's important to think about what
costs you're willing to take on and

37
00:02:04.019 --> 00:02:05.510
你愿意做什么取舍。
what trade offs you're willing to make.

38
00:02:05.510 --> 00:02:09.050
所以让我们看看其他几个Babel插件，我认为，
So let's look at just a few other babel
plug ins that are kind of, I think,

39
00:02:09.050 --> 00:02:12.150
有趣的，有用的考虑到我们今天讨论的内容。
interesting, useful considering what
we've talked about a little bit today.

40
00:02:13.169 --> 00:02:17.680
这就是Babel plugin-transform-react-remove-prop-types。
So this is babel
plugin-transform-react-remove-prop-types.

41
00:02:17.680 --> 00:02:24.110
REACT建议，强烈建议您使用道具类型以确保
React suggests, highly recommends that
you use prop types to make sure that

42
00:02:24.110 --> 00:02:27.389
你认为他们会是什么样子？
the property is going to your component
are what you think they're gonna be?

43
00:02:27.389 --> 00:02:30.800
这是一个有效的反应组件的类型系统，对吧。
It's effectively a type system for
your react components, right.

44
00:02:30.800 --> 00:02:32.020
而且它只在发展中起作用。
And it only works in development.

45
00:02:32.020 --> 00:02:35.599
当您进入生产模式时，REACT不会花费时间进行检查，对吧。
When you go into production mode, react is
not gonna spend the time checking, right.

46
00:02:35.599 --> 00:02:36.729
只是在你发展的过程中。
It's only as you're developing.

47
00:02:36.729 --> 00:02:41.590
我们不想浪费时间在你的用户电脑上检查所有的东西，
We don't wanna waste time on your users
computers to check all the stuff,

48
00:02:41.590 --> 00:02:43.629
所以它完全被跳过了。
and so it just gets totally skipped.

49
00:02:43.629 --> 00:02:46.500
但你还在发送代码，对吧。
But you're still sending that code, right.

50
00:02:46.500 --> 00:02:50.500
你知道什么比必须解析和执行代码更快
You know what would be faster than having
to parse and execute that code and

51
00:02:50.500 --> 00:02:51.246
那就永远不用了？
then never use it?

52
00:02:51.246 --> 00:02:52.788
不做。
Not doing it.

53
00:02:52.788 --> 00:02:54.810
[笑]对吧？
[LAUGH] Right?

54
00:02:54.810 --> 00:02:58.360
所以它所做的就是基本上遍历你的代码
So what it does is it basically
goes through your code and

55
00:02:58.360 --> 00:03:00.710
把它都剥了出来，对吧。
strips it all out, right.

56
00:03:00.710 --> 00:03:03.840
您甚至可以说删除import语句，并且
And you can even say remove
the import statement, and

57
00:03:03.840 --> 00:03:09.270
它将从属性类型中删除导入属性类型。
it will remove that import
prop types from prop-types.

58
00:03:09.270 --> 00:03:12.819
有些图书馆确实需要使用它，所以你可以做其他奇怪的事情，
Some libraries do need to use it, so
you can do this other weird stuff,

59
00:03:12.819 --> 00:03:15.860
这就像，嘿，如果我们不在生产中，那么做这些其他的事情。
which is like, hey, if we're not in
production than do these other things.

60
00:03:15.860 --> 00:03:17.740
但我从来不需要那样的设置。
But I have never needed that setting.

61
00:03:17.740 --> 00:03:19.490
老实说，这张幻灯片让我压力很大，所以
And honestly,
this slide stresses me out, so

62
00:03:19.490 --> 00:03:21.616
我要搬到下一个。
I'm moving to the next one.

63
00:03:21.616 --> 00:03:25.591
&gt；&gt；扬声器2：babel-plugin-transform-react-purple-class-t-
&gt;&gt; Speaker 2:
babel-plugin-transform-react-pure-class-t-

64
00:03:25.591 --> 00:03:28.860
O-Function&gt；&gt；steve：哪个将采取反应
o-function
&gt;&gt; Steve: Which will take reaction

65
00:03:28.860 --> 00:03:32.360
未保持任何状态和
components that are not
holding on to any state and

66
00:03:32.360 --> 00:03:34.530
将它们转换为较小的语法。
turn them into that smaller syntax.

67
00:03:34.530 --> 00:03:38.280
在反应15中并不比反应快，
Which in react 15 wasn't
any faster than react,

68
00:03:39.280 --> 00:03:43.629
比类语法更好，比如类What扩展React Duct组件但是
than the class syntax, like class
whatever extends react duct component but

69
00:03:43.629 --> 00:03:46.520
将来执行可能会更快，因为您不必去
may be faster in the future to execute,
because you don't have to go

70
00:03:46.520 --> 00:03:49.699
通过创建类和原型链的过程。
through the process of creating
a class and a prototype chain.

71
00:03:49.699 --> 00:03:53.120
上次我检查过，但这并不总是正确的。
Last I checked and
this will not always be true.

72
00:03:53.120 --> 00:03:55.710
如果您使用特殊的LIKE SHORT语法
Is that if you use a special
like shorter syntax for

73
00:03:55.710 --> 00:03:58.719
函数，他们只是把它变成了引擎盖下的类。
the functions, they just turned
it into classes under the hood.

74
00:03:58.719 --> 00:04:00.099
但这并不是一件长期的事情。
But that is not like a long term thing.

75
00:04:00.099 --> 00:04:02.259
最终他们会更快。
Eventually they will be faster.

76
00:04:02.259 --> 00:04:05.699
因此，它所做的就是找到一些只有render方法的组件
And so what this does, is find some
component that only has a render method

77
00:04:05.699 --> 00:04:06.840
也不会抓住任何状态。
and doesn't hold onto any state.

78
00:04:08.379 --> 00:04:11.349
把它变成了一个不能前进的
And turns it into one
that does not go ahead

79
00:04:11.349 --> 00:04:13.819
创建原型链的整个新类。
create a whole new class
of the prototype chain.

80
00:04:13.819 --> 00:04:17.050
我们在前面的一个例子中看到，这可能是有问题的，
We saw in that one example earlier
that that can be problematic,

81
00:04:17.050 --> 00:04:19.529
因为还记得我们有那个点的时候，它在一个函数内部，
because remember when we had that
point and it was inside of a function,

82
00:04:19.529 --> 00:04:22.740
我们有这些原型链，但事情并不顺利？
and we had these prototype chains and
things didn't go well?

83
00:04:22.740 --> 00:04:26.004
对，我们最终拍摄了800毫秒或者
Right, we ended up shooting
up to 800 milliseconds or

84
00:04:26.004 --> 00:04:28.730
差不多是九个吧。
something like that compared to nine.

85
00:04:28.730 --> 00:04:32.363
对，这将帮助你避免某些时候的这种情况。
Right, this will help you avoid
some of that some of the time.

86
00:04:32.363 --> 00:04:36.069
现在，我不认为它会有很大的影响，但这就是为什么你要测量。
Right now,I don't think it'll have a big
effect but that's why you measure.

87
00:04:36.069 --> 00:04:38.300
但反应16奠定了基础
But react 16 lays the foundation for

88
00:04:38.300 --> 00:04:43.079
这实际上是为了更快，我只是不知道它是否真的已经发货了。
this actually to be faster, I just don't
know if that is actually shipped yet.

89
00:04:43.079 --> 00:04:46.389
但如果你以后再看这个，这可能都是真的，我说的一切都是真的。
But if you're watching this later, this
could all be true, everything I'm saying.

90
00:04:46.389 --> 00:04:53.819
如果组件具有像Babble插件那样的状态，则绝对没有任何内容。
And if a component has state like the
Babble plugin does, absolutely nothing.

91
00:04:53.819 --> 00:04:55.689
因此在您现有的代码上是安全的。
So it's safe on your existing code.

92
00:04:55.689 --> 00:04:57.480
我用了一个过渡。
I used one transition.

93
00:04:57.480 --> 00:04:59.060
所以这很酷
So it's cool,

94
00:04:59.060 --> 00:05:03.790
因为您的代码在执行时可能会变得更快，对吧。
because again your code could potentially
become faster at execution time, right.

95
00:05:03.790 --> 00:05:06.569
我们总是考虑编译时间，通过线路发送的大小，但是
We always think about compile time,
the size of sending over a wire, but

96
00:05:06.569 --> 00:05:09.939
此外，还必须对代码进行解析、编译和执行。
also that code has to be parsed and
compiled and executed.

97
00:05:09.939 --> 00:05:11.509
如果我们能让代码更快
And if we can make that code faster,

98
00:05:11.509 --> 00:05:13.800
这甚至不是JavaScript可以让它更快的东西。
that's not even a JavaScript
thing that will make it faster.

99
00:05:13.800 --> 00:05:17.939
这是一个反应的东西，会让它更快。
That's a react thing
that will make it faster.

100
00:05:17.939 --> 00:05:21.600
另一个，这是一种接近和亲爱的我们的心是转化或
Another one, this is kind of near and
dear to our hearts is transform or

101
00:05:21.600 --> 00:05:23.670
反应内联元素。
react inline elements.

102
00:05:23.670 --> 00:05:26.410
那么这是什么？为什么这么快？
So what is this and why is it fast?

103
00:05:26.410 --> 00:05:30.019
它将沿着这些路线进行一些事情，这就是发生的事情。
It'll take something along those lines,
and this is what happens.

104
00:05:30.019 --> 00:05:33.500
你输入这个，因为JSX不是真的，我打出来要打破它给你，它是假的。
You type this, because jsx isn't real,
I hit to break it to you, it's fake.

105
00:05:33.500 --> 00:05:36.470
你通过Babble运行它，然后这个从另一端出来。
You run it through babble and
this comes out the other end.

106
00:05:36.470 --> 00:05:40.509
它有一个我们调用的函数，我们在div传递它，className重要和
It has a function that we call,
we pass it at div, className important and

107
00:05:40.509 --> 00:05:41.509
你好世界。
Hello World.

108
00:05:41.509 --> 00:05:44.110
这些都不是动态的，对吧。
None of these are dynamic, right.

109
00:05:44.110 --> 00:05:46.240
我不需要重复调用这个函数
I don't need to call this
function repeatedly and

110
00:05:46.240 --> 00:05:49.509
使用相同的对象在div中传递它，并
pass it in a div with the same object and

111
00:05:49.509 --> 00:05:52.790
同样的字符串，对吧，如果我们只是把它变成h1或者别的什么。
the same string in it, right,
if we're just making it h1 or whatever.

112
00:05:52.790 --> 00:05:56.379
那么什么会比重复调用这个函数更快呢。
So what would be faster than
calling this function repeatedly.

113
00:05:57.740 --> 00:05:58.540
现在都在一起了。
All together now.

114
00:06:00.199 --> 00:06:01.439
什么比调用函数更快？
What's faster than calling a function?

115
00:06:02.670 --> 00:06:03.689
不调用函数，对吧。
Not calling a function, right.

116
00:06:03.689 --> 00:06:07.160
所以我实际上会把它变成这些非常有压力的物体。
So I'll actually just turn it into
these very stressful objects.

117
00:06:07.160 --> 00:06:08.569
但这不是函数。
But this is not a function.

118
00:06:08.569 --> 00:06:10.240
并且不调用函数更快。
And not calling a function is faster.

119
00:06:10.240 --> 00:06:13.089
即使对象使您感到压力，这也是您的编译输出。
Even if the object stresses you out,
this is your complied output.

120
00:06:13.089 --> 00:06:16.500
你永远不用看它，一切都会好起来的。
You never have to look at it,
it's going to be okay.

121
00:06:16.500 --> 00:06:19.490
这样我们就可以避免调用一堆函数，而只需输出。
So we can avoid calling a bunch
of functions and just turn out.

122
00:06:19.490 --> 00:06:21.550
无论如何，这就是函数的结果。
This is what would have come
out of the function anyway.

123
00:06:21.550 --> 00:06:24.519
让我们在构建时在计算机上进行编译，
Let's do a compile time on
our computers as we build,

124
00:06:24.519 --> 00:06:28.310
而不是发送功能给我们所有的用户，让他们重复这样做。
rather than sending the function to all of
our users to make them repeatedly do it.

125
00:06:28.310 --> 00:06:32.290
好的，我们现在就做一次，我们会把它发给所有人，没事的，
Right, we'll just do it once now, we'll
send it off to all of them, it's fine,

126
00:06:32.290 --> 00:06:33.470
大家都很开心。
everyone's happy.

127
00:06:33.470 --> 00:06:37.550
我们在花哨的电脑上付款，这只是一纳秒的时间。
We pay on our fancy computers,
it's a nanosecond of time.

128
00:06:37.550 --> 00:06:40.730
他们从不支付那段时间，因为它一遍又一遍地重现，对吗？
They never pay that time as it
rerenders over and over again, right?

129
00:06:40.730 --> 00:06:42.449
很多时候这个构建没有考虑到
A lot of times this build
wasn't thinking about the fact

130
00:06:42.449 --> 00:06:44.470
我们事先编译JavaScript，
that we compile our JavaScript beforehand,

131
00:06:44.470 --> 00:06:48.139
允许我们做一些真正强大的事情，让我们的用户受益。
allows us to do some really powerful
things that benefit our users.

132
00:06:48.139 --> 00:06:50.641
酷毙了。
Cool.

133
00:06:50.641 --> 00:06:53.800
不做某事比做它快，如果你不得不做，
Not doing something is faster than
doing it, and if you have to do it,

134
00:06:53.800 --> 00:06:57.659
您还不如在构建时在您的计算机上只做一次。
you might as well only do it once,
at build time, on your computer.

135
00:06:57.659 --> 00:07:02.259
实际上，从那个插件中出来的东西实际上比那个稍微恶心一点。
What actually comes out of that plugin is
actually a little bit grosser than that.

136
00:07:02.259 --> 00:07:06.100
这是真的发生的事情，但它是好的。
This is really what happens but it's fine.

137
00:07:08.600 --> 00:07:11.269
就像发生过一次一样，很酷，别担心，永远不要看那张幻灯片
Like it happens once, it's cool,
don't worry, don't ever look at that slide

138
00:07:11.269 --> 00:07:13.502
再说一次，我们只是想让你相信这件事没有发生。
again, we're just gonna make
you believe it didn't happen.

139
00:07:13.502 --> 00:07:14.029
&gt；&gt；[笑]
&gt;&gt; [LAUGH]

140
00:07:14.029 --> 00:07:14.615
&gt；&gt；steve：最后
&gt;&gt; Steve: And finally

141
00:07:14.615 --> 00:07:18.896
plugin-Transform-React-Constant-Elements，类似于Reaction，
plugin-transform-react-constant -elements,
and like these exist for react,

142
00:07:18.896 --> 00:07:23.480
如果你是一个棱角分明的用户，一个用户，你就会有这样的东西存在。
if you're an Angular user, an user, there
are things that exist like this for you.

143
00:07:23.480 --> 00:07:25.800
我只是没有资格谈论他们，
I'm just not qualified
to speak about them,

144
00:07:25.800 --> 00:07:28.495
这里有些部分是不会改变的。
which is there are parts
in here that don't change.

145
00:07:28.495 --> 00:07:31.589
还记得我们看到范围实际上可以产生不同吗？
Remember how we saw scoping can
actually make a difference?

146
00:07:31.589 --> 00:07:34.279
我们看到了惰性解析与急切解析。
We saw lazy parsing versus eager parsing.

147
00:07:34.279 --> 00:07:38.170
我们看到了，是的，只是把东西放在错误的范围内可能会导致
We saw that, yeah, just having stuff
in the wrong scope can cause these big

148
00:07:38.170 --> 00:07:40.500
问题，就像我们每次调用render一样。
problems and
like every time we call render.

149
00:07:40.500 --> 00:07:44.829
再次，请记住h1并不是真正的h1，它是一个react。create元素h1，
Again, remember that h1 isn't really
an h1, it's a react.create element h1,

150
00:07:44.829 --> 00:07:48.300
不管里面有什么属性，不管字符串是什么。
whatever properties are in there,
whatever the string is.

151
00:07:48.300 --> 00:07:52.480
这是我们每次调用render时都会调用的一个函数。
And that's a function that we're calling
every single time we call render.

152
00:07:52.480 --> 00:07:53.230
它会改变吗？
Is it ever changing?

153
00:07:54.480 --> 00:07:55.759
我们为什么要这么做？
Why are we doing this?

154
00:07:55.759 --> 00:07:56.259
对吧？
Right?

155
00:07:56.259 --> 00:08:00.389
因为它对我们来说很容易编写，有时代码也很容易
Because it's easy for us to write,
and sometimes code that is easily

156
00:08:00.389 --> 00:08:03.480
可读的你，未来的你谁是有史以来最重要的开发者。
readable by you, future you who is
the most important developer ever.

157
00:08:03.480 --> 00:08:05.879
如果你受到责备，那总是六个月前的你。
If you ever get blamed something,
it's always you six months ago.

158
00:08:05.879 --> 00:08:07.709
你知道现在的你和
You know about the difference
between current you and

159
00:08:07.709 --> 00:08:09.670
未来的你，以及你的未来有多重要。
future you, and
how important future you is.

160
00:08:09.670 --> 00:08:12.430
写可写的代码是很重要的，对吧。
It's important to write writable code,
right.

161
00:08:12.430 --> 00:08:16.279
我们可以将其提取出来，并进行一系列微优化以使其更快，或者
We could extract this and do a bunch of
micro-optimizations to make it faster, or

162
00:08:16.279 --> 00:08:18.959
我们可以让我们的工具基本上在构建时为我们提升那些东西。
we can have our tools just basically
hoist that stuff up for us at build time.

163
00:08:18.959 --> 00:08:23.310
好的，现在我们只使用ref和ref2，即
All right so now we're just
gonna use ref and ref2, that

164
00:08:23.310 --> 00:08:27.048
将运行这些函数一次，如果您想象您开始组合所有这些函数，
will run those functions once, and if you
imagine you start combining all of these,

165
00:08:27.048 --> 00:08:32.440
他们开始堆积在彼此之上与他们的增量收益。
they start to pile on top of each
other with their incremental gains.

166
00:08:32.440 --> 00:08:33.850
好的，现在我们有了这些函数，但是
Okay, now we have these functions, but

167
00:08:33.850 --> 00:08:37.220
如果我们用另一个插件把它们变成对象，对吗？
what if we turn those into the objects
with the other plugin, right?

168
00:08:37.220 --> 00:08:40.509
我们可以开始做更多的事情，实际上我们不需要做任何事情。
We could begin to do more, and
we don't actually have to do anything.

169
00:08:40.509 --> 00:08:43.940
我们只是安装了一堆插件，然后让其他人的辛勤工作为我们做这件事。
We just install a bunch of plugins and
let other people's hard work do it for us.

170
00:08:43.940 --> 00:08:46.419
我们受益是因为我们可以保持代码的可读性。
We benefit because we get
to keep readable code.

171
00:08:46.419 --> 00:08:49.409
我们的用户受益，因为他们没有执行他们不需要的代码。
Our users benefit because they're not
executing code they don't need to.
