WEBVTT

1
00:00:00.560 --> 00:00:03.355
>> 扬声器 2: 它是否只包含到最接近的悬念 ?
&gt;&gt; Speaker 2: Does it just bubble
up to the nearest suspense?

2
00:00:03.355 --> 00:00:05.115
> > Brian Holt: Mm - hm，所以如果你有一个以上的话，
&gt;&gt; Brian Holt: Mm-hm, so
if you had one above that,

3
00:00:05.115 --> 00:00:07.104
它会击中最接近的一个
it would hit the first closest one, yeah.

4
00:00:10.214 --> 00:00:15.028
> > Brian Holt: 我认为如果你没有，我就会崩溃，我不确定。
&gt;&gt; Brian Holt: And I think it just crashes
if you don't have one, I'm not sure.

5
00:00:18.390 --> 00:00:22.632
>> Brian Holt: 所以 Facebook 说他们在到处使用悬念。
&gt;&gt; Brian Holt: So Facebook says that
they're using suspense everywhere.

6
00:00:22.632 --> 00:00:23.407
嗯。
Yeah.

7
00:00:23.407 --> 00:00:27.823
>演讲者 3: 与 Parcel 相比，有什么不同吗 ?
&gt;&gt; Speaker 3: Is there anything different
about using this with Parcel versus

8
00:00:27.823 --> 00:00:28.565
Webpack?
Webpack?

9
00:00:28.565 --> 00:00:30.617
>> Brian Holt: Nope，他们的工作方式相同。
&gt;&gt; Brian Holt: Nope,
they work the same way.

10
00:00:30.617 --> 00:00:32.537
是啊他们俩都是
Yeah, so they both look for

11
00:00:32.537 --> 00:00:36.435
该导入关键字， >> Brian Holt: And
this import keyword,
&gt;&gt; Brian Holt: And

12
00:00:36.435 --> 00:00:40.200
他们会在那个点上巧妙地分开他们都知道怎么做
they'll split intelligently on that
point and they both know how to do it.

13
00:00:41.469 --> 00:00:44.320
也许机器的运作方式有点不同
Maybe mechanically it works
a little bit differently, but

14
00:00:44.320 --> 00:00:47.006
懒惰来自 React ，懒惰知道怎么处理。
lazy comes from React and so
lazy knows how to handle it.

15
00:00:51.439 --> 00:00:54.640
>> Brian Holt: 与累积情况相同。
&gt;&gt; Brian Holt: Same with rollup as well.

16
00:00:54.640 --> 00:00:56.000
这就是代码分割。
So that's code splitting.

17
00:00:56.000 --> 00:00:58.250
没有比这更多的了
There's not a lot more to it than that.

18
00:00:58.250 --> 00:01:02.929
这是一种相当简单的技术，尤其是懒的，懒惰的，悬念的。
It's a fairly easy technique, especially
with lazy now, lazy and suspense.

19
00:01:02.929 --> 00:01:04.670
如果你看这个课程的 V1 和 V2
If you watch V1 and V2 of this course,

20
00:01:04.670 --> 00:01:06.424
这就更难做了
this used to be a lot
more difficult to do.

21
00:01:06.424 --> 00:01:09.751
而且它越来越容易了，这很酷。
[LAUGH] And it's just getting easier,
which is cool.

22
00:01:13.519 --> 00:01:17.281
>> Brian Holt: 好的，这就是代码分割的结尾。
&gt;&gt; Brian Holt: Okay, so
that's the end of code splitting.

23
00:01:17.281 --> 00:01:19.650
所以我要把雷波恢复得真快
So I'm gonna go reset
my repo really quick.

24
00:01:22.668 --> 00:01:24.239
> > Brian Holt: 我在这里会这样做，相反。
&gt;&gt; Brian Holt: I'll do that in here,
rather.

25
00:01:28.757 --> 00:01:33.875
> > Brian Holt: 所以我要说 git reset HEAD --hard，
&gt;&gt; Brian Holt: So
I'm gonna say git reset HEAD --hard,

26
00:01:33.875 --> 00:01:38.433
然后我就会说它是干净的
and then I'm gonna say git clean -f.

27
00:01:38.433 --> 00:01:42.182
然后我会说 npm 的安装
And then I'm gonna say npm install.

28
00:01:42.182 --> 00:01:45.697
再次，如果要检查该输出，那么将调用该可用分支
Again, if you want to check that out, the
branch of that that's available is called

29
00:01:45.697 --> 00:01:47.539
代码分割，它在 GitHub 存储库上。
code splitting and
it is on the GitHub repo.
