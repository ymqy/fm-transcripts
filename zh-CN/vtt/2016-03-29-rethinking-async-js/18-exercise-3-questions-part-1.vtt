WEBVTT

1
00:00:00.000 --> 00:00:04.099
[音乐]
[MUSIC]

2
00:00:04.099 --> 00:00:05.424
&GT；&GT；Kyle：关于练习三的问题。
&gt;&gt; Kyle: Questions about exercise three.

3
00:00:05.424 --> 00:00:08.535
是吗？&gt；&gt；扬声器2：好吧，
Yes? &gt;&gt; Speaker 2: Well,

4
00:00:08.535 --> 00:00:12.410
我有p1然后函数，和
I have p1 then functions, and

5
00:00:12.410 --> 00:00:17.449
然后我把它放在选项下面。
then I have that under the options.

6
00:00:17.449 --> 00:00:25.920
我[INAUDIBLE]。
I [INAUDIBLE].

7
00:00:25.920 --> 00:00:28.846
&gt；&gt；Kyle：那么，你是说把圆点放在这里？
&gt;&gt; Kyle: So, you're saying put the dot then here?

8
00:00:28.846 --> 00:00:30.821
&gt；&gt；扬声器2：我把它放在[INAUDIBLE]下。
&gt;&gt; Speaker 2: I put it under [INAUDIBLE].

9
00:00:30.821 --> 00:00:31.513
&GT；&GT；Kyle：你是这个意思吗？
&gt;&gt; Kyle: Is that what you're saying?

10
00:00:31.513 --> 00:00:34.970
&gt；&gt；扬声器2：[听不见]像这样吗？
&gt;&gt; Speaker 2: [INAUDIBLE] Like that?

11
00:00:34.970 --> 00:00:40.250
[听不见]那么功能，没有，
[INAUDIBLE] Then functions, no,

12
00:00:40.250 --> 00:00:47.517
这就发生了，函数输出。&gt；&gt；Kyle：你是
this happened then, functions output. &gt;&gt; Kyle: You're

13
00:00:47.517 --> 00:00:50.119
说你把这个拿出来了。&gt；&gt；扬声器2：是的。
saying you took this one out. &gt;&gt; Speaker 2: Yes.

14
00:00:50.119 --> 00:00:51.756
&gt；&gt；Kyle：您确实输出了文本。
&gt;&gt; Kyle: You did output text.

15
00:00:51.756 --> 00:00:52.646
&gt；&gt；扬声器2：是的，并且
&gt;&gt; Speaker 2: Yes, and

16
00:00:52.646 --> 00:00:54.755
然后返回p2。&gt；&gt；Kyle：和
then return p2. &gt;&gt; Kyle: And

17
00:00:54.755 --> 00:00:59.920
然后返回p2，对吗？&gt；&gt；扬声器2：是的。
then return p2 is that correct? &gt;&gt; Speaker 2: Yeah.

18
00:00:59.920 --> 00:01:01.403
&gt；&gt；Kyle：有效的解决方案，但是
&gt;&gt; Kyle: Valid solution, but

19
00:01:01.403 --> 00:01:04.209
这并不是以承诺链为导向的。
that's not as promise chain oriented.

20
00:01:06.310 --> 00:01:11.409
我更喜欢保持输出和链接在不同的地方。
I would prefer to keep the output and the chaining in separate places.

21
00:01:12.489 --> 00:01:14.030
分别进行推理的步骤。
Separate steps to reason about.

22
00:01:15.659 --> 00:01:19.590
这将在功能上工作，但这不是我个人喜欢的风格。
This will functionally work, but this isn't the style I would personally prefer.

23
00:01:19.590 --> 00:01:24.180
我更喜欢步骤更明确地分开的样式。
I prefer a style where the steps are more explicitly separate.

24
00:01:24.180 --> 00:01:27.539
你要考虑一下，这只是一般的编程实践。
You wanna think about, this is just general programming practice.

25
00:01:27.539 --> 00:01:30.000
功能应该是尽可能单一的用途。
Functions should be as single purpose as possible.

26
00:01:31.099 --> 00:01:34.479
所以，不要让一个函数做两件完全不同的事情，
So, don't make a function that does two entirely separate things,

27
00:01:34.479 --> 00:01:39.189
输出前一个响应，并对另一件事进行排序。
outputting the response from a previous one, and sequencing in yet another thing.

28
00:01:39.189 --> 00:01:43.890
这两个任务是不同的关注点，在我看来，它们属于，
Those two tasks are separate concerns, and they belong, in my opinion,

29
00:01:43.890 --> 00:01:48.900
链条中的一个单独的步骤。&gt；&gt；扬声器3：那么，
a separate steps in the chain. &gt;&gt; Speaker 3: So,

30
00:01:48.900 --> 00:01:51.633
你需要解析逗号拼接？
you need to resolve the comma splice?

31
00:01:51.633 --> 00:01:55.310
然后你有两个THEN语句
And then you have two then statements for

32
00:01:55.310 --> 00:01:57.960
P1有两次结果吗？&gt；&gt；Kyle：否。
p1 there to result twice? &gt;&gt; Kyle: No.

33
00:01:59.349 --> 00:02:04.700
问题是，如果我说在我的程序中的其他地方，如果我有另一个p1，
The question was, if I said somewhere else in my program, if I had another p1.,

34
00:02:04.700 --> 00:02:09.819
例如，然后是logValue。
then logValue, for example.

35
00:02:09.819 --> 00:02:12.219
所以现在我有两个p1.then‘s。
So now I have two p1.then's.

36
00:02:12.219 --> 00:02:14.728
我在同一个承诺上注册了两个处理者。
I register two then handlers on the same promise.

37
00:02:16.170 --> 00:02:19.860
这和下链不是一回事，因为这是一个不同的承诺。
That's not the same thing as off the chain, cuz this is a different promise.

38
00:02:19.860 --> 00:02:25.560
但在这里，我有两个当时的操纵者在同一个承诺中注册。
But here, I have two then's handlers registered in the same promise.

39
00:02:25.560 --> 00:02:27.560
解析需要被调用两次吗？
Does resolve need to get called twice?

40
00:02:27.560 --> 00:02:28.719
绝对不行。
Absolutely not.

41
00:02:28.719 --> 00:02:32.329
调用Resolve一次，承诺就会解析为该值
You call resolve once, and the promise becomes resolved to that value

42
00:02:32.329 --> 00:02:37.120
立即且永远不变，无论您是事先观察还是
immediately and forever immutable, no matter whether you observe beforehand or

43
00:02:37.120 --> 00:02:39.509
在手之后，不管你观察了多少次。
after hand, and no matter how many times you observe it.

44
00:02:39.509 --> 00:02:40.680
你还是会得到相同的值。
You're still going to get that same value.

45
00:02:40.680 --> 00:02:42.539
就像我们的屁股一样。
It's exactly like with our thunks.

46
00:02:42.539 --> 00:02:46.710
例如，每次我们调用thunk，我们都会得到相同的25值。
Every time we call the thunk, we're gonna get that same 25 value out, for example.

47
00:02:46.710 --> 00:02:51.539
因此，在这里，只有一个解析，并且日志值和输出都将被调用
So here, only one resolve, and both log value and output would get called with

48
00:02:51.539 --> 00:02:55.789
这个值，以及我们称为p1.then的任何未来时间。
that value, as well as any future times that we called p1.then.

49
00:02:55.789 --> 00:02:57.819
是吗？&gt；&gt；扬声器4：我有点困惑
Yes? &gt;&gt; Speaker 4: I'm a little confused about

50
00:02:57.819 --> 00:03:00.409
输出返回的内容如下
what the output returns so

51
00:03:00.409 --> 00:03:04.060
你可以把它锁起来。&gt；&gt；Kyle：每次使用Then方法时，
that you can chain it. &gt;&gt; Kyle: Every time the then method,

52
00:03:04.060 --> 00:03:06.770
这涉及到了一些实现细节。
this is getting a little bit into the implementation details.

53
00:03:06.770 --> 00:03:09.409
每次调用Then方法时，
Every single time that then method is called,

54
00:03:09.409 --> 00:03:11.413
实际上，它确实回报了自己的承诺。
it actually does return its own promise.

55
00:03:13.479 --> 00:03:16.460
所以，当我在37号线上链条的时候，
So, when I chain right here on line 37,

56
00:03:16.460 --> 00:03:20.650
我正在链接一个由该方法创建并返回的新承诺。
I am chaining off a new promise that was created and returned by that method.

57
00:03:21.819 --> 00:03:27.310
默认情况下，该新承诺设置为立即解决。
That new promise is set to, by default, be resolved immediately.

58
00:03:27.310 --> 00:03:32.000
除非上一步返回另一个承诺，在这种情况下它有点劫持。
Unless the previous step returns another promise, in which case it sort of hijacks.

59
00:03:32.000 --> 00:03:36.030
这就是我说的掩护下的复杂的东西，看起来很简单
That's that complicated under the cover stuff that I said, seems simple and

60
00:03:36.030 --> 00:03:37.539
实际上相当复杂。
it's actually pretty complex.

61
00:03:37.539 --> 00:03:39.129
这部分已经为你处理好了。
That part's handled for you.

62
00:03:39.129 --> 00:03:41.530
因此，这将自动链接到一个新的
So, this is automatically chaining off of a new

63
00:03:41.530 --> 00:03:43.960
我保证。&gt；&gt；扬声器4：那么，
promise. &gt;&gt; Speaker 4: So,

64
00:03:43.960 --> 00:03:47.030
该函数的输入是什么？
what would the input to that function be?

65
00:03:47.030 --> 00:03:49.920
嗯，它将是-&gt；&gt；Kyle：因为我们不退货
Well, it would be- &gt;&gt; Kyle: Because we don't return anything

66
00:03:49.920 --> 00:03:50.469
从输出。
from output.

67
00:03:52.150 --> 00:03:56.944
如果我返回类似于，你好，
If I returned something like, hello there,

68
00:03:56.944 --> 00:04:01.504
我从承诺中返回的价值
that value that I'm returning from that promise

69
00:04:01.504 --> 00:04:05.960
会自动通过管道进入并进入这里是一个论点。
would automatically get piped in and come in here is an argument.

70
00:04:05.960 --> 00:04:09.307
但是因为我没有从输出中返回任何东西，所以什么都不会发生。
But since I'm not returning anything from output, nothing goes.

71
00:04:09.307 --> 00:04:10.264
&gt；&gt；扬声器4：所以它是未定义的？
&gt;&gt; Speaker 4: So it's undefined?

72
00:04:10.264 --> 00:04:11.397
&GT；&GT；Kyle：嗯，它是一样的，
&gt;&gt; Kyle: Well, it's the same,

73
00:04:11.397 --> 00:04:15.146
所有没有Return的JavaScript函数都与Return相同
all JavaScript functions that don't have a return are the same thing as return

74
00:04:15.146 --> 00:04:15.789
未定义。
undefined.

75
00:04:18.779 --> 00:04:22.560
是吗？&GT；&GT；扬声器5：他们在问，
Yeah? &gt;&gt; Speaker 5: They're asking,

76
00:04:22.560 --> 00:04:25.180
是函数或传递给。然后是值
is the function or passing to .then the value

77
00:04:25.180 --> 00:04:29.500
结果呢？&gt；&gt；Kyle：没有。
of result? &gt;&gt; Kyle: No.

78
00:04:30.800 --> 00:04:32.389
我不明白这个问题，但是
I don't understand the question, but

79
00:04:32.389 --> 00:04:37.463
我知道答案是否定的。&gt；&gt；扬声器5：那么，我认为他是
I know that that it's the answer is no. &gt;&gt; Speaker 5: So, I think he is

80
00:04:37.463 --> 00:04:41.906
问输出，它的值是多少？&gt；&gt；Kyle：我需要知道行号
asking output, what is the value of that? &gt;&gt; Kyle: I need to know a line number

81
00:04:41.906 --> 00:04:44.843
有人问起的事情。&gt；&gt；扬声器5：我36岁。
that somebody is asking about. &gt;&gt; Speaker 5: I'm 36.

82
00:04:44.843 --> 00:04:45.360
&gt；&gt；Kyle：第36行。
&gt;&gt; Kyle: Line 36.

83
00:04:45.360 --> 00:04:47.252
什么的价值是什么？
What is the value of what?

84
00:04:47.252 --> 00:04:49.843
输出函数的值，或
The value of the output function, or

85
00:04:49.843 --> 00:04:53.930
.Then函数的值？&gt；&gt；扬声器5：解析在哪里
the value of the .then function? &gt;&gt; Speaker 5: Where is the resolve

86
00:04:53.930 --> 00:04:57.889
定义？&gt；&gt；Kyle：此处定义了解析。
defined? &gt;&gt; Kyle: Resolve is defined here.

87
00:04:57.889 --> 00:05:02.079
它通过Promise机制传递到我们的Promise构造函数中。
It's passed into our promise constructor by the promise mechanism.

88
00:05:02.079 --> 00:05:03.209
我们要做的就是打电话给它。
All we have to do is call it.

89
00:05:10.269 --> 00:05:12.497
&gt；&gt；Speaker 6：前面的示例，其中
&gt;&gt; Speaker 6: The previous example where

90
00:05:12.497 --> 00:05:17.110
你有一个p1，然后用log记录结果。&gt；&gt；Kyle：嗯哼。
you had a p1.then with log on the result. &gt;&gt; Kyle: Uh-huh.

91
00:05:17.110 --> 00:05:17.961
&GT；&GT；演讲者6：顺序是什么？
&gt;&gt; Speaker 6: What's the order?

92
00:05:17.961 --> 00:05:21.125
它是先执行输出还是
Would it execute output first or

93
00:05:21.125 --> 00:05:24.850
先登录？&gt；&gt；Kyle：订单将是
log first? &gt;&gt; Kyle: The order will be

94
00:05:24.850 --> 00:05:28.750
如果你有两个不同的，那么相同的承诺，这就是我们在这里。
if you have two different then's on the same promise, which is what we have here.

95
00:05:29.850 --> 00:05:34.310
请记住，第39行不再是。然后在p1上。
Keep in mind line 39 is not a .then on p1 anymore.

96
00:05:34.310 --> 00:05:36.389
这是完全不同的承诺。
It's on a different promise entirely.

97
00:05:36.389 --> 00:05:40.659
但是第38行和第35行是在同一个承诺上。
But line 38 and line 35 are then's on the same promise.

98
00:05:40.659 --> 00:05:43.800
在这些情况下，他们首先进入，首先登记，执行顺序。
In those cases, they go in first, registered first, executed order.

99
00:05:45.939 --> 00:05:49.495
不过，你真的不应该关注这种细节。
You really should not pay any attention to that sort of detail, though.

100
00:05:49.495 --> 00:05:51.149
&gt；&gt；扬声器6：[笑]
&gt;&gt; Speaker 6: [LAUGH]

101
00:05:51.149 --> 00:05:51.899
&GT；&GT；Kyle：你真的，
&gt;&gt; Kyle: You really, really,

102
00:05:51.899 --> 00:05:54.120
真的绝对不应该。
really absolutely should not.

103
00:05:54.120 --> 00:05:57.899
关于某物在承诺上登记的订单的原因，
Reason about what order something was registered on the promise in,

104
00:05:57.899 --> 00:06:00.930
并不是说它不可靠，它是，这是由规范保证的。
not that it's not reliable, it is, that's guaranteed by the spec.

105
00:06:00.930 --> 00:06:03.360
这是糟糕的编程实践。
This is terrible programming practice.

106
00:06:03.360 --> 00:06:07.300
这就回到了我们正在讨论的那些前函数式编程概念
That's way back to those pre functional programming concepts that we're talking

107
00:06:07.300 --> 00:06:10.290
关于你不能理解你的系统状态的地方，
about where you can't understand the state of your system,

108
00:06:10.290 --> 00:06:11.680
因为你不是一下子就看清了一切。
cuz you don't see it all at once.

109
00:06:12.730 --> 00:06:18.500
所以，承诺邀请你接受你正在处理的想法
So, promises invite you to embrace the idea that you are dealing with

110
00:06:18.500 --> 00:06:20.970
你不应该做的独立的事情。
independent things that you shouldn't.

111
00:06:20.970 --> 00:06:26.139
不应在分辨率之间建立依赖关系
You should not build dependency between the resolution

112
00:06:26.139 --> 00:06:29.882
如果你能避免的话。
of promise handlers if you can avoid it.

113
00:06:35.334 --> 00:06:36.425
&gt；&gt；扬声器6：就在那里。
&gt;&gt; Speaker 6: Right there.

114
00:06:36.425 --> 00:06:39.432
他在跟进他的问题，但他，我不知道我们从哪里经过
He's kind of following up on his question, but he's, I don't see where we pass

115
00:06:39.432 --> 00:06:42.829
将解决价值转化为承诺。&gt；&gt；扬声器5：这给了我们-
the resolve value into the promise. &gt;&gt; Speaker 5: That gives us-

116
00:06:42.829 --> 00:06:44.170
&gt；&gt；Kyle：解决值，
&gt;&gt; Kyle: The resolve value,

117
00:06:44.170 --> 00:06:47.069
我想也许我只是，也许只是，
I think maybe I'm just, it's maybe being just,

118
00:06:48.990 --> 00:06:51.480
很难理解这些问题被问的方式。
it's hard to understand the way the questions are being asked.

119
00:06:51.480 --> 00:06:57.250
我认为实际上被问到的是你没有在第24行看到这个事实，
I think what's actually being asked is you not seeing the fact that this on line 24,

120
00:06:57.250 --> 00:07:02.399
这个解析函数是我们假Ajax中的CB。
this resolve function is that CB up here in our fake AJAX.

121
00:07:02.399 --> 00:07:05.600
下面是我们调用result函数的地方
And down here is where we're calling the result function and

122
00:07:05.600 --> 00:07:09.899
正在传递文本。&gt；&gt；扬声器7：这就是输出。
passing text in. &gt;&gt; Speaker 7: And that is output.

123
00:07:11.670 --> 00:07:13.093
输出是函数？&gt；&gt；Kyle：否。
Output is a function? &gt;&gt; Kyle: No.

124
00:07:13.093 --> 00:07:13.956
&gt；&gt；扬声器7：不？
&gt;&gt; Speaker 7: No?

125
00:07:13.956 --> 00:07:18.269
凯尔：不，不。
&gt;&gt; Kyle: No, no, no, no, no.

126
00:07:18.269 --> 00:07:20.785
Resolve是传递给假Ajax的东西。
Resolve is the thing that's getting passed into fake Ajax.

127
00:07:23.973 --> 00:07:24.894
&gt；&gt；Kyle：不是输出。
&gt;&gt; Kyle: Not output.

128
00:07:24.894 --> 00:07:28.790
&gt；&gt；扬声器4：但是我们通过了
&gt;&gt; Speaker 4: But we're passing

129
00:07:28.790 --> 00:07:34.108
功能。&gt；&gt；扬声器2：函数
the function. &gt;&gt; Speaker 2: Function with

130
00:07:34.108 --> 00:07:39.500
响应和解决与响应。
the response and resolve with response.

131
00:07:39.500 --> 00:07:42.233
这更有意义吗？
Does that make more sense?

132
00:07:42.233 --> 00:07:50.908
在第24行？&gt；&gt；Kyle：这样会不会更容易
On line 24? &gt;&gt; Kyle: Does that make it easier to

133
00:07:50.908 --> 00:07:57.240
明白吗？&gt；&gt；扬声器4：和
understand? &gt;&gt; Speaker 4: And

134
00:07:57.240 --> 00:08:01.259
结果未输出。&gt；&gt；Kyle：不，结果来自承诺
result is not output. &gt;&gt; Kyle: No, result comes from the promise

135
00:08:01.259 --> 00:08:06.232
构造函数。&gt；&gt；Kyle：这
constructor. &gt;&gt; Kyle: This

136
00:08:06.232 --> 00:08:08.250
内置于JavaScript中。&gt；&gt；扬声器4：是的。
is built into JavaScript. &gt;&gt; Speaker 4: Yep.

137
00:08:08.250 --> 00:08:09.740
&gt；&gt；Kyle：它产生一个函数，我们
&gt;&gt; Kyle: It produces a function that we

138
00:08:09.740 --> 00:08:10.790
碰巧呼叫解决。
happen to call resolve.

139
00:08:10.790 --> 00:08:12.970
如果我们想的话我们可以叫它Fubar。&gt；&gt；扬声器4：是的。
We could call it Fubar if we wanted. &gt;&gt; Speaker 4: Yep.

140
00:08:12.970 --> 00:08:14.370
&gt；&gt；Kyle：这来自JavaScript，
&gt;&gt; Kyle: That's coming from JavaScript,

141
00:08:14.370 --> 00:08:16.279
不是从我们这里。&gt；&gt；扬声器4：好的。
not from us. &gt;&gt; Speaker 4: Okay.

142
00:08:16.279 --> 00:08:18.290
&gt；&gt；Kyle：正在将输出传递给
&gt;&gt; Kyle: Output is being passed to

143
00:08:18.290 --> 00:08:21.740
Then函数，它发生在完全不同的部分-
the then function, which is happening at an entirely different part of the-

144
00:08:22.740 --> 00:08:23.740
&gt；&gt；扬声器5：我认为他们可能
&gt;&gt; Speaker 5: I think they might

145
00:08:23.740 --> 00:08:26.629
迷失在承诺从何而来的想法上。
be getting lost on the idea of where promise comes from.

146
00:08:26.629 --> 00:08:29.259
和-&gt；&gt；Kyle：它内置在JavaScript中。
And- &gt;&gt; Kyle: It's built into JavaScript.

147
00:08:29.259 --> 00:08:30.410
&gt；&gt；扬声器5：对，我认为这是
&gt;&gt; Speaker 5: Right, I think that's

148
00:08:30.410 --> 00:08:35.200
他在这里被搞糊涂了。&gt；&gt；Kyle：I
where he's confused here. &gt;&gt; Kyle: I

149
00:08:35.200 --> 00:08:38.220
除了说它内置于JavaScript之外，我不知道还能说什么，
don't know what else to say other than to say it's built into JavaScript,

150
00:08:38.220 --> 00:08:42.539
这就是它的来源。&gt；&gt；扬声器5：ES 6。
that's where it comes from. &gt;&gt; Speaker 5: ES 6.

151
00:08:42.539 --> 00:08:43.740
&gt；&gt；Kyle：它是在ES 6中建造的。
&gt;&gt; Kyle: It's built in the ES 6.

152
00:08:43.740 --> 00:08:48.959
没错。&gt；&gt；Kyle：如果
That's correct. &gt;&gt; Kyle: If

153
00:08:48.959 --> 00:08:52.000
其中一个承诺行为不端并且失败了，它是不是整个流程都失败了？
one of the promises misbehaves and fails, does it fail the whole flow?

154
00:08:52.000 --> 00:08:55.990
是的，如果这里的p1以某种方式拒绝，
Yes, if p1 here were to somehow reject,

155
00:08:55.990 --> 00:09:00.669
然后这些处理程序中的每一个都不听拒绝。
then every one of these then handlers that does not listen to the reject.

156
00:09:00.669 --> 00:09:04.470
它们自动有一个隐含的拒绝处理程序，该处理程序只是简单地传播它
They automatically have an implied reject handler that just simply propagates it

157
00:09:04.470 --> 00:09:05.570
到下一步。
to the next step.

158
00:09:05.570 --> 00:09:08.610
所以，这种排斥会沿着链条向下传播。
So, that rejection would propagate all the way down the chain.

159
00:09:08.610 --> 00:09:10.830
因为我们从来不听拒绝，
Since we never listen for the rejection,

160
00:09:10.830 --> 00:09:13.720
它就会坐在那里等着被观察。
it would sort of just sit there waiting to be observed.

161
00:09:13.720 --> 00:09:17.289
它不是真的被吞噬了，它就在那里。
It's not really been swallowed, it's there.

162
00:09:17.289 --> 00:09:21.559
但我们不会传入拒绝处理程序来监听它。
But we are not passing in a rejection handler to listen for it.

163
00:09:21.559 --> 00:09:23.590
&gt；&gt；扬声器7：这是新的拒绝吗
&gt;&gt; Speaker 7: Is that a new rejection

164
00:09:23.590 --> 00:09:27.139
当它通过当时的传播时？&gt；&gt；Kyle：是的。
as it propagates through the then's? &gt;&gt; Kyle: Yes.

165
00:09:27.139 --> 00:09:28.210
&gt；&gt；扬声器7：所以每个人都会得到
&gt;&gt; Speaker 7: So each one will get

166
00:09:28.210 --> 00:09:30.370
一个新的。&gt；&gt；Kyle：是的，默认设置
a new one. &gt;&gt; Kyle: Yes, the default

167
00:09:30.370 --> 00:09:34.120
拒绝处理程序，因为我们没有传入任何拒绝处理程序。
rejection handler, because we're not passing in any rejection handlers.

168
00:09:34.120 --> 00:09:38.820
默认拒绝处理程序接收来自上一步骤的拒绝，并且
The default rejection handler receives the rejection from the previous step and

169
00:09:38.820 --> 00:09:41.570
拒收。&gt；&gt；扬声器7：使用相同的参数。
rejects. &gt;&gt; Speaker 7: With the same parameter.

170
00:09:41.570 --> 00:09:42.217
&gt；&gt；Kyle：相同的值。
&gt;&gt; Kyle: Same value.

171
00:09:42.217 --> 00:09:42.937
&gt；&gt；扬声器7：相同的值。
&gt;&gt; Speaker 7: Same value.

172
00:09:42.937 --> 00:09:43.437
好吧。
Okay.
