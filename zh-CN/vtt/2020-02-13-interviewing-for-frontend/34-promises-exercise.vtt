WEBVTT

1
00:00:00.940 --> 00:00:05.679
承诺，我们对承诺有什么了解 ?
Promises, what do we know about promises?

2
00:00:05.679 --> 00:00:09.560
我有一个很好的报价，我从 MDN 那里偷来的，我最喜欢的网站。
I actually have a good quote that I
stole from MDN, my favorite website.

3
00:00:11.089 --> 00:00:11.900
我引述的是甚么 ?
What is my quote?

4
00:00:11.900 --> 00:00:13.109
我们对承诺有什么了解 ?
What do we know about promises?

5
00:00:13.109 --> 00:00:13.609
有人告诉我
Someone tell me something.

6
00:00:18.655 --> 00:00:20.219
>> 将返回的将返回的值。
&gt;&gt; Someting that will
return with a future value.

7
00:00:20.219 --> 00:00:22.771
> > 嗯，我喜欢
&gt;&gt; Yeah, I like that.

8
00:00:22.771 --> 00:00:27.339
我将使用 MDN 定义，因为它比我能说的更好得多。
I'll use the MDN definition because it's
much better than anything I can say.

9
00:00:27.339 --> 00:00:29.254
我可以说一个承诺就是
I can say a promise is a proxy for

10
00:00:29.254 --> 00:00:33.404
在创建承诺时不一定知道的值。
value that's not necessarily known
when the promise is created.

11
00:00:33.404 --> 00:00:36.134
一个承诺就是，就是这样，
Which a promise is, it's exactly that,

12
00:00:36.134 --> 00:00:39.929
最终会有回报的
it's a promise to return
something eventually.

13
00:00:39.929 --> 00:00:40.640
你不知道
You don't know what.

14
00:00:40.640 --> 00:00:44.109
你不知道什么时候或者什么时候但你知道最终会发生什么
You don't know where or when, but
you know what happens eventually, so

15
00:00:44.109 --> 00:00:46.340
我们在这附近进行计划
we program around that.

16
00:00:46.340 --> 00:00:50.869
旧的处理价值，我们不知道它会是什么，但是
The old style of handling values that
we don't know what it's gonna be, but

17
00:00:50.869 --> 00:00:53.899
我们知道我们想让它最终回到旧学的回调
we know we want it to return eventually
would be using old school callbacks.

18
00:00:55.020 --> 00:00:58.781
因此，在回调函数中调用函数时，它会执行某些工作，然后
So in a callback you invoke a function,
it does some work and then whenever it's

19
00:00:58.781 --> 00:01:03.810
完成后，它会调用函数以传递该值或执行任何您想做的操作。
done, it calls back the function to pass
on that value or do whatever you wanna do.

20
00:01:03.810 --> 00:01:07.909
随着承诺的发明，我们现在可以将事物联系在一起，
With the invention of promises,
we can now chain things together and

21
00:01:07.909 --> 00:01:10.519
我不必每次都显式地调用回调。
I don't have to explicitly call
the callback every single time.

22
00:01:10.519 --> 00:01:12.390
我们可以把它链起来
We can just chain this together.

23
00:01:12.390 --> 00:01:15.683
希望在这个阶段的 JavaScript 工程中
Hopefully, not hopefully,
at this stage in JavaScript engineering or

24
00:01:15.683 --> 00:01:18.442
你应该知道什么是什么承诺。
UI engineering you should
probably know what promises are.

25
00:01:18.442 --> 00:01:22.015
你以更清洁的方式了解他们，就像异步等待一样。
You know them in a much
cleaner way as async await.

26
00:01:24.099 --> 00:01:27.924
但你仍然需要承诺，你仍然需要了解他们的工作方式
But you still need promises, you still
need to understand how they work because

27
00:01:27.924 --> 00:01:31.650
许多代码，尤其是旧节点库，它们不使用异步等待。
a lot of code, especially old node
libraries, they don't use async await.

28
00:01:31.650 --> 00:01:33.359
它们使用回调。
They use callbacks.

29
00:01:33.359 --> 00:01:37.430
因此，您需要了解如何履行承诺，履行承诺，并且
So you need to know how promises work
to wrap a callback with a promise and

30
00:01:37.430 --> 00:01:38.509
那就回去吧
then return that.

31
00:01:38.509 --> 00:01:39.539
异步等待很漂亮
Async await is pretty.

32
00:01:39.539 --> 00:01:41.140
这是一个很漂亮的语法。
It's a much prettier syntax.

33
00:01:41.140 --> 00:01:43.325
如果你不能告诉你你只能等待一些事情
If you can't tell,
you can just await something and

34
00:01:43.325 --> 00:01:45.569
最终它会为您提供该值与回调。
eventually it gives you
that value versus callback.

35
00:01:45.569 --> 00:01:48.688
你见过多姆的飞行 V 吗
And then you ever seen
the Flying V of doom?

36
00:01:48.688 --> 00:01:52.468
在您具有回调和回调和回调的位置，因为这将是回调，
Where you have callbacks and callbacks and
callbacks because this will be a callback,

37
00:01:52.468 --> 00:01:55.027
这将是回调，这将是您的回调。
and this will be a callback and
this will be your callback.

38
00:01:55.027 --> 00:01:56.350
Async 等待解决所有这些问题。
Async await solves all of that.

39
00:01:56.350 --> 00:01:57.566
多漂亮的人
Much prettier.

40
00:01:57.566 --> 00:02:01.698
所以我有两个问题，我们还有两个问题。
So I have two questions,
we have two questions left.

41
00:02:01.698 --> 00:02:04.260
我不会给你一个承诺的
And I won't give you a promise phi one.

42
00:02:04.260 --> 00:02:06.250
我要把它放在 advanced 节里
I'll leave that in the advanced section.

43
00:02:06.250 --> 00:02:10.442
所以我有一个问题是原来的，更难的问题是，
So I have one question, which
the original, the harder question is,

44
00:02:10.442 --> 00:02:15.216
给一个这样的一个功能，我怎么把这个转化为一个承诺呢 ?
given a function that looks like this,
how would I convert that into a promise?

45
00:02:15.216 --> 00:02:17.806
我把它递给我然后把它转换成一个承诺
I pass this and
then convert it to a promise,

46
00:02:17.806 --> 00:02:20.187
这比你想象的更具挑战性
it's more challenging than you think.

47
00:02:20.187 --> 00:02:25.192
给它一次机会，答案当然在答案部分，
Give it a shot sometime, the answers
are of course in the answer section,

48
00:02:25.192 --> 00:02:28.354
但我们会做一个较短的睡眠功能
but we'll do a shorter one,
sleep function.

49
00:02:28.354 --> 00:02:32.199
现在，如果我说的是 JavaScript ，你在想什么呢 ?
Now implicitly if I say sleep to
the JavaScript, what are you thinking?

50
00:02:33.949 --> 00:02:34.449
>> 线程休眠。
&gt;&gt; Thread sleep.

51
00:02:36.129 --> 00:02:39.159
>> 是，但我们能用 JavaScript 来做吗 ?
&gt;&gt; Yeah, but can we do that in JavaScript?

52
00:02:39.159 --> 00:02:40.329
不我们不能去
No, we can't.

53
00:02:40.329 --> 00:02:43.469
没错你会喜欢的 Gem 你这个帅哥
Exactly, you'd be like,
Gem, you handsome fool.

54
00:02:43.469 --> 00:02:46.500
你不能用 JavaScript 来睡眠它是单线程的它运行和运行
You can't sleep in JavaScript, it'
single threaded, it just runs and runs,

55
00:02:46.500 --> 00:02:49.329
停止线程的最佳方式是无限循环。
the best you can do to stop
a thread would be an infinite loop.

56
00:02:49.329 --> 00:02:51.439
然后就把整个东西都锁起来了
And then it just locks
up the entire thing.

57
00:02:51.439 --> 00:02:54.872
所以我们不一定要睡在主线里，但我可以在一个功能上睡觉。
So we can't necessarily sleep in the main
thread, but I can sleep in a function.

58
00:02:54.872 --> 00:03:00.250
在等待什么的同时
As in using await or something along

59
00:03:00.250 --> 00:03:05.729
我可以使此函数在此处等待指定的时间间隔，并且
those lines I can make this function wait
here for a specified interval of time and

60
00:03:05.729 --> 00:03:08.169
调整功能，我不能在全局范围上做，什么都做不到。
adjust a function, I couldn't do this on
the global scope or anything like that.

61
00:03:09.210 --> 00:03:11.329
所以用这个，这是最后一个问题。
So using this, this is the last problem.

62
00:03:14.540 --> 00:03:18.153
创建一个以一个参数为时间的睡眠功能，并且
Create a sleep function that takes
one parameter, which is time, and

63
00:03:18.153 --> 00:03:20.650
我们将等待时间
we'll wait time milliseconds.

64
00:03:20.650 --> 00:03:22.319
我甚至给你举个例子
I even graciously gave you an example,

65
00:03:22.319 --> 00:03:23.754
而你却不可能真正的生活
which you would not get
in real life probably.

66
00:03:23.754 --> 00:03:27.389
那就睡了 500 毫秒后它就会打印好
So sleep, it's gonna wait 500 milliseconds
then it's gonna print hello and

67
00:03:27.389 --> 00:03:29.599
然后再等五百毫秒打个招呼
then it's gonna wait 500 milliseconds and
print hello.

68
00:03:30.949 --> 00:03:33.129
我给你十分钟的时间
And I'll give you ten minutes on this one.

69
00:03:33.129 --> 00:03:36.360
这是你最后一天的最后一个问题
This is the last problem for
the day then you've made it.

70
00:03:36.360 --> 00:03:40.498
希望我能模拟真实生活耗尽你会得到的
And hopefully I've simulated real life
exhaustion that you'd get [LAUGH] in

71
00:03:40.498 --> 00:03:41.800
一个战术面试
a tactical interview.
