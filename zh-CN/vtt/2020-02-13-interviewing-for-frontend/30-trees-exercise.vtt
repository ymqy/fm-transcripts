WEBVTT

1
00:00:01.123 --> 00:00:02.911
树木
Trees.

2
00:00:02.911 --> 00:00:07.110
我通常会说
Normally, I would say.

3
00:00:07.110 --> 00:00:10.339
我不知道在采访中我不知道我是否会问一些关于树木的问题
I don't know, in an interview, I don't
know if I'd ask something about trees

4
00:00:10.339 --> 00:00:14.029
除非他们是一位很高级的工程师
unless they're a pretty senior engineer
cuz it's not something we think about.

5
00:00:15.070 --> 00:00:20.199
下一个问题是我失败了
This next problem is one that,
I failed it.

6
00:00:20.199 --> 00:00:22.820
我失败了，卡兹我从没想过树木。
I failed it hard,
cuz I never thought about trees.

7
00:00:22.820 --> 00:00:25.070
但一旦我了解如何解决这个问题
But once I understood how
to solve the problem,

8
00:00:25.070 --> 00:00:27.550
真的改变了我对树木工作方式的看法
really it changed my perspective
on the way trees work.

9
00:00:27.550 --> 00:00:28.699
我喜欢好吧我明白了
I'm like, okay, I get it.

10
00:00:28.699 --> 00:00:30.960
我可以用树来迭代
I get how to iterate through a tree.

11
00:00:30.960 --> 00:00:35.420
但在我被迫去做，被迫失败之前，我什么都没学到。
But until I was forced to do it and
forced to fail, I didn't learn anything.

12
00:00:35.420 --> 00:00:38.466
我就像，树木，我知道树木。
I was like, yeah, trees, I know trees.

13
00:00:38.466 --> 00:00:40.579
DOM 是树凉爽
The DOM is a tree, cool.

14
00:00:40.579 --> 00:00:42.210
我什么时候才能用这个
When am I have to use this?

15
00:00:42.210 --> 00:00:45.920
但在我拿到这个问题并失败之前，我没有强迫自己去学习它。
But until I got this question and failed
it, I didn't force myself to learn it.

16
00:00:45.920 --> 00:00:46.799
但一旦你学会了树木
But once you learn trees,

17
00:00:46.799 --> 00:00:50.880
你所了解的知识是适用于任何树的。
you kind of, the knowledge you
learn is applicable to any tree.

18
00:00:50.880 --> 00:00:55.590
卡兹树是你穿过树的方式一般都是一样的
Cuz trees are, the way you traverse a tree
is generally gonna be the same way.

19
00:00:55.590 --> 00:00:58.600
有不同种类的树木，我绝对不会去。
There's different types of trees,
which I'm definitely not gonna go into.

20
00:00:58.600 --> 00:01:01.750
我很肯定还有一个 Fronsend Master的课程
I pretty sure there's another
Frontend Master's course which talks more

21
00:01:01.750 --> 00:01:03.088
有关树算法和不同类型的信息。
about tree algorithms and different types.

22
00:01:04.239 --> 00:01:05.510
我们今天不会这么做的
We're not gonna do that today.

23
00:01:05.510 --> 00:01:07.662
我们要做最基本的树
We're just gonna do the most basic tree.

24
00:01:07.662 --> 00:01:09.590
但要从树上下来
But gonna start off with a tree.

25
00:01:09.590 --> 00:01:10.840
如果你对树木一无所知
If you didn't know anything about trees,

26
00:01:10.840 --> 00:01:14.159
我当时没有，所有的树都有两个属性。
which I didn't at the time,
all trees have two properties.

27
00:01:14.159 --> 00:01:17.742
它们有根，树从那里开始，它们有节点。
They have a root, where the tree begins,
and they have nodes.

28
00:01:20.176 --> 00:01:24.088
为了打破这些节点，孩子，有父母和
And to break up those nodes,
the child, there's are parents and

29
00:01:24.088 --> 00:01:25.382
有孩子。
there are children.

30
00:01:25.382 --> 00:01:29.730
当然，孩子们是父节点的子代。
The children, of course,
are the children of the parent node.

31
00:01:29.730 --> 00:01:32.439
所以根，根底下的一切都是孩子。
So the root, everything
underneath the root is the child.

32
00:01:32.439 --> 00:01:34.299
当然，根本身也是一个节点。
But of course the root
itself is a node as well.

33
00:01:35.509 --> 00:01:39.490
你想以编程方式思考这个问题的方式是父母。
And the way you wanna think about
this programmatically is the parent.

34
00:01:39.490 --> 00:01:42.030
如果你觉得我不知道父母孩子
If you thought, I don't know,
parent.children?

35
00:01:42.030 --> 00:01:46.426
你如何代表孩子们在树上的位置 ?
How would you represent the position
of the children on a tree?

36
00:01:48.860 --> 00:01:53.760
我知道，这有点棘手，但如果我们说这个是零和一个呢 ?
I know, it's a little tricky, but
what if we said this was zero and one?

37
00:01:53.760 --> 00:01:54.399
如果我有三个孩子怎么办
What if I had three children?

38
00:01:54.399 --> 00:01:55.930
应该是零一二
It'd be zero, one, two.

39
00:01:55.930 --> 00:01:57.295
零，一，二，三，四。
Zero, one, two, three, four.

40
00:01:57.295 --> 00:02:00.049
这就是如果你从左到右，我们就会跳树的顺序。
That's how we would jump the order of the
tree if you're reading from left to right,

41
00:02:00.049 --> 00:02:02.040
一般都是这样想的
and that's generally
how you think about it.

42
00:02:02.040 --> 00:02:04.500
以编程方式，我们会说，这是一个数组。
Programmatically, we'd say,
that's an array.

43
00:02:05.560 --> 00:02:07.924
因此，从 JavaScript 对象的角度来看这一点。
So think of this in terms
of JavaScript objects.

44
00:02:07.924 --> 00:02:12.310
Parent.子代是项的数组。
Parent.children is an array of items.

45
00:02:12.310 --> 00:02:17.039
因此，索引 0 中的子代 1 将成为某个节点，它将成为该节点。
So child 1 at index 0 is gonna be
some node, it's gonna be this node.

46
00:02:17.039 --> 00:02:19.370
子代 2 将是此节点，依此类推。
Child 2 is gonna be this node,
and so on and so forth.

47
00:02:21.280 --> 00:02:23.930
这将适用于下一个问题。
This will be applicable for
this next question.

48
00:02:23.930 --> 00:02:27.939
我们都知道和爱的树是什么
So what's a tree that we all know and
love?

49
00:02:27.939 --> 00:02:29.930
我已经说过四次了
I've said it like four times already.

50
00:02:32.752 --> 00:02:33.413
>> DOM。
&gt;&gt; DOM.

51
00:02:33.413 --> 00:02:35.759
>> DOM，是，是树。
&gt;&gt; The DOM, yes, it's a tree.

52
00:02:35.759 --> 00:02:38.270
DOM 有哪些属性?
And what does the DOM have for properties?

53
00:02:39.610 --> 00:02:43.539
你有一个根，这是 HTML ，它总是以 HTML开头。
You have a root, that's HTML,
it's always gonna start with HTML.

54
00:02:43.539 --> 00:02:45.849
那么你可能有一个身体，一个标题，一个头。
Then you have maybe a body,
a title, a head.

55
00:02:45.849 --> 00:02:49.805
是一棵树，每棵树都有什么 ?
It's a tree, so what does every tree have?

56
00:02:49.805 --> 00:02:50.598
给你个提示
Give you a hint.

57
00:02:52.893 --> 00:02:54.420
子节点。
Child nodes.

58
00:02:54.420 --> 00:02:57.319
你可能已经习惯了，我们可能在一个早期的例子中使用过这个。
And you've probably actually used that, we
might have used that in an early example.

59
00:02:57.319 --> 00:03:00.219
.child 是如何将子节点获取到父节点。
.children is how to get
the child node to the parent.

60
00:03:00.219 --> 00:03:04.469
因此，每个 HTML 元素都有一个子代，它具有您可以保证的父代。
So every HTML element has a children,
it has a parent you can guarantee that.

61
00:03:04.469 --> 00:03:07.759
如果我想通过数组进行迭代。
If I wanna Iterate through an array.

62
00:03:07.759 --> 00:03:10.985
所以，如果我点击一些东西，我想说，我点击了什么 ?
So if I click something and
I wanna say, what did I click on?

63
00:03:10.985 --> 00:03:12.820
Cutz 事件不工作什么的
Cuz event's not working or something.

64
00:03:12.820 --> 00:03:15.294
我只会说 .parent， .parent， .parent， .parent。
I would just say .parent,
.parent, .parent, .parent.

65
00:03:15.294 --> 00:03:16.268
我只是在迭代
I'd just iterate up.

66
00:03:16.268 --> 00:03:19.240
如果我想迭代下去我说处于零位的孩子
If I wanna iterate down,
I say that children at position zero,

67
00:03:19.240 --> 00:03:22.509
点孩子们的反对声音我正穿过一棵树
dot children opposition one and
that way I'm moving through a tree.

68
00:03:24.530 --> 00:03:27.560
我要给你公平的警告，这个是很有挑战性的。
I will give you fair warning,
this one is was challenging.

69
00:03:27.560 --> 00:03:30.969
但我觉得这很有用，因为一旦你了解了这个方案，
But again, i think it's helpful because
once you understand the solution,

70
00:03:30.969 --> 00:03:34.210
此问题，您了解如何迭代树。
this problem you understand
how to iterate through a tree.

71
00:03:34.210 --> 00:03:37.840
如果你能理解唐你能理解的唐
Using Dom as a good exposure,
that if you understand Dom you understand,

72
00:03:37.840 --> 00:03:42.829
i 可以迭代二进制搜索树，也可以迭代 vl 树。
i can iterate through a binary search
tree or I can iterate through a vl tree.

73
00:03:42.829 --> 00:03:44.421
或许多不同类型的树。
Or many different types of trees.

74
00:03:46.789 --> 00:03:49.110
所以，对于这个问题，我已经抽出来了。
So for this particular problem,
I have drawn it out.

75
00:03:50.420 --> 00:03:52.699
你给了两个 DOM 树
You're given two DOM trees.

76
00:03:52.699 --> 00:03:57.569
所以想想，我不知道，如果你想，我不知道两个不同的网页副本。
So think of, I don't know, two different
copies of webpage if you wanted to.

77
00:03:57.569 --> 00:04:01.080
或者说你冒犯了你的 DOM
Or let's say you offloaded your DOM,

78
00:04:01.080 --> 00:04:03.490
你的虚拟 DOM 变成了一个网站工作者你想做个迭代
your virtual DOM, into a web worker,
and you wanna iterate through,

79
00:04:03.490 --> 00:04:07.270
你想操纵它们所以你可以直接用 HTML
you wanna manipulate them both So
you can use HTML directly on those.

80
00:04:08.400 --> 00:04:10.830
但你知道，我们是一个元素不是树。
But you know,
we're one element isn't a tree.

81
00:04:10.830 --> 00:04:11.939
你有一个 DOM 树
So you have a DOM tree.

82
00:04:11.939 --> 00:04:14.460
它代表了一些只是 HTML的东西。
It's represents things that are just HTML.

83
00:04:14.460 --> 00:04:17.759
假设你有一个一模一样的树
Let's say you have a clone
of that exact same tree.

84
00:04:17.759 --> 00:04:20.250
您将如何获取给定元素的路径 ?
How would you get the path
to a given element?

85
00:04:22.149 --> 00:04:25.970
所以如果我给你一个按钮一栋树的位置
So if I give you the location
of a button One domTree,

86
00:04:25.970 --> 00:04:28.860
你怎么能在一个一模一样的圆顶里
how would you get to that
button in an identical domTree.

87
00:04:28.860 --> 00:04:32.819
所以我会说更正式的方式是我们有两个相同的边界 A 和 B 。
So I'll say the more formal way we
have two identical boundaries A and B.

88
00:04:32.819 --> 00:04:34.590
对于 DOM 树 A ，我们有位置和
For DOM tree A, we have location and

89
00:04:34.590 --> 00:04:38.350
元素创意函数，用于在 DOM 树 B 中查找同一元素。
element creative function to find
that same element in DOM tree B.

90
00:04:40.639 --> 00:04:44.850
这个我给你 20 分钟我一定帮你
For this one, I will give you 20 minutes
and I'll definitely help you out.

91
00:04:46.709 --> 00:04:50.060
这个很棘手但想想我们已经知道的了
This one is tricky, but
think of what we know already.

92
00:04:50.060 --> 00:04:51.720
我们对 DOM 树有什么了解
What do we know about DOM tree a?

93
00:04:53.040 --> 00:04:56.920
我们知道它有根，很好。
We know that it has a root, fine.

94
00:04:56.920 --> 00:04:58.139
但我们没有被赋予根
But we're not given the root.

95
00:04:58.139 --> 00:05:02.240
我们被赋予了一个元素我们被赋予了另一棵树
We're given an element to find,
and we're given the other tree.

96
00:05:02.240 --> 00:05:06.100
那么我们如何才能到达根，给出一个元素，任何一个节点?
So how would we get to the root,
given an element, any node?

97
00:05:07.329 --> 00:05:11.220
所以，在这个节点上，我们如何才能到达这里 ?
So given this node how
do we get up to here?

98
00:05:14.139 --> 00:05:16.250
>> 父代的递归。
&gt;&gt; Recursion from the parents.

99
00:05:16.250 --> 00:05:18.459
>> 正好，您可以使用递归。
&gt;&gt; Exactly, you can use recursion.

100
00:05:18.459 --> 00:05:20.949
我只说一个循环再走过去
I would just say a loop and
just walk back over.

101
00:05:20.949 --> 00:05:25.480
因为我们知道一个事实的这个节点有一个父母。
Because this node we know for
a fact has a parent.

102
00:05:26.529 --> 00:05:29.759
然后，此节点具有父节点，并且此节点具有父节点。
And then this node has a parent and
this node has a parent.

103
00:05:29.759 --> 00:05:32.149
所以你可以每次都给家长打电话
So you can walk back up the tree
just calling the parent every time.

104
00:05:32.149 --> 00:05:35.990
我再给你五分钟的提示
I'll give you another hint in
another five minutes or so,

105
00:05:35.990 --> 00:05:38.137
但这应该让你走上正确的道路
but that should start
you on the right path.

106
00:05:38.137 --> 00:05:40.139
好吧好吧
All right.

107
00:05:40.139 --> 00:05:45.220
对，中间有个问题提示，因为这个是一个 " 挑战者" ，
Right, mid problem hint since
this one is a Challenging,

108
00:05:45.220 --> 00:05:47.069
尤其是当你从未想到过树木的情况下
especially if you never
thought about trees.

109
00:05:48.199 --> 00:05:50.350
但让我们想想我们知道的事情。
But let's think about the things we know.

110
00:05:50.350 --> 00:05:52.199
我们知道我们可能需要某种功能
We know we're probably gonna
need some sort of function.

111
00:05:52.199 --> 00:06:00.079
这将会有一些元素，然后它会把那棵树也带走，好吧。
And that's gonna take an elements and then
it's gonna take that other tree, okay.

112
00:06:01.740 --> 00:06:04.579
但最终我们要做什么呢 ?
But ultimately what are we trying to do?

113
00:06:04.579 --> 00:06:11.259
如果我说的话你会喜欢的我们正在努力去做树
And if I say it, you'll be like,
We're trying to go up the tree.

114
00:06:15.451 --> 00:06:17.300
我们有这个元素，然后我们有另一棵树。
We have this element and
then we have this other tree.

115
00:06:17.300 --> 00:06:18.540
这就是我们知道的
That's what we know.

116
00:06:18.540 --> 00:06:21.540
我们正试图到这里来
We're trying to get to here, essentially.

117
00:06:22.639 --> 00:06:26.449
然后，我们可以重放这条路径来到达这里。
And then, we can replay that
same path to get to here.

118
00:06:27.959 --> 00:06:29.779
这将是反向路径算法。
So that would be a reverse path algorithm.

119
00:06:31.160 --> 00:06:35.220
所以，你从这里开始，我们怎么走树呢 ?
So essentially you start here,
how would we walk up the tree?

120
00:06:36.569 --> 00:06:37.779
我们会打电话给家长
We would call dot parent.

121
00:06:37.779 --> 00:06:39.840
然后我们打电话给父母然后给父母打电话
And then we call the parent and
then we call the parent.

122
00:06:41.600 --> 00:06:43.180
如果没有父母，我们就在根。
If there is no parent, we're at the root.

123
00:06:45.819 --> 00:06:47.409
所以如果我们能把它储存在这里
So if we can store that.

124
00:06:47.409 --> 00:06:52.120
然后我们可以回放它，让它后退到这里的树。
We can then replay that, reversing it
to walk back down the tree to here.

125
00:06:53.620 --> 00:06:57.050
请记住，每个元素都有父代，并且有子代。
Remember that every element has
a parent and it has children.

126
00:06:59.930 --> 00:07:02.610
这就是我给你的提示
That's the hint I'll give you.

127
00:07:02.610 --> 00:07:06.579
所以我说，你想在你点击根节点之前迭代起来。
So I'll say, you want to iterate
up until you hit the root node.

128
00:07:06.579 --> 00:07:09.269
然后你就想跳回去回去
And then you want to jump back,
go back down.
