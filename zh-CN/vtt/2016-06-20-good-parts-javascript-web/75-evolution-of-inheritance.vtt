WEBVTT

1
00:00:00.000 --> 00:00:03.798
[音乐]
[MUSIC]

2
00:00:03.798 --> 00:00:07.764
&gt；&gt；Douglas：我认为编程语言是两种截然不同的语言
&gt;&gt; Douglas: I think of programming languages as being in two very distinct

3
00:00:07.764 --> 00:00:12.210
类、系统语言和应用程序语言。
classes, systems languages and application languages.

4
00:00:12.210 --> 00:00:16.440
系统语言是一种用于编写系统内容的语言。
A systems language is a language that you would use for writing system stuff.

5
00:00:16.440 --> 00:00:19.699
需要像内核一样靠近金属的东西，
Something that needs to be close to the metal like a kernel,

6
00:00:19.699 --> 00:00:22.660
设备驱动程序，内存管理器。
a device driver, a memory manager.

7
00:00:22.660 --> 00:00:26.199
那种低级的东西什么都没有。
That kind of low level stuff and nothing else.

8
00:00:26.199 --> 00:00:29.483
其他所有内容都应该用应用程序语言编写。
Everything else should be written in application languages.

9
00:00:29.483 --> 00:00:31.283
现在我们需要一种新的系统语言
Now we need a new system language,

10
00:00:31.283 --> 00:00:36.049
我们占主导地位的系统语言仍然是来自60年代后期的C语言。
our dominant system language is still C which comes from the late 60s.

11
00:00:36.049 --> 00:00:40.950
那是很久以前的事了，我们似乎已经失去了能力
That was a long, long time ago, we seem to have lost the ability

12
00:00:40.950 --> 00:00:45.609
在系统语言中进行创新，并不是说我们不再需要它们了。
to innovate in system languages and it's not like we don't need them anymore.

13
00:00:45.609 --> 00:00:51.549
我认为我们需要一个更好的C版本，但它需要很长的时间。
I think we need a better version of C, but it's a long time coming.

14
00:00:51.549 --> 00:00:53.490
但我更关心的是应用程序语言，
But I'm more concerned with the application languages,

15
00:00:53.490 --> 00:00:57.500
因为那是我们都生活的地方，我们需要更好的应用程序语言。
because that's where we all live and we need better application languages.

16
00:00:57.500 --> 00:01:00.369
我认为一个你可以在很多语言中看到的错误
I think a mistake that you can see in lots of languages

17
00:01:00.369 --> 00:01:04.230
他们对自己站在这条线的哪一边感到困惑。
is that they're confused about which side of this line that they're on.

18
00:01:04.230 --> 00:01:08.269
例如，在我看来，Java最大的设计错误是它不能
For example, for my money the biggest design error in Java was it couldn't

19
00:01:08.269 --> 00:01:11.400
决定它是想成为系统语言还是应用程序语言。
decide if it wanted to be a system language or an application language.

20
00:01:11.400 --> 00:01:16.219
其中一个迹象是它需要使用线程
And one of the signs of that is that it requires the use of threads

21
00:01:16.219 --> 00:01:17.950
在应用程序级别。
at the application level.

22
00:01:17.950 --> 00:01:20.739
我认为这是由于混乱造成的一个悲剧性错误。
Which I think was a tragic mistake due from that confusion.

23
00:01:23.150 --> 00:01:27.460
因此，您可以将应用程序语言划分为两个类。
So you can take the application languages and divide them into two classes.

24
00:01:27.460 --> 00:01:29.799
有古典学派和原型学派。
There's the classical school and the prototypal school.

25
00:01:30.960 --> 00:01:34.229
很长一段时间以来，我一直是原型学校的倡导者
And for a long time I've been an advocate of the prototypal school

26
00:01:34.229 --> 00:01:37.829
因为古典学派存在明显的问题。
because of the obvious problems that are in the classical school.

27
00:01:37.829 --> 00:01:42.609
你已经有了我们讨论过的分类法问题
That you've got the classification taxonomy problem that we talked

28
00:01:42.609 --> 00:01:43.129
关于之前的事。
about earlier.

29
00:01:44.549 --> 00:01:49.280
回到GOTO争论进行的时候，也许是在最响亮的时候，有人发表了
Back when the goto argument was going on, maybe at its loudest, someone published

30
00:01:49.280 --> 00:01:55.039
一篇文章说，我们也应该消除来自的声明。
an article saying we should also eliminate the come-from statement.

31
00:01:55.039 --> 00:01:58.620
这是一个笑话，有人试图设计程序
And it was a joke of it and there were people who attempted to design programming

32
00:01:58.620 --> 00:02:01.530
基于来自语句的语言。
languages based on the come-from statement.

33
00:02:01.530 --> 00:02:04.939
但事实证明我们有来自
But it turns out we have come-from statements in

34
00:02:04.939 --> 00:02:08.379
我们的古典语言，除了我们称之为延伸。
our classical languages except we call it extends.

35
00:02:08.379 --> 00:02:14.560
它所做的事情会导致事物的耦合，耦合可能是一个问题。
And what it does has cause coupling of things and coupling can be a problem.

36
00:02:14.560 --> 00:02:18.319
当你将事物耦合在一起时，一个就会变得依赖于另一个你不能依赖的东西
When you couple things together, then one becomes dependent on the other you cannot

37
00:02:18.319 --> 00:02:20.590
不再独立更改它们。
change them independently anymore.

38
00:02:20.590 --> 00:02:25.340
这导致系统变得脆弱，这在班级系统中发生。
And that causes systems to become brittle and that happens in class systems.

39
00:02:26.659 --> 00:02:31.969
因此原型系统的最大优势就是我们消除了这种耦合。
And so the big advantage in prototypal systems is we eliminate that coupling.

40
00:02:31.969 --> 00:02:38.000
或者我们至少大幅减少它，
Or we at least reduce it significantly,

41
00:02:38.000 --> 00:02:42.560
这样就不再成为问题或进步的障碍。
such that that no longer becomes a problem or a barrier to progress.

42
00:02:42.560 --> 00:02:46.629
所以，作为原型继承的大倡导者。
So, as a big advocate of prototype inheritance.

43
00:02:47.939 --> 00:02:49.270
从那以后我改变了主意
Since then I've changed my mind,

44
00:02:49.270 --> 00:02:53.819
原型最大的好处是节省内存。
that the biggest benefit you get from prototypes is memory conservation.

45
00:02:53.819 --> 00:02:56.829
我认为这可能很重要，可能很重要。
And I think that might have been important, probably was important.

46
00:02:56.829 --> 00:02:59.516
嗯，也许这在1995年并不重要。
Well, maybe it wasn't important in 1995.

47
00:02:59.516 --> 00:03:05.430
现在已经不那么重要了，我们拥有的记忆已经变得如此丰富。
It's not so important now, that we've had memory has become so abundant.

48
00:03:05.430 --> 00:03:08.090
现在，您的口袋中有千兆字节的RAM，并且
You now have gigabytes of RAM in your pocket and

49
00:03:08.090 --> 00:03:11.680
当你无法想象那么多的记忆时。
when you just can't imagine that much memory.

50
00:03:12.819 --> 00:03:16.930
你真的不懂这么大的数字，但我们仍然认为
You really don't understand numbers that big, but we still think about

51
00:03:16.930 --> 00:03:21.849
记忆好像它是以k为单位分发出去的。
memory as though it's doled out in k.

52
00:03:21.849 --> 00:03:24.680
这在当时可能是有道理的，但现在就不那么有道理了。
So may have made sense then, not so much now.

53
00:03:24.680 --> 00:03:28.620
这也是我们拥有财产和继承财产的困惑之源
It also is a source of confusion that we have owned properties and inherited

54
00:03:28.620 --> 00:03:33.550
属性在某些用途上是相同的，但在某些用途上并非如此。
properties which for some purposes act the same, but for some purposes don't.

55
00:03:33.550 --> 00:03:36.500
我在寻找摆脱一切混乱的来源
I'm looking to get rid of all sources of confusion

56
00:03:36.500 --> 00:03:39.550
正如你所知道的，因为混乱会导致错误和利用。
as you know because confusion causes bugs and exploits.

57
00:03:41.500 --> 00:03:44.120
它还提供追溯遗传
It also provides retroactive heredity

58
00:03:44.120 --> 00:03:48.150
您可以在构造对象后更改对象继承的内容。
that you can change what an object inherits after it's constructed.

59
00:03:49.479 --> 00:03:54.270
我还没有发现任何好的用法，但我可以想象很多非常糟糕的用法
I've not found any good uses for this, but I can imagine a lot of really bad uses for

60
00:03:54.270 --> 00:03:57.969
它和它是由这个架构提供的东西。
it and it's something that is provided by this architecture.

61
00:03:57.969 --> 00:04:02.296
它的一个缺点是性能抑制。
One bad thing about it is performance inhibiting.

62
00:04:02.296 --> 00:04:08.000
因此，JavaScript引擎通过对象的形状进行假设来加快速度。
So JavaScript engines go fast by making assumptions about the shape of objects.

63
00:04:09.210 --> 00:04:12.360
当涉及到原型链时，他们必须是悲观的。
And they have to be pessimistic when it comes to prototype chains.

64
00:04:12.360 --> 00:04:16.930
因为原型链可以随时更改其内容
Because a prototype chain can change its contents at any time and

65
00:04:16.930 --> 00:04:20.220
他们需要为此做好准备，这会减慢速度。
they need to be prepared for that and that slows things down.

66
00:04:22.490 --> 00:04:26.170
所以，我过去倾向于原型遗传，
So, I used to be in favor of prototypal inheritance,

67
00:04:26.170 --> 00:04:30.310
我现在支持无类面向对象编程。
I'm now in favor of class free object-oriented programming.

68
00:04:30.310 --> 00:04:34.673
我认为无类面向对象编程是JavaScript的礼物
I think class free object-oriented programming is JavaScript's gift to

69
00:04:34.673 --> 00:04:35.740
人性。
humanity.

70
00:04:35.740 --> 00:04:38.579
我认为这就是为什么这是一种重要的语言。
I think that's why this is an important language.

71
00:04:38.579 --> 00:04:41.000
这就是为什么我希望它成为一种有影响力的语言。
It's why I hope it becomes an influential language.

72
00:04:42.399 --> 00:04:44.629
所以让我们再回顾一遍。
So let's review this again.

73
00:04:44.629 --> 00:04:45.949
这就是块范围。
So this is block scope.

74
00:04:47.670 --> 00:04:51.132
我们有一些函数具有相同的作用域关系和
And we've got functions which have the same scope relationship and

75
00:04:51.132 --> 00:04:52.725
我们又结束了。
we've got our closure again.

76
00:04:52.725 --> 00:04:58.375
我们有这个
And we've got this

77
00:04:58.375 --> 00:05:02.245
非常重要的形式，我们有一个返回函数的函数。
really important form where we have a function that returns a function.

78
00:05:03.670 --> 00:05:07.982
这是我认为历史上最好最重要的发现
And this is I think the best most important discovery in the history

79
00:05:07.982 --> 00:05:11.918
我们有这种愚蠢的小语言。
of programming and we have it in this silly little language.

80
00:05:14.418 --> 00:05:18.067
&gt；&gt；Douglas：最后一次回顾一下，这是我推荐的模型
&gt;&gt; Douglas: So to review one last time, this is the model that I recommend for

81
00:05:18.067 --> 00:05:19.690
进行面向对象的操作
doing object-oriented for

82
00:05:19.690 --> 00:05:25.189
使用JavaScript中的函数进行无类的面向对象编程。
doing class free object-oriented programming using functions in JavaScript.

83
00:05:25.189 --> 00:05:28.930
我们有一个构造函数，它接受一个规范对象。
We've got a constructor which takes a specification object.

84
00:05:28.930 --> 00:05:32.340
我们使我们的实例变量，我们可以
We make our instance variables which we can

85
00:05:32.340 --> 00:05:35.413
从规范对象初始化。
initialize from the specification object.

86
00:05:37.295 --> 00:05:42.279
我们可以获得我们可以使用的其他方法或其他函数
We get other methods or other functions that we can use that we can get

87
00:05:42.279 --> 00:05:45.699
从其他构造函数中调用，我们可以随意调用其中的任意多个。
from other constructors and we can call as many of these as we like.

88
00:05:48.389 --> 00:05:52.829
然后我们创建将关闭所有成员的方法，
We then create our methods which will close over all of the members,

89
00:05:52.829 --> 00:05:56.478
所有其他方法，我们的所有方法和规范对象。
all of the other methods, all of our methods and the specification object.

90
00:05:59.230 --> 00:06:01.500
所有这些都需要公开，
And any of these which need to be public,

91
00:06:01.500 --> 00:06:04.290
我们将放入传出对象，然后将其冻结。
we will put in the outgoing object which we then freeze.

92
00:06:06.160 --> 00:06:10.980
通过这样做，我们得到了一个具有硬接口的对象，
By doing this, we get an object which has a hard interface,

93
00:06:10.980 --> 00:06:13.430
一个不会损坏的接口。
an uncorruptable will interface.

94
00:06:13.430 --> 00:06:17.250
它总是以它应该的方式工作，它不能被混淆。
It will always work exactly the way it should, it cannot be confused.

95
00:06:18.350 --> 00:06:21.459
而且它也纠正了，我认为我们一直存在的一个问题
And it also corrects, I think a problem that we've always had in

96
00:06:21.459 --> 00:06:24.600
对象，因为您希望通过方法访问某些内容。
objects in that some things you want to access through a method.

97
00:06:24.600 --> 00:06:29.509
还有一些只是简单地戳一下属性。
And some simply by poking at the properties.

98
00:06:30.589 --> 00:06:33.579
除非你允许人们去戳他们的房子，
Except if you allow people to poke at the properties,

99
00:06:33.579 --> 00:06:36.468
那么就没有针对不一致的防御。
then there is no defense against inconsistency.

100
00:06:37.639 --> 00:06:42.620
所有的一切，至少对象的所有更改都应该通过接口。
Everything, all changes at least to the object should go through the interfaces.
