WEBVTT

1
00:00:00.000 --> 00:00:03.932
[音乐]
[MUSIC]

2
00:00:03.932 --> 00:00:09.189
&gt；&gt；Douglas Crockford：编写一个计算简单数组表达式的函数exp。
&gt;&gt; Douglas Crockford: Write a function exp that evaluates simple array expressions.

3
00:00:09.189 --> 00:00:15.179
一个简单的数组表达式是一个数组，其中第一个元素是一个函数，并且
A simple array expression is an array in which the first element is a function and

4
00:00:15.179 --> 00:00:19.719
其余元素是该函数的参数。
the remaining elements are the arguments to that function.

5
00:00:21.120 --> 00:00:25.585
所以如果我们传递数组，mul，5，
So if we pass that array, mul, five,

6
00:00:25.585 --> 00:00:31.175
11到EXP函数，它将返回55。
11 to the EXP function, it will return 55.

7
00:00:31.175 --> 00:00:34.859
如果我们简单地将一个数字传递给exp函数。
And if we simply pass a number to the EXP function.

8
00:00:34.859 --> 00:00:37.582
它只会返回那个号码，好吗？
It will just return that number, okay?

9
00:00:40.329 --> 00:00:43.450
&gt；&gt；扬声器2：二进制？
&gt;&gt; Speaker 2: Binary?

10
00:00:43.450 --> 00:00:45.250
&gt；&gt；Douglas Crockford：是的，但有些是二元函数。
&gt;&gt; Douglas Crockford: Yeah, but some are binary function.

11
00:00:45.250 --> 00:00:48.649
事实证明，它也可以与一元函数一起工作，但是-
It turns out it will also work with unary functions, but-

12
00:00:48.649 --> 00:00:49.520
&gt；&gt；演讲者3：下一步是什么？
&gt;&gt; Speaker 3: What's the next?

13
00:00:50.619 --> 00:00:51.600
对，例如。
Right, exp.

14
00:00:51.600 --> 00:00:52.340
对不起。&gt；&gt；Douglas Crockford：是的。
Sorry. &gt;&gt; Douglas Crockford: Yeah.

15
00:00:52.340 --> 00:00:54.710
是的，你是对的。
Yeah, you're right.

16
00:00:54.710 --> 00:00:56.420
&GT；&GT；扬声器3：它总是对的吗？
&gt;&gt; Speaker 3: And it's always right?

17
00:00:57.950 --> 00:00:59.020
&gt；&gt；Douglas Crockford：可能是两个或三个。
&gt;&gt; Douglas Crockford: Could be two or three.

18
00:00:59.020 --> 00:01:00.000
&gt；&gt；扬声器3：两个或三个，好的。
&gt;&gt; Speaker 3: Two or three, okay.

19
00:01:00.000 --> 00:01:01.490
&GT；&GT；道格拉斯·克罗克福德：但你并不关心这个。
&gt;&gt; Douglas Crockford: But you don't care about that.

20
00:01:01.490 --> 00:01:03.189
假设三个，总是这样。
Assume three, it's always.

21
00:01:03.189 --> 00:01:04.629
&gt；&gt；扬声器3：当然。
&gt;&gt; Speaker 3: Sure.

22
00:01:04.629 --> 00:01:06.469
&gt；&gt；Douglas Crockford：明年会是n，但是。
&gt;&gt; Douglas Crockford: Next year it'll be n, but.

23
00:01:06.469 --> 00:01:07.180
&gt；&gt；扬声器3：好的。
&gt;&gt; Speaker 3: Right, okay.

24
00:01:07.180 --> 00:01:08.739
&GT；&GT；道格拉斯·克罗克福德：但今年将是三个。
&gt;&gt; Douglas Crockford: But this year it'll be three.

25
00:01:13.813 --> 00:01:15.680
&gt；&gt；Douglas Crockford：好的，这是Exp。
&gt;&gt; Douglas Crockford: Okay, here is exp.

26
00:01:17.219 --> 00:01:22.489
EXP接受一个值，如果该值是一个数组，则返回一些值。
Exp takes a value and it returns something if the value is an array.

27
00:01:22.489 --> 00:01:25.359
它返回调用第一个元素的结果，
It returns a result of calling the first element,

28
00:01:25.359 --> 00:01:28.140
将接下来的两个元素作为参数传递。
passing the next two elements as arguments.

29
00:01:28.140 --> 00:01:30.299
否则，它将返回值。
Otherwise, it returns the value.

30
00:01:30.299 --> 00:01:31.579
那么，谁有用的东西呢？
So, who got something that works?

31
00:01:32.920 --> 00:01:33.420
非常好。
Very good.

32
00:01:35.954 --> 00:01:36.865
想再来一次吗？
Wanna do one more?

33
00:01:36.865 --> 00:01:38.545
你以为你有这个本事吗？
You think you've got it in you?

34
00:01:38.545 --> 00:01:40.134
它将基于这个，所以
It's gonna be based on this one, so

35
00:01:40.134 --> 00:01:43.411
如果有人没有得到这个，现在就得到它，因为你会需要它。
if anybody didn't get this one, get it now cuz you're gonna need it.

36
00:01:43.411 --> 00:01:45.956
准备好了吗？
Okay ready?

37
00:01:45.956 --> 00:01:50.020
最后一个问题。
Last problem.

38
00:01:50.020 --> 00:01:52.710
完成强可以这样。
Finish Strong OK so.

39
00:01:52.710 --> 00:01:53.990
修改x P
Modify x P.

40
00:01:53.990 --> 00:02:00.329
来计算嵌套数组表达式，这就是OR表达式。
to evaluate nested array expressions and that's that or expression is.

41
00:02:00.329 --> 00:02:03.079
就像简单的表达式一样，除了
Just like the simpler expressions except

42
00:02:03.079 --> 00:02:08.349
任何参数也可以是嵌套数组表达式。
any of the arguments can also be a nested array expression.

43
00:02:08.349 --> 00:02:13.409
所以在这种情况下，我们有一个斜边的东西在这里进行。
So in this case, we've got a hypotenuse thing going on here.

44
00:02:14.930 --> 00:02:18.612
如果我们将嵌套数组结构传递给exp，
And if we pass that nested array structure to exp,

45
00:02:18.612 --> 00:02:22.745
现在它将评估整个事情并得出5个结果。
it will now evaluate the whole thing and come up with 5.

46
00:02:25.384 --> 00:02:29.513
&gt；&gt；Douglas Crockford：每个人都明白了吗？
&gt;&gt; Douglas Crockford: Everybody got it?

47
00:02:29.513 --> 00:02:34.699
[BLACK_AUDIO]&gt；&gt；扬声器3：获取一个参数是
[BLANK_AUDIO ] &gt;&gt; Speaker 3: Getting one parameters is

48
00:02:34.699 --> 00:02:39.770
如果对数组求值，则可以传递给数组。
an array, can that pass of, pass to if it's evaluated.

49
00:02:40.819 --> 00:02:41.759
&gt；&gt；Douglas Crockford：是的。
&gt;&gt; Douglas Crockford: Yes.

50
00:02:41.759 --> 00:02:42.259
完全正确。
Exactly.

51
00:02:43.860 --> 00:02:45.650
所以让我们来看看exp。
So let's take a look at EXP.

52
00:02:46.949 --> 00:02:50.829
所以我做的唯一的改变就是我调用了exp
So the only change that I made was I called EXP

53
00:02:50.829 --> 00:02:55.170
在我们使用它们之前，请先对每个论点进行讨论。
on each of the arguments before we use them.

54
00:02:55.170 --> 00:02:56.069
就是这样。
That's it.

55
00:02:56.069 --> 00:03:00.360
因此，递归最终完成了所有的工作，这真的很好。
And so, recursion ends up doing all the work, which is really really nice.

56
00:03:00.360 --> 00:03:03.050
无论何时您正在处理嵌套数据结构
Anytime you're dealing with nested data structures

57
00:03:03.050 --> 00:03:06.840
递归通常是处理该问题的理想方法。
Recursion is usually the ideal way to deal with that.

58
00:03:06.840 --> 00:03:11.800
所以这个函数说明的好事情之一就是它有多强大
So one of the nice things that this function illustrates is just how powerful

59
00:03:13.460 --> 00:03:15.419
功能系统可以。
function systems can be.

60
00:03:15.419 --> 00:03:19.599
其中的这个小功能是一个小功能
That this little function in it is a little function

61
00:03:19.599 --> 00:03:21.349
实现编程语言的大部分内容。
Implement most of a programming language.

62
00:03:22.710 --> 00:03:24.695
有人认识这是什么语言吗？
Anyone recognize what language this is?

63
00:03:24.695 --> 00:03:29.460
列表，是的，在列表中他们使用
List, yeah in list they use

64
00:03:29.460 --> 00:03:33.485
父代而不是括号和逗号是可选的，否则这是Lisp。
parents instead of brackets and the commas are optional otherwise this is Lisp.

65
00:03:34.954 --> 00:03:39.025
这显然不是整个语言，但它是语言中一个有趣的部分。
It's clearly not the whole language, but it's an interesting part of the language.

66
00:03:39.025 --> 00:03:46.064
做Lisp的人这样做的原因之一是因为
And one of the reasons why people who do Lisp act the way they do is because

67
00:03:46.064 --> 00:03:49.920
他们可以做这样的事情，真的很快，真的很容易。
they can do stuff like this really, really fast, really, really easily.

68
00:03:49.920 --> 00:03:53.199
只是，你把它比作实现
It's just, you compare that to implementing

69
00:03:54.259 --> 00:03:56.099
一个系统来做我们的语言之一。
a system to do one of our languages.

70
00:03:56.099 --> 00:03:58.289
这是一件完全不同的事情。
And it's just a completely different thing.

71
00:04:00.069 --> 00:04:02.500
所以我希望你们都喜欢这个。
So I hope you all enjoy this.

72
00:04:02.500 --> 00:04:03.680
今天很累，但是
Today was grueling but

73
00:04:03.680 --> 00:04:06.650
你出来了，有没有人觉得今天他们的大脑变大了？
you came out, does anybody feel like their brain got bigger today?

74
00:04:06.650 --> 00:04:08.330
有人感觉到了吗？
Anyone feeling that?

75
00:04:08.330 --> 00:04:11.879
所以在我送你回家之前，显然你需要一些家庭作业，对吗？
So before I send you home obviously you're going to need some homework right?

76
00:04:11.879 --> 00:04:13.060
所以让我们开始做作业吧。
So let's get to the homework.

77
00:04:15.849 --> 00:04:20.550
家庭作业问题是编写一个函数ADD G，该函数用于添加
The homework problem is write a function add G that adds for

78
00:04:20.550 --> 00:04:24.319
多次调用，直到它看到一个空调用。
many invocations until it sees an empty invocation.

79
00:04:24.319 --> 00:04:28.870
当您收到一个空调用时，当您接收未定义的参数时。
When you've got an empty invocation when you receive undefined as an argument.

80
00:04:28.870 --> 00:04:33.420
因此在这种情况下，如果没有传递任何内容给add G，它将返回undefined。
So in this case if you pass nothing to add G, it will return undefined.

81
00:04:33.420 --> 00:04:36.159
如果你通过了两个然后就什么都没有了。
If you pass two and then nothing.

82
00:04:36.159 --> 00:04:36.879
它将返回2。
It will return 2.

83
00:04:36.879 --> 00:04:40.370
如果你传递2，然后是7，然后什么都没有，它将返回9。
If you pass 2 and then 7 and then nothing, it will return 9.

84
00:04:40.370 --> 00:04:44.699
如果你传递3，然后是0，然后是4，然后什么都没有，它将返回7。
If you pass 3 and then 0, then 4, and then nothing, it will return 7.

85
00:04:44.699 --> 00:04:48.870
如果你通过1，然后是2，然后是4，然后是8，然后什么都没有，
And if you pass 1 and then 2 and then 4 and then 8 and then nothing,

86
00:04:48.870 --> 00:04:49.959
它将返回15。
it will return 15.

87
00:04:49.959 --> 00:04:54.389
所以我给你个提示。
So I'll give you a hint.

88
00:04:54.389 --> 00:04:58.139
这个问题将涉及一个函数返回自身，
This problem is going to involve a function returning itself,

89
00:04:59.199 --> 00:05:01.910
这可能是你以前从未遇到过的事情。
which is something you may have never encountered before.
