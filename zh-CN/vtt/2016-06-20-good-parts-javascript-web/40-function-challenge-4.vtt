WEBVTT

1
00:00:00.000 --> 00:00:03.744
[音樂]
[MUSIC]

2
00:00:03.744 --> 00:00:08.192
&gt；&gt；Douglas：從生成將生成
&gt;&gt; Douglas: Write a from a function that produces a generator that will produce

3
00:00:08.192 --> 00:00:09.551
一系列的值。
a series of values.

4
00:00:09.551 --> 00:00:13.198
所以，我們要把一個零傳遞給FROM函式。
So, we're going to pass a zero to the from function.

5
00:00:13.198 --> 00:00:16.710
它將返回一個生成器，在本例中我稱之為index。
It will return a generator in this case I'm calling it index.

6
00:00:16.710 --> 00:00:21.652
每次我呼叫index時，它都會返回
Every time I call index, it will return the next value in

7
00:00:21.652 --> 00:00:26.292
以起始值開始的序列。
the sequence that started with the starting value.

8
00:00:26.292 --> 00:00:29.254
&gt；&gt；演講者2：什麼是發電機？
&gt;&gt; Speaker 2: What's a generator?

9
00:00:29.254 --> 00:00:31.635
&gt；&gt；道格拉斯：生成器是一個會製造東西的函式。
&gt;&gt; Douglas: Generator is a function that will make things.

10
00:00:31.635 --> 00:00:37.287
所以每次你打電話給發電機，你就會得到另一樣東西。
So each time you call a generator, you'll get another thing.

11
00:00:37.287 --> 00:00:41.615
在這種情況下，你在製造一臺發電機，
In this case, where you were making a generator that's

12
00:00:41.615 --> 00:00:46.508
將產生一個從某個值開始的整數序列。
gonna produce a sequences of integers starting at some value.

13
00:00:46.508 --> 00:00:48.261
好的，這是來自，
Okay, so here is from,

14
00:00:48.261 --> 00:00:53.783
FROM接受起始值，它返回一個計算下一個值的函式
from takes a start value it returns a function which computes the next value

15
00:00:53.783 --> 00:00:58.884
只需開始，它就會在開始時新增一個，然後返回下一個。
simply by taking the start it adds one to start and then returns next.

16
00:00:58.884 --> 00:01:02.180
那麼，誰有什麼管用的東西？
So, who got something that works?

17
00:01:02.180 --> 00:01:07.731
好的，很好，有人採取了不同的方法嗎？
Okay, very good, anybody take a different approach?

18
00:01:07.731 --> 00:01:13.609
&gt；&gt；演講者2：我剛剛在您的函式中看到了這一點。
&gt;&gt; Speaker 2: I just read that in your function.

19
00:01:13.609 --> 00:01:20.328
道格拉斯：好的，我剛剛退回了X加等於1。道格拉斯：好的。
I just did return X plus equals one &gt;&gt; Douglas: Okay

20
00:01:20.328 --> 00:01:21.108
&gt；&gt；揚聲器2：可以嗎？
&gt;&gt; Speaker 2: That work?

21
00:01:21.108 --> 00:01:22.358
&gt；&gt；道格拉斯：當然可以。
&gt;&gt; Douglas: Sure.

22
00:01:22.358 --> 00:01:24.176
還有其他人嗎？
Anybody else?

23
00:01:24.176 --> 00:01:27.402
&gt；&gt；演講者3：那會給你一個不同的起點。
&gt;&gt; Speaker 3: That will give you a starting point different.

24
00:01:27.402 --> 00:01:29.820
那就應該是零開始了。
Then zero ought to be starting one.

25
00:01:29.820 --> 00:01:31.998
道格拉斯：是的，他說得對。
&gt;&gt; Douglas: Yeah, he's right.

26
00:01:31.998 --> 00:01:32.808
&gt；&gt；揚聲器2：您會喜歡這個的。
&gt;&gt; Speaker 2: You'll like this.

27
00:01:32.808 --> 00:01:34.953
道格拉斯：是的，我確實退回了Start plus&gt；&gt；道格拉斯：是的，
I did return start plus plus &gt;&gt; Douglas: Yeah,

28
00:01:34.953 --> 00:01:36.271
總會有這樣的事。
there's always one of those.

29
00:01:36.271 --> 00:01:40.859
&gt；&gt；演講者3：[笑]&gt；&gt；道格拉斯：還有人嗎？
&gt;&gt; Speaker 3: [LAUGH] &gt;&gt; Douglas: Anybody else?

30
00:01:40.859 --> 00:01:43.777
&gt；&gt；揚聲器4：你想開始加一個嗎？
&gt;&gt; Speaker 4: You wanna get start plus one?

31
00:01:43.777 --> 00:01:50.996
&gt；&gt；道格拉斯：是的，從1開始，如果我們說從零開始，我們需要從零開始。
&gt;&gt; Douglas: Yeah, start 1’s to be, if we say from zero we need to start from zero.

32
00:01:50.996 --> 00:01:54.615
&gt；&gt；揚聲器4：你需要加，加1。
&gt;&gt; Speaker 4: You need plus, plus 1.

33
00:01:54.615 --> 00:01:58.859
但是你返回加，加開始。
But you return plus, plus start.

34
00:01:58.859 --> 00:01:59.984
&gt；&gt；道格拉斯：我們不會這麼做的。
&gt;&gt; Douglas: We’re not doing that.

35
00:01:59.984 --> 00:02:02.865
&gt；&gt；揚聲器3：是的，我知道你不會那麼做的。
&gt;&gt; Speaker 3: Yeah, I know you’re not doing that.

36
00:02:02.865 --> 00:02:06.260
&gt；&gt；道格拉斯：好了，準備好繼續前進了嗎？
&gt;&gt; Douglas: Okay, ready to move on?

37
00:02:06.260 --> 00:02:11.689
好的，這是下一個，寫一個to函式，它接受一個生成器，
Okay here's the next one, write a to function that takes a generator and

38
00:02:11.689 --> 00:02:17.663
一個終結值，並返回一個生成器，該生成器將生成達到該限制的數字。
an end value and returns a generator that will produce numbers up to that limit.

39
00:02:17.663 --> 00:02:22.552
因此，我們將傳遞給，以執行一個生成器，我們
So, we'll pass to the to function a generator that we

40
00:02:22.552 --> 00:02:25.278
使用我們的FROM函式進行製作。
make with our from function.

41
00:02:25.278 --> 00:02:29.799
所以我將從1傳遞到2，也傳遞給它3，
So I will pass from 1 to 2 and also pass it a 3, and

42
00:02:29.799 --> 00:02:36.478
它將返回一個生成器，該生成器將返回值最高可達2，並且
it will return a generator which will return values up to the limit to 2 and

43
00:02:36.478 --> 00:02:41.353
從這一點開始，它將返回UNDEFINED。
from that point on it will return undefined instead.

44
00:02:41.353 --> 00:02:46.021
&gt；&gt；演講者2：那麼就之前的限制而言，這一限制不包括限制？
&gt;&gt; Speaker 2: So on the previous limit, this one does not include the limit?

45
00:02:46.021 --> 00:02:48.518
[聽不見]次。
[INAUDIBLE] times.

46
00:02:48.518 --> 00:02:52.896
&gt；&gt；道格拉斯：對，這是2a值&gt；&gt；演講者2：不包括這個。
&gt;&gt; Douglas: Right, this is 2 a value &gt;&gt; Speaker 2: Not including this one.

47
00:02:52.896 --> 00:02:53.740
&gt；&gt；道格拉斯：對。
&gt;&gt; Douglas: Right.

48
00:03:03.250 --> 00:03:07.816
&gt；&gt；[INAUDIBLE]&gt；&gt；道格拉斯：嗯，
&gt;&gt; [INAUDIBLE] &gt;&gt; Douglas: Well,

49
00:03:07.816 --> 00:03:10.181
這是我們語言中的慣例，對嗎？
this is the convention we have in our languages, right?

50
00:03:10.181 --> 00:03:10.844
&gt；&gt；演講者4：沒錯。
&gt;&gt; Speaker 4: That's true.

51
00:03:10.844 --> 00:03:13.421
&gt；&gt；道格拉斯：當你在服用某種亞型的時候？
&gt;&gt; Douglas: When you're taking a substrain of something?

52
00:03:13.421 --> 00:03:16.361
這就是我們做這件事的方式。
This is the way we do it.

53
00:03:16.361 --> 00:03:17.746
&gt；&gt；揚聲器4：這就是你的理由嗎，麥克斯？
&gt;&gt; Speaker 4: Is this your reason Max?

54
00:03:17.746 --> 00:03:18.930
道格拉斯：是的。
&gt;&gt; Douglas: Yeah.

55
00:03:18.930 --> 00:03:24.724
[聲音]所以，這裡有一種編寫to函式的方法。
[SOUND] So, here's one way to write the to function.

56
00:03:24.724 --> 00:03:27.144
要獲取一個生成器和一個終結值，
To takes a generator and an end value,

57
00:03:27.144 --> 00:03:31.393
它返回一個函式，該函式從生成器獲取下一個值。
it returns a function that gets the next value from the generator.

58
00:03:31.393 --> 00:03:35.442
如果該值小於結束值，則返回該值，
If that value is less than the end value, it returns that value,

59
00:03:35.442 --> 00:03:37.625
否則，它將返回UNDEFINED。
otherwise it returns undefined.

60
00:03:37.625 --> 00:03:40.060
那麼，誰有什麼管用的東西？
So, who got something that works?

61
00:03:40.060 --> 00:03:41.241
非常好。
Very good.

62
00:03:41.241 --> 00:03:43.759
有沒有人採取不同的方法或做一些令人驚歎的事情？
Anyone take a different approach or do something amazing?

63
00:03:45.670 --> 00:03:47.789
&gt；&gt；道格拉斯：精彩、壯觀，諸如此類。
&gt;&gt; Douglas: Wonderful, spectacular, anything like that.

64
00:03:47.789 --> 00:03:53.177
&gt；&gt；揚聲器2：太神奇了，但是我的看起來和極限函式非常相似。
&gt;&gt; Speaker 2: Amazing it is but mine looks very similar to the limit function.

65
00:03:53.177 --> 00:03:56.593
只是使用它內部的發電機。
Just uses from generators inside of it.

66
00:03:56.593 --> 00:04:01.592
所以我在外部作用域中設定了變數，然後新增一個數字
So I set variable in the outer scope, and then add a number to that and

67
00:04:01.592 --> 00:04:06.152
如果該數字小於或等於返回查詢限制，
if that number is less than or equal to the limit a return find,

68
00:04:06.152 --> 00:04:08.552
否則就是發電機。
otherwise generator.

69
00:04:08.552 --> 00:04:14.460
&gt；&gt；道格拉斯：好的，還有沒有人？
&gt;&gt; Douglas: Okay, anybody else?

70
00:04:14.460 --> 00:04:17.297
好的，想再來一次嗎？
All right, wanna do another one?

71
00:04:17.297 --> 00:04:20.838
好的，好的，我們再做一次。
Yes, all right, let's do another one.

72
00:04:20.838 --> 00:04:25.605
好的，讓我們編寫一個生成生成器的FROM TO函式
Okay, let's write a from to function that produces a generator

73
00:04:25.605 --> 00:04:28.000
在一定範圍內創造價值。
that produces value in a range.

74
00:04:28.000 --> 00:04:33.584
所以我們將從0和3傳遞到0和3，它會讓我們得到生成器
So we're going to pass to fromTo 0 and 3 and it will get us the generator

75
00:04:33.584 --> 00:04:38.439
這給了我們一個序列0，1，2，然後是未定義的。
that gives us a sequence zero, one, two and then undefined.

76
00:04:38.439 --> 00:04:43.858
下面是返回中的FromTo、FromTo(Start，End)值
So here is fromto, fromto (start, end) value in the returns

77
00:04:43.858 --> 00:04:48.577
呼叫的結果從(Start)傳遞到結束。
result of calling to passing it from (start), end.

78
00:04:48.577 --> 00:04:51.009
那麼，誰有什麼管用的東西？
So, who got something that works?

79
00:04:51.009 --> 00:04:52.261
非常好。
Very good.

80
00:04:52.261 --> 00:04:54.495
誰做得更難？
Who did it the hard way?

81
00:04:54.495 --> 00:04:57.687
是的，函數語言程式設計的第一條規則，
Yeah, first rule of functional programming,

82
00:04:57.687 --> 00:04:59.769
讓函式來完成這項工作。
let the functions do the work.

83
00:04:59.769 --> 00:05:04.024
編寫一個元素函式，該函式接受一個數組和一個生成器，並
Write an element function that takes an array and a generator and

84
00:05:04.024 --> 00:05:08.300
返回將從陣列生成元素的生成器。
returns a generator that will produce elements from the array.

85
00:05:08.300 --> 00:05:14.983
所以我們將傳遞給元素工廠，以及包含a、b、c和d的陣列。
So we're gonna pass to the element factory, and array containing a,b,c and d.

86
00:05:14.983 --> 00:05:20.425
並將給它一個發電機，從2點1到3點，
And will give it a generator which does from two one to three,

87
00:05:20.425 --> 00:05:27.487
這將給我們一個生成器，它將產生b和c，然後是未定義的。
and that will give us a generator which will produce b and c and then undefined.

88
00:05:27.487 --> 00:05:31.470
這裡是元素，元素有一個數組和一個生成器。
So here's element, element takes an array and a generator.

89
00:05:31.470 --> 00:05:35.521
它返回一個函式，該函式從生成器獲取下一個索引。
It returns a function that gets the next index from the generator.

90
00:05:35.521 --> 00:05:40.466
如果索引不是未定義的，則它返回下一個索引，
If the index is not undefined it returns the next,

91
00:05:40.466 --> 00:05:44.600
或該索引處的陣列元素。
or the element of the array at that index.

92
00:05:44.600 --> 00:05:47.584
那麼，誰有什麼管用的東西？
So, who got something that works?

93
00:05:47.584 --> 00:05:51.206
所以，我想談談這個帶下劃線的陳述。
So, I want to talk about this statement that's underlined.

94
00:05:51.206 --> 00:05:56.189
因為如果你把它去掉，如果我們無條件地退貨，
Because if you leave that if out, if we do the return unconditionally,

95
00:05:56.189 --> 00:05:57.860
它做的是同樣的事情。
it does the same thing.

96
00:05:57.860 --> 00:06:00.932
它做同樣事情的原因有點奇怪。
And the reason it does the same thing is kind of weird.

97
00:06:00.932 --> 00:06:01.733
所以,
So,

98
00:06:09.735 --> 00:06:14.132
&gt；&gt；道格拉斯：如果我們那裡沒有如果，
&gt;&gt; Douglas: If we don't have the if there,

99
00:06:14.132 --> 00:06:18.028
如果索引是未定義的。
and if index is undefined.

100
00:06:18.028 --> 00:06:23.867
則括號將變為未定義的字串。
Then the brackets will turn undefined into the string undefined.

101
00:06:23.867 --> 00:06:28.923
然後它將查詢陣列中未定義的成員，並且找不到它，
It will then look for the member undefined in the array and not find it,

102
00:06:28.923 --> 00:06:34.593
返回UNDEFINED，如果找不到什麼，就返回UNDEFINED。
and return undefined, which is what you return if you can't find something.

103
00:06:34.593 --> 00:06:41.408
如果你省略了那個測試，它就會意外地起作用，除非在這種情況下
So it kind of accidentally works, if you leave that test out, except in the case

104
00:06:41.408 --> 00:06:46.723
其中，如果有人在陣列中建立了未定義的屬性。
where if someone creates an undefined property in the array.

105
00:06:46.723 --> 00:06:50.740
然後，它們可以使此函式的行為在這種情況下更改。
Then they can cause the behavior of this function to change in that case.

106
00:06:50.740 --> 00:06:54.509
&gt；&gt；Speaker 2：那麼，您會在陣列中的節點上呼叫delete嗎？
&gt;&gt; Speaker 2: So, you would to call delete on a node in the array?

107
00:06:54.509 --> 00:07:00.798
&gt；&gt；Douglas：不，不刪除節點，如果您說陣列，那麼陣列叫什麼？
&gt;&gt; Douglas: No not deleting a node, if you said array, what are calling the array?

108
00:07:00.798 --> 00:07:05.064
是的，如果我們說array.unfinition=5，
Yeah, if we said array.undefined = five,

109
00:07:05.064 --> 00:07:10.230
則在這種情況下將返回5，而不是未定義
then in that case will return five instead of undefined

110
00:07:10.230 --> 00:07:16.992
這可能不是你想要的，所以在大多數情況下它是有效的。
which might not be what you want, and so while most of the time it works.

111
00:07:16.992 --> 00:07:20.920
我擔心的是那些讓你陷入困境的奇怪案件
I'm concerned about the weird cases which are what actually screw you up in

112
00:07:20.920 --> 00:07:22.235
無論是在生產上還是在生活中。
production and at life.

113
00:07:22.235 --> 00:07:28.461
因此，我寧願直截了當地尋找這種情況。
And so, I would rather be explicit and look for that case.

114
00:07:28.461 --> 00:07:30.122
還有誰做了些不一樣的事嗎？
Anybody else do something different?

115
00:07:32.747 --> 00:07:36.552
&gt；&gt；演講者2：我的意思是，這將繼續與任務相關。
&gt;&gt; Speaker 2: This is continued to be array, I mean, to the task.

116
00:07:36.552 --> 00:07:37.139
道格拉斯：是的。
&gt;&gt; Douglas: Yeah.

117
00:07:37.139 --> 00:07:39.129
&gt；&gt；Speaker 4：這裡是返回的陣列gen。
&gt;&gt; Speaker 4: Here it's returned array gen.

118
00:07:39.129 --> 00:07:43.125
&gt；&gt；道格拉斯：嗯-嗯，是的-&gt；&gt；揚聲器4：因為要做的事情太多了
&gt;&gt; Douglas: Mm-hm and yes- &gt;&gt; Speaker 4: Cuz there's too much to

119
00:07:43.125 --> 00:07:43.672
那麼做吧。
do that.

120
00:07:43.672 --> 00:07:47.425
[笑]&gt；&gt；道格拉斯：幾乎總是在工作，
[LAUGH] &gt;&gt; Douglas: Almost always work,

121
00:07:47.425 --> 00:07:53.351
修改元素函式，使生成器引數是可選的。
modify the element function so that the generator argument is optional.

122
00:07:53.351 --> 00:07:56.625
如果沒有提供生成器，則
If the generator is not provided then each of the elements of

123
00:07:56.625 --> 00:07:58.201
將提供陣列。
the array will be provided.

124
00:07:58.201 --> 00:08:03.261
所以我們可以呼叫元素來傳遞陣列a、b、c和d，並且
So we can call element pass the array a, b, c, and d, and

125
00:08:03.261 --> 00:08:09.387
我們將得到一個生成器，它將返回a、b、c、d和未定義。
we will get a generator which will return a, b, c, d and undefined.

126
00:08:09.387 --> 00:08:14.985
這是修改後的元素，我所做的就是新增黃色方框中的程式碼。
So here is the revised element, all I did was add the code that's in the yellow box.

127
00:08:14.985 --> 00:08:19.386
如果我們沒有通過發電機，我們也會打來電話
If we didn't get past a generator, then we'll call from too and

128
00:08:19.386 --> 00:08:23.634
買一臺新的發電機，否則一切都一樣。
get a new generator, otherwise everything else is the same.

129
00:08:23.634 --> 00:08:26.399
那麼，誰有什麼管用的東西？
So, who got something that works?

130
00:08:26.399 --> 00:08:29.961
有沒有人試著用艱難的方式來做這件事？
Did anybody try to do it the hard way?

131
00:08:29.961 --> 00:08:31.403
函式式程式設計的第一條規則。
First rule of functional programming.

132
00:08:31.403 --> 00:08:34.561
是的，讓函式來做這件事。
Yeah, let functions do the work.

133
00:08:34.561 --> 00:08:39.625
所以，我想談談我強調的條件。
So, I want to talk about the condition that I underlined.

134
00:08:39.625 --> 00:08:42.408
我可以用三種方式寫下這句話。
There are three ways I could have written that.

135
00:08:42.408 --> 00:08:49.734
這是我要顯式查詢的第一個函式，是否傳入了unfinition。
That's the first one where I'm looking for explicitly, did undefined get passed in.

136
00:08:49.734 --> 00:08:53.024
也就是說什麼都沒傳進來。
Which means did nothing get passed in.

137
00:08:53.024 --> 00:08:58.452
我可以寫的另一種方式是，性別的型別等於功能嗎？
Another way I could have written it is, is the type of gen equal to function?

138
00:08:58.452 --> 00:09:01.801
所以如果他們傳入了一些東西，但這不是一個函式，
So if they passed in something but it wasn't a function,

139
00:09:01.801 --> 00:09:03.419
我們會把它變成一個函式。
we'll make it a function.

140
00:09:03.419 --> 00:09:07.673
所以這兩種方法的不同之處在於
So the difference between those two approaches is

141
00:09:07.673 --> 00:09:11.724
第二個往往總是成功的，而且
the second one will tend to always succeed, and

142
00:09:11.724 --> 00:09:17.005
如果傳入了一些不好的東西，第一個將傾向於失敗。
the first one will tend to fail if something bad was passed in.

143
00:09:17.005 --> 00:09:20.708
這通常取決於您的應用程式的特性，
And it depends on the characteristics of your application generally,

144
00:09:20.708 --> 00:09:24.485
快速失敗是您想要的，因為它可以幫助您更快地發現錯誤。
fast failure is what you want because it helps you discover bugs faster.

145
00:09:24.485 --> 00:09:29.078
但有時您的程式碼非常關鍵，您需要確保
But sometimes you got code which is really critical, and you wanna be sure that

146
00:09:29.078 --> 00:09:32.571
不管發生什麼，這個程式碼都會正常工作。
no matter what happens this code is gonna be working right.

147
00:09:32.571 --> 00:09:38.236
第三種寫這種情況的方法是做一個看漲檢查。
The third way you could write that condition would be to do a bullish check.

148
00:09:38.236 --> 00:09:44.081
如果不是GEN，那就做點什麼，我不喜歡那樣。
if not gen then do something and I don't like that.

149
00:09:44.081 --> 00:09:49.374
因為我們在製造這種情況的過程中想要做的就是把整個
Because what we're trying to do in making the condition is divide the whole

150
00:09:49.374 --> 00:09:54.846
可能的宇宙變成兩種狀態中的一種，要麼是，要麼不是。
universe of possibilities into one of two states that either is or it isn't.

151
00:09:54.846 --> 00:10:00.096
看漲的案例以一種非常奇怪的方式將其分裂，
And the bullish case splits it in a really weird way in that,

152
00:10:00.096 --> 00:10:04.402
如果他們打進一杆的話，行為會非常，
if they pass in a one, the behavior will be very,

153
00:10:04.402 --> 00:10:08.394
與他們通過零的時候有很大的不同。
very different than if they passed in a zero.

154
00:10:08.394 --> 00:10:12.388
在我看來，零分之一的人應該表現得如此不同，這對我來說是沒有意義的
And it doesn't make sense to me that one in zero should behave that differently

155
00:10:12.388 --> 00:10:14.274
當我們在尋找函式時。
when we're looking for a function.

156
00:10:14.274 --> 00:10:19.423
這就是為什麼我認為JavaScript依賴於布林值和
So this is why I think that JavaScript depending on boolish values and

157
00:10:19.423 --> 00:10:24.331
條件是一個錯誤，我建議總是更明確。
conditions was a mistake, I recommend always be more explicit.

158
00:10:24.331 --> 00:10:28.706
或者想一想，我是想要快速失敗的問題，還是
Either figure out, do I want the fast failure question or

159
00:10:28.706 --> 00:10:32.899
我想要意志似乎總是成功的問題嗎，但是
do I want the will seem to always succeed question, but

160
00:10:32.899 --> 00:10:39.025
不是方便的那個，它可以以意想不到的方式跨越這兩個方面。
not the the convenient one which can straddle both of those in unexpected ways.

161
00:10:39.025 --> 00:10:39.938
嗯。
Yeah.

162
00:10:39.938 --> 00:10:45.268
&gt；&gt；[INAUDIBLE]&gt；&gt；Douglas：在這種情況下，
&gt;&gt; [INAUDIBLE] &gt;&gt; Douglas: In that case,

163
00:10:45.268 --> 00:10:46.986
那也會很好用的。
that'll work fine too.

164
00:10:46.986 --> 00:10:52.879
我們會永遠走下去，但我們會跑到盡頭，發現事情是這樣的
From we'll keep going forever but we run into the end to find things so

165
00:10:52.879 --> 00:10:56.548
它會停下來的，所以它自己也可以。
it'll stop so from by itself is also okay.

166
00:10:56.548 --> 00:10:57.575
還有其他人嗎？
Anybody else?

167
00:10:57.575 --> 00:11:04.392
&gt；&gt；揚聲器4：[聽不見]那個時候，
&gt;&gt; Speaker 4: [INAUDIBLE] That when,

168
00:11:04.392 --> 00:11:09.414
因為你說過
because you said

169
00:11:09.414 --> 00:11:16.591
未定義的，與之相對的
undefined, as opposed

170
00:11:16.591 --> 00:11:21.985
去布林廣場。
to boole square.

171
00:11:21.985 --> 00:11:22.494
&gt；&gt；道格拉斯：對。
&gt;&gt; Douglas: Right.

172
00:11:22.494 --> 00:11:24.549
所以，我過去推薦使用邏輯OR
So, I used to recommend using the logical OR

173
00:11:24.549 --> 00:11:27.005
接線員去做你建議的事情。
operator to do something like you're suggesting.

174
00:11:27.005 --> 00:11:29.150
替換預設值和
To replace default values and

175
00:11:29.150 --> 00:11:33.798
我已經不推薦了，因為它太危險了。
I've stopped recommending that because it's too hazardous.

176
00:11:33.798 --> 00:11:38.698
如果有人傳了個零，零就是錯誤的，所以
That if someone passes in a zero, zero is falsely and so

177
00:11:38.698 --> 00:11:43.717
如果我們沒有預料到它會被替換的話，它可能會被替換。
it might get replaced in cases we don't expect it will.

178
00:11:43.717 --> 00:11:46.088
這是有問題的，所以
And that's problematic so

179
00:11:46.088 --> 00:11:52.177
我現在建議你應該明確一點，不要依賴粗魯的卡盤。
I now recommend instead be explicit don't depend on boolish chucks.
