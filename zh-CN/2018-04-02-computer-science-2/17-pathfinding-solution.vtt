WEBVTT

1
00:00:00.210 --> 00:00:01.750
&gt;&gt; Brian Holt: So welcome back.

2
00:00:01.750 --> 00:00:05.020
Hopefully you're able to
feel your brain a little bit

3
00:00:06.340 --> 00:00:07.830
before we start melting it again.

4
00:00:07.830 --> 00:00:13.870
[LAUGH]
We talked about pathfinding last time.

5
00:00:13.870 --> 00:00:18.466
We gave you the exercise and so what we're
gonna do now is we're gonna go through and

6
00:00:18.466 --> 00:00:21.235
write it together so
we can see what it looks like.

7
00:00:27.344 --> 00:00:30.586
&gt;&gt; Brian Holt: Let's go ahead and

8
00:00:30.586 --> 00:00:33.110
get started.

9
00:00:33.110 --> 00:00:36.860
So the first thing that I'm
gonna do is I'm just gonna make

10
00:00:38.290 --> 00:00:41.070
three different flags of

11
00:00:44.570 --> 00:00:50.140
has this particular note been opened by
no one, has it been opened by someone and

12
00:00:50.140 --> 00:00:54.450
like which person has been opened by or
which origin point rather.

13
00:00:54.450 --> 00:01:00.089
So no one,
&gt;&gt; Brian Holt: Equals

14
00:01:00.089 --> 00:01:05.043
zero Const by A equals 1,

15
00:01:05.043 --> 00:01:09.780
and const by B equals 2.

16
00:01:09.780 --> 00:01:12.710
Now, I could just put those
numbers directly in there, but

17
00:01:12.710 --> 00:01:16.150
the reason why I like doing this is so it
makes my code a little bit more readable.

18
00:01:16.150 --> 00:01:20.430
So if these two aren't equal to each
other it means something's up and

19
00:01:20.430 --> 00:01:23.290
we should investigate.

20
00:01:24.550 --> 00:01:29.680
Wonder why my, well,
it's different, it is what it is.

21
00:01:29.680 --> 00:01:30.540
Okay.

22
00:01:30.540 --> 00:01:34.070
So, we're gonna start by doing that.

23
00:01:34.070 --> 00:01:37.750
Next, we're gonna go start
writing our algorithm.

24
00:01:39.630 --> 00:01:44.270
Actually, lets go ahead and
write Get neighbors as well.

25
00:01:44.270 --> 00:01:46.320
Because this is going to
be a useful function.

26
00:01:46.320 --> 00:01:48.940
Like helper function for
us that we talked about.

27
00:01:48.940 --> 00:01:54.310
The basic idea being if I have
one part of the graph, I'm going

28
00:01:54.310 --> 00:01:59.190
to investigate above it, to the right
of it, below it, and to the left of it.

29
00:02:04.320 --> 00:02:07.612
[COUGH] This will be useful because we
can contain all the logic in therefore,

30
00:02:07.612 --> 00:02:08.744
checking if it's a wall,

31
00:02:08.744 --> 00:02:11.430
checking if it's like all those
various checks we have to do.

32
00:02:13.350 --> 00:02:16.110
That will be useful to kind
of contain in one place.

33
00:02:16.110 --> 00:02:19.880
It will make it testable and
those, you know kind of idea.

34
00:02:19.880 --> 00:02:23.750
So I'm gonna call it getNeighbors and and

35
00:02:23.750 --> 00:02:27.800
it's gonna take in visited,
which is what I'm calling my graph.

36
00:02:29.060 --> 00:02:31.979
And it's gonna take in a point,

37
00:02:31.979 --> 00:02:39.010
okay?
&gt;&gt; Brian Holt: So

38
00:02:39.010 --> 00:02:42.780
this neighbors array is
gonna be valid neighbors.

39
00:02:42.780 --> 00:02:46.420
This is eventually what I'm
going to return at the bottom.

40
00:02:46.420 --> 00:02:49.571
And then I'm just gonna
go check all the sides.

41
00:02:51.851 --> 00:02:54.378
&gt;&gt; Brian Holt: So the first thing I'm

42
00:02:54.378 --> 00:03:02.228
gonna say is, if y minus 1,
&gt;&gt; Brian Holt: Is greater than or

43
00:03:02.228 --> 00:03:09.890
equal to 0, again, this is a ligature that
combines those two things together, right?

44
00:03:09.890 --> 00:03:13.880
If I put a space between those
it's less than equal to, but

45
00:03:13.880 --> 00:03:16.550
if I put them together,
that's just my font, right?

46
00:03:18.080 --> 00:03:23.103
Sometimes that confuses people.
&gt;&gt; Brian Holt: And

47
00:03:23.103 --> 00:03:27.528
If it's not closed, so

48
00:03:27.528 --> 00:03:33.292
visited y minus 1 x.closed.

49
00:03:33.292 --> 00:03:39.410
This is going to the left, right?

50
00:03:41.010 --> 00:03:44.460
I think so yeah, it's going to the left.

51
00:03:44.460 --> 00:03:48.343
Then we're going to say,

52
00:03:48.343 --> 00:03:53.287
neighbors.push visited y minus

53
00:03:53.287 --> 00:03:58.070
1 of x, this confuses people.

54
00:03:58.070 --> 00:04:03.290
You're used to see X Y, right?

55
00:04:03.290 --> 00:04:07.310
But if you think about it as this
is an array of arrays, right?

56
00:04:07.310 --> 00:04:08.430
This is an array of arrays, right?

57
00:04:08.430 --> 00:04:13.710
So actually the Y column is
represented by the first array and

58
00:04:13.710 --> 00:04:15.640
the X column is represented
by the second array.

59
00:04:15.640 --> 00:04:19.050
Which is why you're gonna do
Y is the first accessor and

60
00:04:19.050 --> 00:04:22.650
X is the second accessor
does that make sense to you?

61
00:04:22.650 --> 00:04:27.430
You can do a bunch of backwards thinking
to get it to go the other way but

62
00:04:27.430 --> 00:04:30.470
just don't [LAUGH] I
promise this is easier.

63
00:04:33.090 --> 00:04:37.840
Okay, so does this make sense
what we're doing right here?

64
00:04:37.840 --> 00:04:42.950
We're just saying If this is
not out of bounds, right,

65
00:04:42.950 --> 00:04:47.260
so if it's not below zero and
it's not closed.

66
00:04:47.260 --> 00:04:50.520
We're going to make this data structure
that's going to make this true later.

67
00:04:50.520 --> 00:04:52.120
But closed just means that it's not a one.

68
00:04:52.120 --> 00:04:55.700
You could have just as easily said,
triple equals one, here, right?

69
00:04:57.240 --> 00:04:59.980
Then put that into a valid neighbor.

70
00:04:59.980 --> 00:05:01.530
And we're gonna do that for
each one of these.

71
00:05:01.530 --> 00:05:05.480
In fact I'm just gonna copy and paste
'cuz we all know that I'm good at that.

72
00:05:08.940 --> 00:05:13.770
So this one we're gonna go right.

73
00:05:13.770 --> 00:05:18.853
So this is gonna be y plus

74
00:05:18.853 --> 00:05:23.683
1 is less than visited

75
00:05:23.683 --> 00:05:28.547
0.length, right?

76
00:05:28.547 --> 00:05:34.570
Again, to the graph that
I'm giving you is a square,

77
00:05:34.570 --> 00:05:40.820
right, so you can just check the row
of the first, the first row's length.

78
00:05:40.820 --> 00:05:45.130
And say is this outside of the bounds
of that particular row, right?

79
00:05:45.130 --> 00:05:49.193
Does that make sense?
&gt;&gt; Brian Holt: And then here, and

80
00:05:49.193 --> 00:05:57.470
it's not closed.
&gt;&gt; Brian Holt: Then push that in, right?

81
00:05:59.990 --> 00:06:03.391
And this is gonna check to the right,
so far so

82
00:06:03.391 --> 00:06:09.207
good?
&gt;&gt; Brian Holt: Okay, let's go ahead and

83
00:06:09.207 --> 00:06:16.356
do up.
&gt;&gt; Brian Holt: So

84
00:06:16.356 --> 00:06:21.633
now, we're gonna do x plus 1 is greater

85
00:06:21.633 --> 00:06:27.940
than visited 0.length.
&gt;&gt; Brian Holt: Did I,

86
00:06:27.940 --> 00:06:29.200
I did mess this up, didn't I?

87
00:06:29.200 --> 00:06:35.120
It actually doesn't matter because so
this should be, right?

88
00:06:35.120 --> 00:06:36.780
Yep, that is.

89
00:06:36.780 --> 00:06:40.070
This wasn't a bug because everything
I gave you was a square, too.

90
00:06:40.070 --> 00:06:41.292
Which may not always be true.

91
00:06:41.292 --> 00:06:46.183
But nonetheless,
x plus 1 is less than visited 0.length.

92
00:06:46.183 --> 00:06:50.397
And visited y of x plus 1.

93
00:06:50.397 --> 00:06:53.758
y plus

94
00:06:53.758 --> 00:06:59.573
1.
&gt;&gt; Brian Holt: Then

95
00:06:59.573 --> 00:07:04.721
we're gonna push in neighbors.
&gt;&gt; Brian Holt: Of yx

96
00:07:04.721 --> 00:07:09.856
plus1.
&gt;&gt; Brian Holt: Okay?

97
00:07:09.856 --> 00:07:16.756
That was up.
&gt;&gt; Brian Holt: And

98
00:07:16.756 --> 00:07:22.170
lastly, we're gonna go down.
&gt;&gt; Brian Holt: Down, down.

99
00:07:23.410 --> 00:07:25.230
Now, we're doing the get
neighbors function.

100
00:07:25.230 --> 00:07:28.730
We're gonna use that inside of our
function that we're about to write up.

101
00:07:28.730 --> 00:07:32.300
If we were gonna do diagonals as well,
if that was gonna be a valid move,

102
00:07:32.300 --> 00:07:35.080
we would just put some more function or
more checks in here.

103
00:07:35.080 --> 00:07:39.350
To say can I go northeast, can I go
northwest, southeast, southwest, right?

104
00:07:39.350 --> 00:07:43.403
And that's all you would have to do to
add diagonals functionality to this code,

105
00:07:43.403 --> 00:07:49.257
which is pretty cool I think.
&gt;&gt; Brian Holt: So

106
00:07:49.257 --> 00:07:57.542
this is actually down, I believe.
&gt;&gt; Brian Holt: Yeah,

107
00:07:57.542 --> 00:08:01.466
it's down.
&gt;&gt; Brian Holt: Cardinality

108
00:08:01.466 --> 00:08:02.036
is a weird thing.

109
00:08:02.036 --> 00:08:08.392
[LAUGH] It all depends on what
perspective you're taking on it.

110
00:08:08.392 --> 00:08:12.290
x + 1, so we're gonna do x- 1 &gt; 0.

111
00:08:24.300 --> 00:08:25.383
&gt;&gt; Brian Holt: Greater than or

112
00:08:25.383 --> 00:08:27.389
equal to cuz you can go to 0.

113
00:08:27.389 --> 00:08:30.760
And this is going to be x- 1.

114
00:08:36.650 --> 00:08:39.631
&gt;&gt; Brian Holt: And the new approach, x- 1.

115
00:08:39.631 --> 00:08:43.810
There we go, okay.

116
00:08:43.810 --> 00:08:47.420
So far, you're just gonna get
all of the valid neighbors.

117
00:08:47.420 --> 00:08:48.610
So that's all this function's gonna do for
you.

118
00:08:48.610 --> 00:08:50.669
And that makes it really easy for

119
00:08:50.669 --> 00:08:55.320
us in the above function to be able
to go through each one of those.

120
00:08:55.320 --> 00:09:00.700
And check if we've intersected and
all that kind of stuff.

121
00:09:00.700 --> 00:09:08.227
So now that we've done that, let's go back
up to our findShortestPath function and

122
00:09:08.227 --> 00:09:17.111
start on that.
&gt;&gt; Brian Holt: So

123
00:09:17.111 --> 00:09:21.948
the first thing what we're going to do
is massage this maze data structure

124
00:09:21.948 --> 00:09:24.690
into something a little bit more useful.

125
00:09:26.690 --> 00:09:29.508
So I'm gonna call this visited.

126
00:09:29.508 --> 00:09:34.470
And we're gonna do maze.map.

127
00:09:34.470 --> 00:09:40.120
If your not familiar with map, again,
I suggest you check out the first course.

128
00:09:40.120 --> 00:09:43.273
There's a whole section on what is map.

129
00:09:43.273 --> 00:09:47.583
There's also plenty of stuff on
Frontend Masters from Brian Lonsdorf and

130
00:09:47.583 --> 00:09:50.930
Kyle Simpson about functional
programming in general.

131
00:09:50.930 --> 00:09:54.955
But the too long didn't read
version of what map is,

132
00:09:54.955 --> 00:09:58.990
is it's a function that
takes in another function.

133
00:09:58.990 --> 00:10:02.620
And it's going to apply that function
to every item in your array.

134
00:10:02.620 --> 00:10:06.881
Whatever that function returns on that
individual item is going to be the new

135
00:10:06.881 --> 00:10:08.682
value in the array.

136
00:10:08.682 --> 00:10:13.360
So just to give you a really quick
demo of that, if I do 1,2,3.

137
00:10:13.360 --> 00:10:17.666
So an array of 1,2,3 and I say .map.

138
00:10:17.666 --> 00:10:22.183
And now I'm gonna give it a function
that all I want it to do is double

139
00:10:22.183 --> 00:10:24.920
the numbers in the array.

140
00:10:24.920 --> 00:10:28.004
So it's gonna be function, oops, num.

141
00:10:28.004 --> 00:10:32.853
And that's just going to return x x 2, or

142
00:10:32.853 --> 00:10:39.077
num x 2 rather.
&gt;&gt; Brian Holt: So

143
00:10:39.077 --> 00:10:43.420
what I would expect back is to get 2,
4, 6, right?

144
00:10:43.420 --> 00:10:47.320
2, 4, 6, so that's what map does.

145
00:10:47.320 --> 00:10:51.130
Whatever this function does, it's going
to be run on every item in the array.

146
00:10:51.130 --> 00:10:54.370
And then whatever is returned there
is going to be the new array.

147
00:10:54.370 --> 00:10:55.659
So it's a very, very valuable function.

148
00:10:55.659 --> 00:11:00.060
If you're not familiar with it,
I definitely suggest deep diving.

149
00:11:00.060 --> 00:11:02.980
I use this dozens of time a day.

150
00:11:02.980 --> 00:11:06.237
Probably not exaggerating,
probably a dozen times a day.

151
00:11:06.237 --> 00:11:08.000
So that's what we're doing here.

152
00:11:09.460 --> 00:11:10.905
What I showed you here
is a simple example.

153
00:11:10.905 --> 00:11:13.934
But, please go away.

154
00:11:13.934 --> 00:11:16.572
Okay, there we go.

155
00:11:16.572 --> 00:11:21.538
[COUGH] The times that you're gonna
use map are the times that you say,

156
00:11:21.538 --> 00:11:26.860
I have this one array of things and
I want another array of things, right?

157
00:11:26.860 --> 00:11:30.010
I wanna transform this set of things
into this set of things, right?

158
00:11:30.010 --> 00:11:35.170
So in this case,
I have this array of arrays, right?

159
00:11:35.170 --> 00:11:37.739
And what I wanna get back is
an array of array of objects, right?

160
00:11:37.739 --> 00:11:41.530
Because I wanna be able to mark this
has been visited, this is the value.

161
00:11:41.530 --> 00:11:42.438
This is how far away,

162
00:11:42.438 --> 00:11:45.220
I wanna be able to associate some
metadata associated with that.

163
00:11:45.220 --> 00:11:47.500
So that's what I'm gonna
do up here in this map.

164
00:11:49.276 --> 00:11:50.939
&gt;&gt; Brian Holt: So I'm gonna say row map,

165
00:11:50.939 --> 00:11:57.578
and I'm gonna say,
&gt;&gt; Brian Holt: row, y, right?

166
00:11:57.578 --> 00:11:59.809
The second item that you
get in there is the index.

167
00:12:01.570 --> 00:12:04.169
So this is gonna represent wherever
I am in the array on the y

168
00:12:04.169 --> 00:12:07.425
axis.
&gt;&gt; Brian Holt: Okay?

169
00:12:10.266 --> 00:12:12.312
&gt;&gt; Brian Holt: Then you have to keep in

170
00:12:12.312 --> 00:12:14.361
mind that row is what?

171
00:12:14.361 --> 00:12:17.230
Row is an array of numbers, right?

172
00:12:17.230 --> 00:12:19.830
Because working with an array
of an array of numbers.

173
00:12:19.830 --> 00:12:21.610
It's a 2D array.

174
00:12:21.610 --> 00:12:24.813
So row is gonna be an array, so

175
00:12:24.813 --> 00:12:29.568
what I wanna do is I
want to return row.map.

176
00:12:29.568 --> 00:12:32.030
So we're going to do
another map inside of here.

177
00:12:32.030 --> 00:12:35.053
So row.map and
this is going to be some point.

178
00:12:35.053 --> 00:12:40.760
Well, we can call it a point or
a cell or whatever you wanna call it.

179
00:12:40.760 --> 00:12:42.160
I think I called it origin.

180
00:12:42.160 --> 00:12:46.580
But let's go with point.

181
00:12:46.580 --> 00:12:47.205
That might make more sense.

182
00:12:47.205 --> 00:12:48.960
It's one point on the graph.

183
00:12:50.390 --> 00:12:54.550
And the index that here is gonna
be represented as the x axis.

184
00:12:54.550 --> 00:13:00.030
Cool, do we follow so far?
&gt;&gt; Brian Holt: Now

185
00:13:00.030 --> 00:13:04.140
you could definitely do this without map.

186
00:13:04.140 --> 00:13:11.190
I just find this to be, it simplifies
the mental model for me, okay?

187
00:13:11.190 --> 00:13:17.440
Now what we're going to do here is
we're going to return an object.

188
00:13:20.150 --> 00:13:22.880
The first thing that I want it
keeping track of, is it closed, right?

189
00:13:23.880 --> 00:13:31.206
We know if a thing is closed if the point
===, again, people find that weird.

190
00:13:31.206 --> 00:13:34.141
That's my ===, right?

191
00:13:34.141 --> 00:13:38.793
So if I say ===, so
if you see the three lines that's what

192
00:13:38.793 --> 00:13:43.608
that is.
&gt;&gt; Brian Holt: 1,

193
00:13:43.608 --> 00:13:46.300
then we know that that point is closed.

194
00:13:46.300 --> 00:13:49.030
It's a wall,
you can't go through it, okay?

195
00:13:49.030 --> 00:13:52.500
The length at time of creation is 0,
right?

196
00:13:52.500 --> 00:13:53.806
Because we haven't touched it yet.

197
00:13:53.806 --> 00:13:56.956
openedBy, openedBy,

198
00:13:56.956 --> 00:14:02.250
it's been opened by NO_ONE, right?

199
00:14:02.250 --> 00:14:03.702
Remember this up here?

200
00:14:03.702 --> 00:14:08.157
So that's what that represents.
&gt;&gt; Brian Holt: And

201
00:14:08.157 --> 00:14:12.510
then lastly, we wanna put in the x y
value for every one of these, right?

202
00:14:13.580 --> 00:14:15.850
So you can put x: x.

203
00:14:15.850 --> 00:14:17.700
Because we're using modern JavaScript,
you can just put x and y.

204
00:14:17.700 --> 00:14:21.255
It's the same thing, right?

205
00:14:21.255 --> 00:14:25.912
x: x, or just x.
&gt;&gt; Brian Holt: Cool.

206
00:14:28.390 --> 00:14:30.043
&gt;&gt; Brian Holt: So now I have this really

207
00:14:30.043 --> 00:14:33.848
useful data structure that I
can start working the grid

208
00:14:33.848 --> 00:14:38.992
with.
&gt;&gt; Brian Holt: So

209
00:14:38.992 --> 00:14:41.529
the first thing I'm gonna
do is I'm going to go mark.

210
00:14:46.254 --> 00:14:48.696
&gt;&gt; Brian Holt: visited [yA] and

211
00:14:48.696 --> 00:14:54.346
[xA] as being visited by itself, right?

212
00:14:54.346 --> 00:14:58.791
That follows.
&gt;&gt; Brian Holt: So

213
00:14:58.791 --> 00:15:06.968
openedBy = BY_A.

214
00:15:06.968 --> 00:15:09.369
Same thing down here for B.
&gt;&gt; [COUGH]

215
00:15:09.369 --> 00:15:11.552
&gt;&gt; Brian Holt: Bless you.

216
00:15:14.420 --> 00:15:15.503
&gt;&gt; Brian Holt: Then after that,

217
00:15:15.503 --> 00:15:18.250
we're going to go mark
B as being marked by B.

218
00:15:20.560 --> 00:15:22.030
&gt;&gt; Brian Holt: We still follow?

219
00:15:22.030 --> 00:15:24.260
Right, makes sense that something,
the origin has been opened by itself.

220
00:15:28.585 --> 00:15:30.474
&gt;&gt; Brian Holt: Now we're gonna go and

221
00:15:30.474 --> 00:15:34.160
do two depth first traversals with these.

222
00:15:34.160 --> 00:15:35.910
Or sorry, not depth first, breadth first.

223
00:15:35.910 --> 00:15:37.592
I don't know what I'm talking about.

224
00:15:37.592 --> 00:15:42.050
Keep up, okay, so
just kidding, that's terrible.

225
00:15:43.060 --> 00:15:46.606
let, we're gonna have an aQueue and
a bQueue.

226
00:15:46.606 --> 00:15:50.950
let aQueue, I know it's weird terminology.

227
00:15:52.870 --> 00:15:54.670
So what we're gonna put,
we're gonna put one item in this.

228
00:15:54.670 --> 00:15:55.210
We're gonna put the origin, right?

229
00:15:55.210 --> 00:15:56.860
Cuz that's where we're gonna start.

230
00:15:56.860 --> 00:16:04.249
So we're gonna put Visited yA xA, right?

231
00:16:04.249 --> 00:16:09.545
It's gonna be an array, right,
because when you keep continuing

232
00:16:09.545 --> 00:16:14.950
putting things in there and
take out there, and same thing with pQ.

233
00:16:16.190 --> 00:16:19.490
This is what I was saying, that you could
be clever and do this with one queue,

234
00:16:19.490 --> 00:16:21.070
well, you can't do it with one queue.

235
00:16:21.070 --> 00:16:23.790
But you could do it with one function,
but don't.

236
00:16:23.790 --> 00:16:29.248
This is just a lot clearer to write this
way, even if it is a little repeating

237
00:16:29.248 --> 00:16:35.581
yourself.
&gt;&gt; Brian Holt: Okay,

238
00:16:35.581 --> 00:16:39.340
and then we also have to keep track
of the iteration that we are on.

239
00:16:39.340 --> 00:16:47.900
So let iteration equal zero
because we have to mark.

240
00:16:47.900 --> 00:16:51.580
This is one away, two away, and three
away for the iteration to keep track of.

241
00:16:55.540 --> 00:17:03.574
So now,
down here we are going to have a Y loop,

242
00:17:03.574 --> 00:17:11.615
while aqueue.length &amp;&amp; bqueue.length.

243
00:17:11.615 --> 00:17:15.026
Right, because if we have
a maze that's unsolvable,

244
00:17:15.026 --> 00:17:17.630
eventually one of these is gonna run out.

245
00:17:17.630 --> 00:17:19.710
And if one of them runs out,
you'll instantly know.

246
00:17:19.710 --> 00:17:21.530
It doesn't matter what
the other one is gonna do,

247
00:17:21.530 --> 00:17:23.450
there's no way to get to the other one.

248
00:17:23.450 --> 00:17:27.640
So if that's true, then you're going to
return negative 1 down here at the bottom.

249
00:17:28.870 --> 00:17:34.800
Because, if it's not case, then we'll
know somewhere in the loop here,

250
00:17:34.800 --> 00:17:41.701
we'll just return that number.
&gt;&gt; Brian Holt: Cool,

251
00:17:41.701 --> 00:17:46.604
so first thing we're gonna do is we're
gonna start out by going iteration,

252
00:17:46.604 --> 00:17:49.370
plus plus, cuz it's the next iteration.

253
00:17:50.920 --> 00:17:56.371
And we're going to set.
&gt;&gt; Brian Holt: First

254
00:17:56.371 --> 00:17:59.160
thing we're gonna do is we're
gonna go get As neighbors.

255
00:17:59.160 --> 00:18:03.660
So we're gonna say ,const aNeighbors.

256
00:18:11.040 --> 00:18:14.670
So what you need to do is you need to go
through everything that's currently in

257
00:18:14.670 --> 00:18:15.730
the a queue.

258
00:18:15.730 --> 00:18:18.460
I mean, you need to go get
all its neighbors, right?

259
00:18:19.480 --> 00:18:23.880
So if I have four things in the aQueue,
I need to go get all of the neighbors for

260
00:18:23.880 --> 00:18:24.580
all of those, right?

261
00:18:24.580 --> 00:18:29.210
So that could end up being, four times
four, it could be quite a few neighbors.

262
00:18:29.210 --> 00:18:33.300
And as you get further and further out,
you have the potential to have lots and

263
00:18:33.300 --> 00:18:38.106
lots and lots of neighbors.
&gt;&gt; Brian Holt: So you can,

264
00:18:38.106 --> 00:18:42.310
however you want to do this
is totally up to you, right?

265
00:18:42.310 --> 00:18:44.890
You can have a for
loop that keeps them all together.

266
00:18:44.890 --> 00:18:48.600
Me being someone that likes a little
bit more functional approach to things,

267
00:18:48.600 --> 00:18:51.490
you can implement this
fairly easy as a reduce.

268
00:18:52.610 --> 00:18:58.160
So just to give you
the five second version,

269
00:18:58.160 --> 00:19:00.110
maybe 15 second version
of what it reduces.

270
00:19:00.110 --> 00:19:03.240
One, two, three, right, and I say reduce.

271
00:19:03.240 --> 00:19:06.440
This is going to take in a function, but

272
00:19:06.440 --> 00:19:11.420
it's reducing an array of things
down to another something.

273
00:19:11.420 --> 00:19:16.360
So in this particular case, I'm gonna have
usually it's called acc for accumulator.

274
00:19:16.360 --> 00:19:21.530
I did not invent that so and
it's gonna be some number.

275
00:19:21.530 --> 00:19:25.090
And let's just I want to add all
those numbers together, right?

276
00:19:25.090 --> 00:19:29.470
So what I'm going to do is
it's going to return acc plus

277
00:19:29.470 --> 00:19:35.105
number.
&gt;&gt; Brian Holt: And

278
00:19:35.105 --> 00:19:37.870
this should just add them all together,
right?

279
00:19:37.870 --> 00:19:38.910
So I get six, right?

280
00:19:38.910 --> 00:19:40.760
Which is all of them added together,
right?

281
00:19:40.760 --> 00:19:44.030
So what acc is the result
of the previous iteration.

282
00:19:44.030 --> 00:19:48.910
So it starts out with one because it just
pulls the first item off the list, right?

283
00:19:48.910 --> 00:19:53.180
And then it goes through
[COUGH] it returns that.

284
00:19:53.180 --> 00:19:57.710
So this is going to be one, and
then it's going to add two to it and

285
00:19:57.710 --> 00:19:59.870
then it's gonna add three to it and
then we end up with six, right?

286
00:19:59.870 --> 00:20:01.790
Do we understand more or
less what reduce is?

287
00:20:01.790 --> 00:20:04.800
So the times we wanna use reduce is
when you have an array of something and

288
00:20:04.800 --> 00:20:09.320
you want to basically in some way
combine it with the other elements in

289
00:20:09.320 --> 00:20:13.819
the array.
&gt;&gt; Brian Holt: Not quite as useful as map,

290
00:20:13.819 --> 00:20:16.960
but I still use it quite frequently.

291
00:20:16.960 --> 00:20:20.450
Like if I use math 50% of the time,
I use reduce 10% of the time, or

292
00:20:20.450 --> 00:20:21.330
something like that.

293
00:20:25.040 --> 00:20:30.639
Okay.
&gt;&gt; Brian Holt: So

294
00:20:30.639 --> 00:20:35.733
what I'm going to do is,
aQueue, it's going to be

295
00:20:35.733 --> 00:20:40.716
a reduce function.
&gt;&gt; Brian Holt: So

296
00:20:40.716 --> 00:20:43.550
it's gonna be that accumulator, right?

297
00:20:43.550 --> 00:20:48.240
Now in this particular case, I have
an array of these various items, right?

298
00:20:50.250 --> 00:20:54.730
What I want to do is I wanna have
an array of all its neighbors.

299
00:20:54.730 --> 00:20:57.140
So that's what I'm gonna
write in terms of a reduce.

300
00:20:57.140 --> 00:21:03.640
So neighbor, and
what I am going to return.

301
00:21:03.640 --> 00:21:11.010
I want to return acc which
is going to be an array.

302
00:21:11.010 --> 00:21:18.039
I'm going to call concat which is,
I'm gonna add another array to it.

303
00:21:19.040 --> 00:21:23.953
That's gonna be a result of

304
00:21:23.953 --> 00:21:29.296
getNeighbors with visited,

305
00:21:29.296 --> 00:21:36.360
neighbor.x and neighbor.y, okay?

306
00:21:36.360 --> 00:21:37.760
You follow so far?

307
00:21:38.910 --> 00:21:43.520
I will also say that this also could be
implemented as a map and flatten, but

308
00:21:43.520 --> 00:21:45.000
we don't have flatten yet.

309
00:21:45.000 --> 00:21:48.040
In fact, if you've been following the
Twitter drama this week, they're debating

310
00:21:48.040 --> 00:21:55.150
if they wanna call it smush or flatten.
&gt;&gt; Brian Holt: JavaScript is weird.

311
00:21:55.150 --> 00:21:56.270
That's all I'm gonna say.

312
00:21:56.270 --> 00:21:57.460
It's a ridiculous argument.

313
00:21:59.020 --> 00:22:01.328
I'm not upset, okay, let's keep going.

314
00:22:01.328 --> 00:22:06.808
So that's there,
if you don't provide reduced

315
00:22:06.808 --> 00:22:13.090
seed value it just pulls
the first time off the array.

316
00:22:13.090 --> 00:22:16.000
We don't actually want it to be the first
time in the array we want it to be

317
00:22:16.000 --> 00:22:16.540
an empty array.

318
00:22:16.540 --> 00:22:19.130
So that's going to be the first acc,
right?

319
00:22:19.130 --> 00:22:21.290
So the first acc,
we want it to be an array, so

320
00:22:21.290 --> 00:22:30.952
that's what we provided here.
&gt;&gt; Brian Holt: So

321
00:22:30.952 --> 00:22:34.402
even if this is a little
bit difficult to read for

322
00:22:34.402 --> 00:22:38.644
those of you that are not more
functionally oriented yet.

323
00:22:38.644 --> 00:22:44.312
One, I have faith in you, and, two,
what this does is I have an array of

324
00:22:44.312 --> 00:22:50.140
next notes to process and this just
gets me all of the neighbors of that.

325
00:22:50.140 --> 00:22:54.090
That's what this blob of code does, cool?

326
00:22:55.500 --> 00:23:00.009
Okay.
&gt;&gt; Brian Holt: So next thing I'm gonna do

327
00:23:00.009 --> 00:23:02.798
here is I'm gonna go through every
item in this particular list, and

328
00:23:02.798 --> 00:23:03.870
I'm going to process it.

329
00:23:04.980 --> 00:23:09.390
So I'm gonna say, for

330
00:23:09.390 --> 00:23:12.871
let i equal to 0,

331
00:23:12.871 --> 00:23:18.211
i less than any neighbors,

332
00:23:18.211 --> 00:23:24.490
rather, .length i plus plus.

333
00:23:26.050 --> 00:23:27.130
The typical full loop.

334
00:23:28.870 --> 00:23:32.989
So the current neighbor I'm on.

335
00:23:32.989 --> 00:23:34.294
Let's just put some space there so

336
00:23:34.294 --> 00:23:39.513
you can see.
&gt;&gt; Brian Holt: neighbor

337
00:23:39.513 --> 00:23:43.900
equals aNeighbors of i, right?

338
00:23:43.900 --> 00:23:46.320
That's the current thing that
we're on at this moment in time.

339
00:23:51.760 --> 00:23:56.472
&gt;&gt; Brian Holt: Then, The first thing

340
00:23:56.472 --> 00:23:59.291
that we're going to check
because we're processing a.

341
00:23:59.291 --> 00:24:04.075
If the current neighbor that
we're on has been processed by b,

342
00:24:04.075 --> 00:24:06.280
we've solved it, right?

343
00:24:06.280 --> 00:24:07.990
We've intersected with the other one so
we've found the answer.

344
00:24:07.990 --> 00:24:09.840
So that's the first thing
that we're gonna check.

345
00:24:11.286 --> 00:24:15.025
&gt;&gt; Brian Holt: So if (neighbor.openedBy

346
00:24:15.025 --> 00:24:21.723
=== BY_B),
then we have solved the problem,

347
00:24:21.723 --> 00:24:25.655
right?
&gt;&gt; Brian Holt: So

348
00:24:25.655 --> 00:24:33.266
what you're gonna do is you're gonna
return neighbor.length + iteration, right?

349
00:24:33.266 --> 00:24:36.227
So that basically means whereever we

350
00:24:36.227 --> 00:24:41.009
are in their currents file plus
the length of the neighbor.

351
00:24:41.009 --> 00:24:45.710
Those added together is gonna be
the correct answer of how far away I was.

352
00:24:45.710 --> 00:24:49.212
Does that make sense?
&gt;&gt; off screen male: What's

353
00:24:49.212 --> 00:24:52.961
neighbor going [INAUDIBLE]
&gt;&gt; Brian Holt: neighbor.length,

354
00:24:52.961 --> 00:24:56.250
if we go up here into this data
structure that we created.

355
00:24:57.500 --> 00:25:00.728
It's how far away it is from its origin,
right?

356
00:25:00.728 --> 00:25:04.773
So if it's opened by b,
it's 10 away from b, right?

357
00:25:04.773 --> 00:25:10.196
So it's going to be the length
of the current node plus

358
00:25:10.196 --> 00:25:16.683
the length of the neighbor node, yeah?
&gt;&gt; Brian Holt: It is,

359
00:25:16.683 --> 00:25:20.728
I assure you, but
let's understand why that is, right?

360
00:25:20.728 --> 00:25:24.297
So can I just,
let's see if I can bring this up,

361
00:25:24.297 --> 00:25:29.852
four.
&gt;&gt; Brian Holt: If we're going

362
00:25:29.852 --> 00:25:34.717
out to Pathfinding, right?

363
00:25:34.717 --> 00:25:39.580
So if I meet here, so here.

364
00:25:40.860 --> 00:25:42.795
Iteration is let's say I'm on
this node at the time, right?

365
00:25:42.795 --> 00:25:45.600
The one that I've highlighted there.

366
00:25:45.600 --> 00:25:47.090
If I'm on that node at the time,

367
00:25:47.090 --> 00:25:50.194
iteration is going to be where I am
right now at this moment in time.

368
00:25:50.194 --> 00:25:52.700
So that's going to be 3, right?

369
00:25:52.700 --> 00:25:53.986
And then I find this one,

370
00:25:53.986 --> 00:25:57.241
it's going to be plus the length
that that one is away, right?

371
00:25:57.241 --> 00:26:02.358
So those are the two numbers that we're
adding together to get the correct answer,

372
00:26:02.358 --> 00:26:03.578
yeah?
&gt;&gt; off screen female: Are we updating

373
00:26:03.578 --> 00:26:05.387
the length somewhere?
&gt;&gt; Brian Holt: Yeah,

374
00:26:05.387 --> 00:26:07.565
we'll get there.
&gt;&gt; off screen female: Okay,

375
00:26:07.565 --> 00:26:08.219
we're not-
&gt;&gt; Brian Holt: Yeah,

376
00:26:08.219 --> 00:26:10.360
we haven't gotten there yet.
&gt;&gt; off screen female: That's probably why

377
00:26:10.360 --> 00:26:12.421
it doesn't make sense.
&gt;&gt; Brian Holt: It's magical.

378
00:26:12.421 --> 00:26:13.429
[LAUGH]
&gt;&gt; off screen female: [LAUGH] I was gonna

379
00:26:13.429 --> 00:26:16.970
say, cuz I'm pretty sure all
the lengths are 0 right now.

380
00:26:16.970 --> 00:26:18.193
&gt;&gt; Brian Holt: Yeah no, I'm gonna call

381
00:26:18.193 --> 00:26:21.150
the sprinkle fairy dust function next.
&gt;&gt; off screen female: [LAUGH]

382
00:26:21.150 --> 00:26:24.351
&gt;&gt; Brian Holt: Yeah, that's a good point.

383
00:26:24.351 --> 00:26:26.340
Fair point, okay.

384
00:26:26.340 --> 00:26:30.416
So if it hasn't been opened by anyone,
then you update the length, so

385
00:26:30.416 --> 00:26:35.341
else.
&gt;&gt; Brian Holt: else if,

386
00:26:37.983 --> 00:26:42.512
&gt;&gt; Brian Holt: (neighbor.openedBy

387
00:26:42.512 --> 00:26:46.362
=== NO_ONE).

388
00:26:46.362 --> 00:26:50.989
Then we're gonna do all this updating
that we were talking about, right?

389
00:26:52.290 --> 00:26:54.330
Now there's one more case
that we haven't provided for.

390
00:26:54.330 --> 00:26:56.910
What if it's opened by A?

391
00:26:56.910 --> 00:26:59.420
Just ignore it,
it's already been processed, right?

392
00:27:01.090 --> 00:27:04.204
So a good example of that going back here.

393
00:27:04.204 --> 00:27:07.190
If I'm, let's say, here.

394
00:27:07.190 --> 00:27:08.610
I'm processing this node right here.

395
00:27:08.610 --> 00:27:11.910
It's going to see this node and
it's gonna see this node, right?

396
00:27:11.910 --> 00:27:14.180
Because those are valid neighbors, right?

397
00:27:14.180 --> 00:27:17.020
That's gonna see those
have been open by A.

398
00:27:17.020 --> 00:27:17.850
I'm not gonna check those, right?

399
00:27:17.850 --> 00:27:20.220
They have been checked.

400
00:27:20.220 --> 00:27:22.450
So that's why you're just
ignoring the opened by A case.

401
00:27:22.450 --> 00:27:24.158
Does that make some sense?

402
00:27:24.158 --> 00:27:29.944
Cool.
&gt;&gt; Brian Holt: So

403
00:27:29.944 --> 00:27:35.970
first thing we're gonna say is
neighbor.length = iteration.

404
00:27:35.970 --> 00:27:40.491
neighbor.openedBy = BY_A, right?

405
00:27:40.491 --> 00:27:43.390
Cuz it's been opened by A.

406
00:27:43.390 --> 00:27:51.520
And then what we're going to do is we're
going to push it on the aQueue, right?

407
00:27:51.520 --> 00:27:54.309
So that on the next iteration,
up here, it's gonna go okay,

408
00:27:54.309 --> 00:27:57.272
all of its neighbors and
then process all the neighbors, right?

409
00:27:57.272 --> 00:28:06.480
So that's why you push itself on there.
&gt;&gt; Brian Holt: And that's it.

410
00:28:06.480 --> 00:28:08.260
That's how you process the A part.

411
00:28:08.260 --> 00:28:11.815
Now what we're gonna do is
we're just going to copy and

412
00:28:11.815 --> 00:28:13.990
paste this little block of code.

413
00:28:15.494 --> 00:28:21.406
The one thing I did miss.
&gt;&gt; Brian Holt: You

414
00:28:21.406 --> 00:28:23.030
could do this by queueing and
dequeuing, right?

415
00:28:23.030 --> 00:28:28.024
So I could have been shifting these things
off instead of saying neighbor.length,

416
00:28:28.024 --> 00:28:29.510
whatever.

417
00:28:29.510 --> 00:28:31.749
What I'm just gonna do here is once
I've processed all the neighbors and

418
00:28:31.749 --> 00:28:32.380
I have them up here.

419
00:28:32.380 --> 00:28:36.490
I'm just gonna say aQueue = new array,
right?

420
00:28:36.490 --> 00:28:38.300
Because you don't wanna
process those things again.

421
00:28:38.300 --> 00:28:39.050
Somehow you have to get
them out of the array.

422
00:28:39.050 --> 00:28:42.156
If you wanna do that by shifting or
whatever,

423
00:28:42.156 --> 00:28:45.690
be destructive on the other array,
that's fine.

424
00:28:45.690 --> 00:28:47.124
Up to you.

425
00:28:47.124 --> 00:28:50.010
Some of the stories each
iteration you need a new queue.

426
00:28:52.110 --> 00:28:54.540
Well, rather it needs to be
cleared out by this point.

427
00:28:54.540 --> 00:28:57.080
In fact, that's actually why
you have to do it this way.

428
00:28:57.080 --> 00:28:59.671
Scratch that, listen to me,
only do it this way.

429
00:28:59.671 --> 00:29:04.485
[LAUGH] Once I've grabbed all
the neighbors, I'm gonna start pushing

430
00:29:04.485 --> 00:29:08.670
things into the new queue to
be processed next time, right?

431
00:29:08.670 --> 00:29:10.302
So that's why I got get all
the neighbors and I reset the queue.

432
00:29:10.302 --> 00:29:12.990
So that I can have a new
queue to work with.

433
00:29:12.990 --> 00:29:14.770
Does that make sense?

434
00:29:14.770 --> 00:29:19.053
Okay.
&gt;&gt; Brian Holt: Sometimes I have to work

435
00:29:19.053 --> 00:29:19.900
through my own problems.

436
00:29:19.900 --> 00:29:22.229
That's what my therapist tells me,

437
00:29:22.229 --> 00:29:27.243
just kidding.
&gt;&gt; Brian Holt: Cool,

438
00:29:27.243 --> 00:29:30.013
so we're gonna do the same thing.

439
00:29:30.013 --> 00:29:35.316
We're just gonna grab everything like this
and we're just gonna change everything

440
00:29:35.316 --> 00:29:41.798
from a to b.
&gt;&gt; Brian Holt: So

441
00:29:41.798 --> 00:29:48.570
bNeighbors = bQueue.

442
00:29:48.570 --> 00:29:49.191
This is all fine.

443
00:29:49.191 --> 00:29:51.458
bQueue= blank.

444
00:29:51.458 --> 00:29:56.248
aNeighbors, bNeighbors, BY_A.

445
00:30:00.810 --> 00:30:05.120
&gt;&gt; Brian Holt: This has been opened BY_B,

446
00:30:05.120 --> 00:30:07.100
and aQueue.

447
00:30:07.100 --> 00:30:13.856
Did I miss any?
&gt;&gt; Brian Holt: Again,

448
00:30:13.856 --> 00:30:16.590
you could be more clever and
drive out this.

449
00:30:16.590 --> 00:30:18.980
What's annoying about this is
if you modify anything in here,

450
00:30:18.980 --> 00:30:20.860
you're gonna have to
modify it in two places.

451
00:30:20.860 --> 00:30:21.430
It is annoying.

452
00:30:23.250 --> 00:30:27.340
Just like my personal kind of
mantra of Web development is

453
00:30:27.340 --> 00:30:28.700
only abstract things when you have to.

454
00:30:28.700 --> 00:30:33.020
Because abstractions just make
things tougher in general, right?

455
00:30:33.020 --> 00:30:38.110
Something like this, I would typically
leave in my code, just personally.

456
00:30:38.110 --> 00:30:40.600
But I know this would greatly offend
some people and they're wrong.

457
00:30:40.600 --> 00:30:43.710
So don't listen to them,
[LAUGH] listen to me.

458
00:30:43.710 --> 00:30:45.030
No, I'm just kidding.

459
00:30:45.030 --> 00:30:47.240
Yeah, listen to me at your own risk.

460
00:30:47.240 --> 00:30:48.100
That's a good idea.

461
00:30:48.100 --> 00:30:54.074
Okay, so I think this should work now.
&gt;&gt; Brian Holt: Let's

462
00:30:54.074 --> 00:30:57.851
give it a shot, see what happens,

463
00:30:57.851 --> 00:31:04.959
fingers crossed.
&gt;&gt; Brian Holt: First time.

464
00:31:04.959 --> 00:31:11.290
[LAUGH] So let's see what happens
if we go for the other two as well.

465
00:31:11.290 --> 00:31:19.460
So the extra credit ones.
&gt;&gt; Brian Holt: And it does solve.

466
00:31:19.460 --> 00:31:20.656
What happens if there's
no possible path and

467
00:31:20.656 --> 00:31:22.110
it does solve it if they're
next to each other as well?

468
00:31:25.202 --> 00:31:26.112
&gt;&gt; Brian Holt: Any questions,

469
00:31:26.112 --> 00:31:27.740
or rather, what questions?

470
00:31:27.740 --> 00:31:29.789
There's gotta be questions about this.

471
00:31:39.322 --> 00:31:41.372
&gt;&gt; Brian Holt: Either I taught it
perfectly and everyone gets it or

472
00:31:41.372 --> 00:31:43.555
everyone's like no just shut up and
move on, Brian.

473
00:31:43.555 --> 00:31:46.290
[LAUGH] Okay, it's the latter.

474
00:31:46.290 --> 00:31:49.235
I was not expecting that.

475
00:31:49.235 --> 00:31:55.362
[LAUGH]
&gt;&gt; Brian Holt: Conceptually,

476
00:31:55.362 --> 00:31:56.610
does this make sense?

477
00:31:58.510 --> 00:31:59.490
That's the important thing.

478
00:31:59.490 --> 00:32:02.690
Whether or not you actually got the
correct syntax on the page, I'm confident

479
00:32:02.690 --> 00:32:06.850
that if I gave you enough time and you
spent enough hours debugging and crying,

480
00:32:06.850 --> 00:32:08.460
like I did when I was writing this,

481
00:32:08.460 --> 00:32:10.560
that you would come to the correct answer,
right?

482
00:32:12.260 --> 00:32:13.750
Given time we can solve these problems,

483
00:32:13.750 --> 00:32:16.440
but what's important is that you
grasp these conceptually, right?

484
00:32:16.440 --> 00:32:20.940
Cuz later, at some point, it might not
be solving a maze, but maybe it's like

485
00:32:20.940 --> 00:32:24.950
finding the closest edge network in
your CDN or something like that, right?

486
00:32:26.050 --> 00:32:26.820
That's what's important.

487
00:32:26.820 --> 00:32:28.440
Because eventually you're gonna
have this problem that's like,

488
00:32:28.440 --> 00:32:32.690
that looks like a graph that I'm gonna
have to do a breadth-first traversal on.

489
00:32:32.690 --> 00:32:35.010
Those are the kind of patterns
that I want you to recognize.

490
00:32:35.010 --> 00:32:37.770
This is like pathfinding, right?

491
00:32:37.770 --> 00:32:40.890
Cuz this is useful for more than just
finding from point a to point b,

492
00:32:40.890 --> 00:32:43.430
not everyone's gonna look at Google Maps.

493
00:32:43.430 --> 00:32:46.600
But there are a lot of us
have to work with CDNs and

494
00:32:46.600 --> 00:32:48.370
that's just traversing things, right?

495
00:32:48.370 --> 00:32:51.620
So that's what's important about this,

496
00:32:51.620 --> 00:32:53.760
that's what I would really would
like you to get out of this.

497
00:32:55.800 --> 00:32:58.602
All right,
that said is there any questions?

498
00:32:58.602 --> 00:33:00.933
&gt;&gt; off screen female: I have a question?

499
00:33:00.933 --> 00:33:01.522
&gt;&gt; Brian Holt: Yeah.

500
00:33:01.522 --> 00:33:02.589
&gt;&gt; off screen female: So if you go back to

501
00:33:02.589 --> 00:33:07.085
where you're looping through the
neighbors, in the else if statement for

502
00:33:07.085 --> 00:33:12.076
either the b cue or the a cue, when you're
pushing the neighbor back onto the b cue,

503
00:33:12.076 --> 00:33:15.716
that's because you're gonna come back and
reduce again and

504
00:33:15.716 --> 00:33:18.300
get the neighbors of that node.
&gt;&gt; Brian Holt: Yep.

505
00:33:18.300 --> 00:33:19.430
&gt;&gt; off screen female: Okay, okay,

506
00:33:19.430 --> 00:33:24.440
that's the part that just connected.
&gt;&gt; Brian Holt: Yeah, it's a little weird.

507
00:33:24.440 --> 00:33:28.304
So I don't blame you for
having to reason through that out loud.

508
00:33:28.304 --> 00:33:29.260
&gt;&gt; off screen female: Okay [LAUGH].

509
00:33:29.260 --> 00:33:30.010
&gt;&gt; Brian Holt: I talk to myself, but

510
00:33:30.010 --> 00:33:31.550
mostly I just talk to my dog.

511
00:33:31.550 --> 00:33:32.400
She just looks at me.

512
00:33:32.400 --> 00:33:34.430
It's like, I don't care about this.

513
00:33:34.430 --> 00:33:35.280
Just give me treats.

514
00:33:37.830 --> 00:33:42.827
Yes, so you are kind of re-populating so
the next the iteration through then you

515
00:33:42.827 --> 00:33:46.374
can process them again,
right, yep that's accurate.

516
00:33:46.374 --> 00:33:48.260
Okay, cool.

517
00:33:48.260 --> 00:33:49.714
We all get it, this is all perfect,

518
00:33:49.714 --> 00:33:53.850
everyone's really happy about this.
&gt;&gt; off screen male: The question is

519
00:33:55.010 --> 00:33:59.482
she didn't understand why you
would need to clear the aQueue.

520
00:33:59.482 --> 00:34:02.601
&gt;&gt; Brian Holt: Sure let's take a look at

521
00:34:02.601 --> 00:34:09.703
that really quick.
&gt;&gt; Brian Holt: So,

522
00:34:14.316 --> 00:34:14.978
&gt;&gt; Brian Holt: I'm gonna get

523
00:34:14.978 --> 00:34:16.080
aNeighbors, right?

524
00:34:16.080 --> 00:34:17.780
aNeighbors is going to be.

525
00:34:17.780 --> 00:34:22.740
All of the neighbors,
all the valid neighbors for

526
00:34:22.740 --> 00:34:25.036
everything that's currently in my queue,
right?

527
00:34:25.036 --> 00:34:29.130
Why are we clearing out
a queue every single time?

528
00:34:29.130 --> 00:34:35.610
aNeighbors, after we do this line 39
right here, is going to be full of all

529
00:34:35.610 --> 00:34:40.150
of the valid neighbors that we're going
to process on this particular iteration.

530
00:34:40.150 --> 00:34:43.770
What we need to do is aq for the next
iteration, after we finish with this

531
00:34:43.770 --> 00:34:48.770
entire iteration, it needs to be full of
the next set of neighbors to process.

532
00:34:48.770 --> 00:34:53.190
So, after we do this aNeighbors thing,

533
00:34:53.190 --> 00:34:57.330
aq is still going to be full of
the previous neighbors, right?

534
00:34:57.330 --> 00:34:59.340
But we've gotten all the information
that we'd need out of them, so

535
00:34:59.340 --> 00:35:02.310
we don't need to worry about them anymore.

536
00:35:02.310 --> 00:35:05.020
And if we don't clear it out,
we're just going to be adding more and

537
00:35:05.020 --> 00:35:07.880
more things to the queue that we're going
to keep processing over and over and

538
00:35:07.880 --> 00:35:10.080
over and over again,
which we don't need to do.

539
00:35:10.080 --> 00:35:11.890
It would be totally pointless.

540
00:35:11.890 --> 00:35:13.630
So that's why we cleared out.

541
00:35:13.630 --> 00:35:16.620
And then down here we can end queue
a bunch of new things that need to be

542
00:35:16.620 --> 00:35:21.728
processed on the next iteration.
&gt;&gt; Brian Holt: Does that make

543
00:35:21.728 --> 00:35:26.561
sense?
&gt;&gt; Brian Holt: I see blank stares so

544
00:35:26.561 --> 00:35:28.599
no, that does not make any sense.

545
00:35:28.599 --> 00:35:32.034
So,
&gt;&gt; Brian Holt: Let's

546
00:35:32.034 --> 00:35:36.526
see.
&gt;&gt; Brian Holt: Let's see if I can show you

547
00:35:36.526 --> 00:35:37.170
this way.

548
00:35:37.170 --> 00:35:40.470
All right so, come on.

549
00:35:40.470 --> 00:35:45.395
There we go.
&gt;&gt; Brian Holt: Let's

550
00:35:45.395 --> 00:35:47.290
go all the way to the top.

551
00:35:47.290 --> 00:35:51.190
Make this just a tiny bit smaller so
I can get everything on the page.

552
00:35:51.190 --> 00:35:51.810
Okay.

553
00:35:51.810 --> 00:35:56.360
So, and
then make this a little bit bigger so

554
00:35:56.360 --> 00:36:01.179
you can see the code.
&gt;&gt; Brian Holt: So

555
00:36:01.179 --> 00:36:06.920
if I'm processing,
let's go with just a queue right now.

556
00:36:06.920 --> 00:36:09.990
So everything that's here
that's marked as two, right?

557
00:36:09.990 --> 00:36:14.480
Would be processing the next
iteration on top of that.

558
00:36:14.480 --> 00:36:19.120
What I need when I process it this time,
is this needs to be enqueued,

559
00:36:19.120 --> 00:36:23.170
this one, this one,
this one and that one, right?

560
00:36:23.170 --> 00:36:26.140
Those all need to be added so
I can process those on the next one.

561
00:36:26.140 --> 00:36:28.240
However, the problem that we have,

562
00:36:28.240 --> 00:36:33.010
particularly with AQ is it's still
full of everything that has two on it.

563
00:36:33.010 --> 00:36:36.040
We have to remove everything that all
those two's because if you don't want to

564
00:36:36.040 --> 00:36:36.640
process them again.

565
00:36:36.640 --> 00:36:39.610
We want to process the three's, and
then the four's, and then the five's.

566
00:36:39.610 --> 00:36:43.020
So that's what we do here is we cleared
out so that there's no more two's and

567
00:36:43.020 --> 00:36:45.770
it's just gonna be full of three's
after this current iteration.

568
00:36:46.800 --> 00:36:48.320
That's why we clear it out.

569
00:36:49.700 --> 00:36:51.670
Does that make more sense?
&gt;&gt; off screen female: So

570
00:36:51.670 --> 00:36:58.320
it is kind of like how we unshifted
the element in our breadth-first search?

571
00:36:58.320 --> 00:37:03.088
But this time, instead of unshifting one
thing, we're unshifting many things.

572
00:37:03.088 --> 00:37:04.660
&gt;&gt; Brian Holt: The whole thing.

573
00:37:04.660 --> 00:37:05.960
That's a very good way of putting it.

574
00:37:05.960 --> 00:37:09.340
That you're basically dequeuing
everything all at once.

575
00:37:09.340 --> 00:37:11.210
Whereas before we had been
doing it one at a time,

576
00:37:11.210 --> 00:37:12.820
we're just doing it a batch at a time.

577
00:37:13.920 --> 00:37:14.420
Yeah.

578
00:37:15.700 --> 00:37:17.500
Do you want to teach?

579
00:37:17.500 --> 00:37:18.200
[LAUGH]
&gt;&gt; off screen female: No, that was my

580
00:37:18.200 --> 00:37:18.720
contribution.

581
00:37:18.720 --> 00:37:20.080
I'm done now.
&gt;&gt; Brian Holt: Okay, well thank you,

582
00:37:20.080 --> 00:37:20.950
that was very valuable.

583
00:37:23.750 --> 00:37:24.250
Cool.

