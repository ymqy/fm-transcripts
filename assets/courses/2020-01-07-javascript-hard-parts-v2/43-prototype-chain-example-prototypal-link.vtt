WEBVTT

1
00:00:00.400 --> 00:00:03.258
威尔 · 森塔斯: 我们将要创建一个很棒的函数，但是
&gt;&gt; Will Sentance: We are going to
create I use a great function, but

2
00:00:03.258 --> 00:00:07.581
我们称这个对象为单拷贝或单拷贝，我甚至不想要我们的副本
we call this object single copies or
single, I don't even want us a copy of

3
00:00:07.581 --> 00:00:11.163
这首歌不是我们每个功能的同一个版本。
that song is no single same
version of each of our functions.

4
00:00:11.163 --> 00:00:14.476
我们将运行 i use a creative function，它将创建对象
And we're going to run I use a creative
function, it's going to create objects

5
00:00:14.476 --> 00:00:17.798
内部使用对象创建，这只是创建对象的另一种方式
inside using object create, which is just
another way of creating the object.dddd

6
00:00:17.798 --> 00:00:23.980
但是这些对象以某种方式与用户函数存储对象有联系。
But that objects going to have somehow our
bond to that user function store object.

7
00:00:23.980 --> 00:00:28.751
这意味着，当该对象返回到用户 one 时,
Meaning that, when that object gets
returned out into user one with

8
00:00:28.751 --> 00:00:32.109
它的属性，但没有任何功能存储在里面。
its properties, but
no function stored on it.

9
00:00:32.109 --> 00:00:36.847
当我们最终使用这个对象时，使用一个点增量，它不会找到
When we end up using that object, using
one dot increment, and it doesn't find

10
00:00:36.847 --> 00:00:41.442
对象的增量，我们会惊慌吗? 它会以某种方式链接到
increment on the object, are we gonna
panic It's gonna have a link somehow to

11
00:00:41.442 --> 00:00:45.991
使用一个函数存储，它会找到递增方法并使用它。
use a function store where it's gonna
find the increment method and use it.

12
00:00:45.991 --> 00:00:48.079
好了，各位，我们开始吧。
All right people, here we go.

13
00:00:48.079 --> 00:00:48.914
一号线。
Line one.

14
00:00:48.914 --> 00:00:51.753
杰夫，我们在全球记忆中做什么？
Jeff, what are we doing in global memory?

15
00:00:51.753 --> 00:00:52.777
我们在做什么？
What are we doing?

16
00:00:52.777 --> 00:00:55.524
Jeff: 我们正在声明一个用户创建的函数。
&gt;&gt; Jeff: We are declaring
a function user created.

17
00:00:55.524 --> 00:01:01.218
威尔 · 森坦斯: 非常好，在全局内存中，用户,
&gt;&gt; Will Sentance: Excellent,
in global memory, user,

18
00:01:01.218 --> 00:01:05.900
创造者，威尔 · 森塔斯: 就是这样。
creator,
&gt;&gt; Will Sentance: There it is.

19
00:01:05.900 --> 00:01:09.001
旧功能，非常好。
The old function, excellent.

20
00:01:09.001 --> 00:01:11.555
现在，为马特干杯。
Now, to Matt.

21
00:01:11.555 --> 00:01:15.750
Matt: 我们要定义一个常量用户函数存储库-
&gt;&gt; Matt: We're gonna define
a constant user function store-

22
00:01:15.750 --> 00:01:16.310
威尔 · 森特斯: 是的。
&gt;&gt; Will Sentance: Yeah.

23
00:01:16.310 --> 00:01:18.073
杰夫: 带有一个值 Will Sentance: Of a object。
&gt;&gt; Jeff: With a value
&gt;&gt; Will Sentance: Of an object.

24
00:01:18.073 --> 00:01:18.742
马特: 关于一个物体。
&gt;&gt; Matt: Of an object.

25
00:01:18.742 --> 00:01:19.799
威尔 · 森坦斯: 是的，不要被抓住,
&gt;&gt; Will Sentance: Yeah,
don't get caught people,

26
00:01:19.799 --> 00:01:21.010
在这里，认为它是其他的东西。
here in thinking it's anything else.

27
00:01:21.010 --> 00:01:22.004
是一个物体，没错。
It's an object, yeah.

28
00:01:22.004 --> 00:01:24.766
就是这个。
There it is.

29
00:01:24.766 --> 00:01:27.442
是的，那个东西上面储存了什么？
Yeah, and what's stored on the object?

30
00:01:27.442 --> 00:01:29.754
Matt: 我们有一个增量属性和一个登录属性。
&gt;&gt; Matt: We have an increment property and
a login property.

31
00:01:29.754 --> 00:01:32.429
Will Sentance: 是的，这是一个递增方法，因为函数是
&gt;&gt; Will Sentance: Yeah, and that's
an increment method because the function's

32
00:01:32.429 --> 00:01:33.028
储存在里面。
stored on it.

33
00:01:33.028 --> 00:01:37.012
和一个登录属性，这也是一个方法。
And a login Property
which is also a method.

34
00:01:37.012 --> 00:01:38.603
我的胳膊开始疼了。
Well, my arm is actually starting to ache.

35
00:01:38.603 --> 00:01:39.621
好了。
There we go.

36
00:01:39.621 --> 00:01:40.469
没问题。
No problem.

37
00:01:40.469 --> 00:01:42.221
就是这个。
There it is.

38
00:01:42.221 --> 00:01:43.241
非常感谢。
Thank you too much.

39
00:01:43.241 --> 00:01:46.909
现在我们进入下一张幻灯片的左边。
Now we move on to the next
slide left hand side.

40
00:01:46.909 --> 00:01:48.508
布莱登，该怎么办？
Braden, what to say to do?

41
00:01:48.508 --> 00:01:50.674
Braden: 声明常量 user-1。
&gt;&gt; Braden: Declare the constant user-1.

42
00:01:50.674 --> 00:01:51.838
杰夫: 用户 -1。
&gt;&gt; Jeff: User-1.

43
00:01:51.838 --> 00:01:54.911
威尔 · 森特斯: 我们知道这里显示的是什么吗，同志们。
&gt;&gt; Will Sentance: Do we know
what it showing here, people.

44
00:01:54.911 --> 00:01:58.715
不，我们要去创造我们，全新的每一个人。
Nope, we got to go and
run us the creator, brand new everybody.

45
00:01:58.715 --> 00:02:00.204
学生: 执行情境。
&gt;&gt; Students: Execution context.

46
00:02:00.204 --> 00:02:02.362
威尔 · 句子: 执行上下文，美丽。
&gt;&gt; Will Sentance: Execution context,
beautiful.

47
00:02:02.362 --> 00:02:06.632
这是如此充满活力，以通过我们的
That was so vibrant in which to pass our

48
00:02:06.632 --> 00:02:11.703
争论将和三个全新的执行
arguments will and
three brand new execution

49
00:02:11.703 --> 00:02:16.545
威尔 · 森塔斯: 所以
context as you all said
&gt;&gt; Will Sentance: So

50
00:02:16.545 --> 00:02:19.506
好极了，就是这个。
wonderfully, here it is.

51
00:02:19.506 --> 00:02:23.776
不，就是这个。
No, there it is.

52
00:02:23.776 --> 00:02:27.045
好了，我们开始吧
Okay, into it we

53
00:02:27.045 --> 00:02:32.560
杰夫: 我
go,
&gt;&gt; Jeff: I

54
00:02:32.560 --> 00:02:37.319
没有做的是本地记忆我们有，杰夫: 好吧,
didn't do is local memory we had,
&gt;&gt; Jeff: Okay,

55
00:02:37.319 --> 00:02:42.377
我们要做的第一件事，交给 Dan，我们要先做什么？
first thing we handle, over to Dan,
what are we gonna handle first?

56
00:02:42.377 --> 00:02:46.225
Will Sentance: 我们将 Will 分配给参数名。
&gt;&gt; Will Sentance: We assign
Will to the argument name.

57
00:02:46.225 --> 00:02:48.859
杰夫: 差不多，威尔对-威尔 · 森塔斯的论点是: 对不起,
&gt;&gt; Jeff: Almost, the Will argument to the-
&gt;&gt; Will Sentance: Sorry,

58
00:02:48.859 --> 00:02:50.418
参数名。
to the parameter name.

59
00:02:50.418 --> 00:02:51.781
杰夫: 参数名，是的，没错。
&gt;&gt; Jeff: Parameter name, yeah, exactly.

60
00:02:51.781 --> 00:02:54.465
然后下一个参数是 score，我们用什么参数分配？
And then the next parameter is score,
we assign in what argument?

61
00:02:54.465 --> 00:02:55.108
威尔 · 森坦斯: 3。
&gt;&gt; Will Sentance: 3.

62
00:02:55.108 --> 00:02:56.021
杰夫: 3，漂亮。
&gt;&gt; Jeff: 3, beautiful.

63
00:02:56.021 --> 00:02:56.971
很好，谢谢你，丹。
Very nice, thank you Dan.

64
00:02:56.971 --> 00:03:00.628
现在我们进入函数体，这个函数的整个点
Now we enter the body of the function
where the whole point of this function

65
00:03:00.628 --> 00:03:04.465
顺便说一下，使用存储在其中的特定用户的数据创建一个对象
by the way, create an object with the data
of a particular user stored in it and

66
00:03:04.465 --> 00:03:08.318
这个功能永远，永远不会被应用到特定的用户身上。
the functionality that will ever,
ever be applied to that particular user.

67
00:03:08.318 --> 00:03:09.122
这是唯一的一点。
That's the only point.

68
00:03:09.122 --> 00:03:11.086
那么下一行我们要做什么呢？
So what do we do in the next line?

69
00:03:11.086 --> 00:03:12.162
凯拉，我们创造一个？
Kyla, we create a?

70
00:03:12.162 --> 00:03:14.603
一个经常使用的新用户。
&gt;&gt; Will Sentance: A constant new user.

71
00:03:14.603 --> 00:03:17.103
杰夫: 是的，并赋予它将句子: 空对象。
&gt;&gt; Jeff: Yeah, and assign to it
&gt;&gt; Will Sentance: Empty object.

72
00:03:17.103 --> 00:03:18.068
杰夫: 一个空物体。
&gt;&gt; Jeff: An empty object.

73
00:03:18.068 --> 00:03:19.052
继续，对不起。
Go ahead, sorry.

74
00:03:19.052 --> 00:03:21.622
Will Sentance: 具有用户功能存储属性。
&gt;&gt; Will Sentance: With the properties
of user function store.

75
00:03:21.622 --> 00:03:25.301
杰夫: 没有属性，它实际上是一个空对象。
&gt;&gt; Jeff: No properties,
it's really an empty object.

76
00:03:25.301 --> 00:03:30.025
但是我会说我同意，不知怎么的
But I will say I do agree, it somehow got

77
00:03:30.025 --> 00:03:35.468
这个物体之间的亲密联系
an intimate link between
this object that's

78
00:03:35.468 --> 00:03:40.777
我使用函数存储。
being created And
I use the function store.

79
00:03:40.777 --> 00:03:42.877
我们还不知道如何，但有一个亲密的联系。
We do not yet know how but
there is a intimate link.

80
00:03:42.877 --> 00:03:45.912
好吧，让我们来试试这些特性。
Okay, but
let's get fitting in those properties.

81
00:03:45.912 --> 00:03:48.432
Dan 实际上 Adam 刚才的事很抱歉。
Dan, actually, Adam, sorry about there.

82
00:03:48.432 --> 00:03:51.213
我不应该总是在后面指定它，亚当。
I should not always specify
it at the back, Adam.

83
00:03:51.213 --> 00:03:53.326
继续。
Go ahead.

84
00:03:53.326 --> 00:03:55.105
我们得到了一个新的用户对象。
We've got a new user object.

85
00:03:55.105 --> 00:03:57.009
我们要立即增加什么内容？
What are we adding immediately to it?

86
00:03:57.009 --> 00:03:58.259
Will Sentance: 一个名为 name 的属性。
&gt;&gt; Will Sentance: A property called name.

87
00:03:58.259 --> 00:03:58.925
杰夫: 是的，然后呢？
&gt;&gt; Jeff: Yeah, and?

88
00:03:58.925 --> 00:04:04.076
Will Sentance: 并重新分配参数名的值，即 Will。
&gt;&gt; Will Sentance: And reassigning its
value of the argument name, which is Will.

89
00:04:04.076 --> 00:04:07.542
杰夫: 好极了，然后呢？
&gt;&gt; Jeff: Fantastic yeah, and then?

90
00:04:07.542 --> 00:04:09.662
威尔 · 森坦斯: 分数是3？
&gt;&gt; Will Sentance: The score is 3?

91
00:04:09.662 --> 00:04:13.637
杰夫: 是的，很好，那个物体。
&gt;&gt; Jeff: Yeah, perfect okay, that object.

92
00:04:13.637 --> 00:04:15.532
我们怎么处理它？
What do we do with it?

93
00:04:15.532 --> 00:04:18.536
看起来我们需要的。
It's kind of seems that what we need.

94
00:04:18.536 --> 00:04:21.380
它获得了数据，并以某种方式与我们的功能相连接，但是
It's got the data and
it linked somehow to our functions, but

95
00:04:21.380 --> 00:04:23.417
它被困在我们的行刑环境里了。
it's stuck inside our execution context.

96
00:04:23.417 --> 00:04:24.629
马特，我们怎么把它弄出来。
Matt, how we get it out.

97
00:04:24.629 --> 00:04:30.004
我们要把这个物体完全返回到全局标签 Matt 中,
We're going to return the object exactly
out into what global label Matt,

98
00:04:30.004 --> 00:04:31.466
用一个神奇的。
use one fantastic.

99
00:04:31.466 --> 00:04:39.814
就是这个名字: 威尔,
And there it is with name: Will,

100
00:04:39.814 --> 00:04:44.593
配乐: [声音]3。
score: [SOUND] 3.

101
00:04:44.593 --> 00:04:48.197
上面有增量方法吗？
And any increment method on it?

102
00:04:49.558 --> 00:04:57.413
没错，但它确实和这里的函数集有某种联系。
Exactly, but it does have somehow a link
To this collection of functions up here.

103
00:04:57.413 --> 00:04:58.862
过一会儿就知道了，别担心。
We'll see how in a moment, don't worry.

104
00:04:58.862 --> 00:05:02.192
好了，我们回到全球，我们现在宣布用户2。
Okay, we're back out in global
we declare now user two.

105
00:05:02.192 --> 00:05:08.889
它将是另一个调用用户的结果，另一个运行,
It's going to be the result of
another call to user, another running,

106
00:05:08.889 --> 00:05:14.593
用于运行用户创建器的另一个执行上下文。
another execution context for
the running of user creator.

107
00:05:14.593 --> 00:05:18.901
这次是提姆的争论，还有五个。
This time with the argument of Tim,
and five.

108
00:05:18.901 --> 00:05:21.004
它的输出是什么？
What would it's output be?

109
00:05:21.004 --> 00:05:24.307
我就跳过执行上下文吧,
I'm just gonna sort of skip
the execution context,

110
00:05:24.307 --> 00:05:27.021
知道我们已经走进去，做了一切。
know that we've gone inside and done all.

111
00:05:27.021 --> 00:05:29.377
那我们最后会怎么样呢 Matt,
So what are we gonna end up with here,
Matt,

112
00:05:29.377 --> 00:05:31.874
存储到用户2B 中的所有输出？
all the output that gets
stored into user 2B?

113
00:05:31.874 --> 00:05:34.524
Will Sentance: 属性名为 Tim 值的对象。
&gt;&gt; Will Sentance: The object with
the property name to the value of Tim.

114
00:05:34.524 --> 00:05:39.401
这就是它的属性，值为5的分数，以及一个不可磨灭的链接。
That does it property, score of
the value 5, and an indelible link.

115
00:05:39.401 --> 00:05:43.457
杰夫: 是啊，一种神秘的不可磨灭的联系，贯穿到？
&gt;&gt; Jeff: Yeah,
a mysterious indelible link, through to?

116
00:05:43.457 --> 00:05:45.577
Will Sentance: 用户函数存储。
&gt;&gt; Will Sentance: The user function store.

117
00:05:45.577 --> 00:05:46.797
杰夫: 通过用户功能存储。
&gt;&gt; Jeff: Through to
the user function store.

118
00:05:46.797 --> 00:05:50.163
威尔 · 森塔斯: 看，他们合并得很好。
&gt;&gt; Will Sentance: Look at that,
they merged well, there.

119
00:05:50.163 --> 00:05:52.283
并且您可以通过用户函数存储。
And you are through to
the user function store.

120
00:05:52.283 --> 00:05:56.266
好了，现在我们检查一下。
Okay, now we do our check.

121
00:05:56.266 --> 00:06:01.800
我们要做的是，让我们做 user1.increment,
We're gonna do, let's do user1.increment,

122
00:06:01.800 --> 00:06:07.610
这就是我在这里得到的，user1.increment。
it's what I've got up here,
user1.increment.

123
00:06:07.610 --> 00:06:11.456
托德，你已经知道了，该你上场了。
Todd, you already know, it's over to you.

124
00:06:11.456 --> 00:06:15.264
托德，JavaScript 要去哪里寻找 user1呢？
Todd, where's JavaScript
gonna go looking for user1?

125
00:06:15.264 --> 00:06:16.029
杰夫: 在全球的记忆里。
&gt;&gt; Jeff: In the global memory.

126
00:06:16.029 --> 00:06:16.757
全局记忆，我们找到它了吗？
&gt;&gt; Will Sentance: Global memory,
we find it?

127
00:06:16.757 --> 00:06:17.490
杰夫: 是的。
&gt;&gt; Jeff: Yes.

128
00:06:17.490 --> 00:06:20.516
威尔 · 森塔斯: 是的，我们知道，等等。
&gt;&gt; Will Sentance: Yes we do, hold on.

129
00:06:24.098 --> 00:06:24.704
威尔 · 森塔斯: 是的，我们知道。
&gt;&gt; Will Sentance: Yes we do.

130
00:06:24.704 --> 00:06:26.995
我们在那个物体上寻找什么？
What are we looking for on that object?

131
00:06:26.995 --> 00:06:27.668
杰夫: Increment。
&gt;&gt; Jeff: Increment.

132
00:06:27.668 --> 00:06:28.663
句子: 增量，我们找到了吗？
&gt;&gt; Will Sentance: Increment,
do we find it?

133
00:06:28.663 --> 00:06:29.552
杰夫: 不是马上。
&gt;&gt; Jeff: Not immediately.

134
00:06:29.552 --> 00:06:31.105
威尔 · 森塔斯: 不，不在那个物体上。
&gt;&gt; Will Sentance: No,
it's not on that object.

135
00:06:31.105 --> 00:06:32.197
我们要放弃吗？
Do we give up?

136
00:06:32.197 --> 00:06:32.988
杰夫: 没有。
&gt;&gt; Jeff: No.

137
00:06:32.988 --> 00:06:35.380
威尔 · 森特斯: 我们跟随紫色到哪里去？
&gt;&gt; Will Sentance: Where
do we follow the purple?

138
00:06:35.380 --> 00:06:37.324
杰夫: 不可磨灭的纽带。
&gt;&gt; Jeff: The indelible link.

139
00:06:37.324 --> 00:06:38.399
威尔 · 森特斯: 不可磨灭的纽带，直到？
&gt;&gt; Will Sentance: The indelible link,
up to?

140
00:06:38.399 --> 00:06:39.784
杰夫: 用户功能。
&gt;&gt; Jeff: User function.

141
00:06:39.784 --> 00:06:41.612
威尔 · 森坦斯: 功能偷了我们在它上面找到的地方-
&gt;&gt; Will Sentance: Function
stole where we find on it-

142
00:06:41.612 --> 00:06:42.276
杰夫: Increment。
&gt;&gt; Jeff: Increment.

143
00:06:42.276 --> 00:06:43.735
Will Sentance: Increment，我们获取它的代码。
&gt;&gt; Will Sentance: Increment,
and we grab its code.

144
00:06:43.735 --> 00:06:47.853
我们马上就要开始处决的人。
And people we're gonna start
executing in a moment.

145
00:06:47.853 --> 00:06:51.644
我希望你们能看到一些，关于这个函数的有趣的东西，我们需要
So I want you all to see some interesting
things about that function that we need to

146
00:06:51.644 --> 00:06:52.612
确保是真的。
make sure are true.

147
00:06:52.612 --> 00:06:59.459
因为这个函数可以用在用户1，用户2，用户400上。
Because that function is gonna be able to
be used on user 1, on user 2, on user 400.

148
00:06:59.459 --> 00:07:05.355
在我们这样做之前，让我们先了解一下这个链接实际上是如何存储的。
Before we do that though, let's understand
how this link is actually stored.

149
00:07:05.355 --> 00:07:08.180
它是使用 auto.create 制作的。
It's made using auto.create.

150
00:07:08.180 --> 00:07:11.319
无论你经历了什么，我们都会得到那种不可磨灭的联系，那种联系。
Whatever you pass in,
we get that indelible link, that bond.

151
00:07:11.319 --> 00:07:15.564
它是如何存储的，对象，重拍,
How is it stored, the object, the reshoot,

152
00:07:15.564 --> 00:07:21.499
create 确实创建了一个空对象，我支持这一点。
object.create does create an empty object,
I stand by that.

153
00:07:21.499 --> 00:07:26.718
Kayla 在暗示这个链接是怎么建立起来的？
And Kayla was hinting,
well hold on how is this link made?

154
00:07:26.718 --> 00:07:29.637
她这么说是对的，这是事实。
Well she is right to say that,
is something that happens.

155
00:07:29.637 --> 00:07:32.909
但是在引擎盖下面我们看不到它。
But it's under the hood
that we can't see it.

156
00:07:32.909 --> 00:07:35.408
当我们来安慰你的时候，我马上就告诉你怎么做。
When we come to console I'll
show you how in a second.

157
00:07:35.408 --> 00:07:41.947
此对象上的隐藏属性。
A hidden property on this object.

158
00:07:44.937 --> 00:07:49.949
威尔 · 森塔斯: 这是一个有趣的问题，它是双下划线,
&gt;&gt; Will Sentance: And it's a funny one,
it's double underscore,

159
00:07:49.949 --> 00:07:56.274
原型双下划线，他们称之为 dunderline proto
proto double underscore,
they call that dunderscore proto or

160
00:07:56.274 --> 00:08:00.927
原型 dunder 原型 dunder 原型财产,
dunder, proto dunder, the proto property,

161
00:08:00.927 --> 00:08:04.291
存储在里面，或者链接到。
and it has stored in it or link to.

162
00:08:04.291 --> 00:08:06.889
用户功能存储。
User function store.

163
00:08:06.889 --> 00:08:10.331
不不不。
No, no, no, no.

164
00:08:11.370 --> 00:08:16.115
将该对象返回给用户1，并
Returns that object into user 1, and

165
00:08:16.115 --> 00:08:20.564
在幕后，它仍然有它的
behind the scenes, it still has its

166
00:08:20.564 --> 00:08:25.322
原型链接到用户功能存储器。
proto link up to user function store.

167
00:08:25.322 --> 00:08:32.902
这个原型链接，这个链接从用户1到用户函数存储。
This proto link, this chain connection
from user 1 up to user function store.

168
00:08:32.902 --> 00:08:34.100
这里也有。
And it's also on here.

169
00:08:36.768 --> 00:08:38.256
威尔 · 森塔斯: 我们有一个参照物，一个链接,
&gt;&gt; Will Sentance: We have a referent,
a link,

170
00:08:38.256 --> 00:08:40.746
真正能看到的字体。
would actually literally
see written in here.

171
00:08:40.746 --> 00:08:46.495
用户函数存储，指向该对象的链接。
User function store,
a link to that object.

172
00:08:46.495 --> 00:08:50.010
意思是，我们开始吧，布莱登。
Meaning, let's start, Braden.

173
00:08:50.010 --> 00:08:53.999
如果我在做 user1.increment，请告诉我。
Braden, if I were doing user1.increment,
talk me through.

174
00:08:53.999 --> 00:08:55.067
我在哪里寻找用户1？
Where do I look for user one?

175
00:08:55.067 --> 00:08:55.631
我们会找到它吗？
Would we find it?

176
00:08:55.631 --> 00:08:56.140
杰夫: 是的。
&gt;&gt; Jeff: Yes.

177
00:08:56.140 --> 00:08:57.889
威尔 · 森坦斯: 是的，我知道。
&gt;&gt; Will Sentance: Yeah, I do.

178
00:09:04.312 --> 00:09:07.139
威尔 · 森塔斯: 这个不起作用，]我发现是的，我发现了。
&gt;&gt; Will Sentance: This one is not
working,] I find it yes, I do.

179
00:09:07.139 --> 00:09:11.711
我在它上面寻找增量方法。
I look for the increment method on it.

180
00:09:11.711 --> 00:09:12.495
我找到了吗？
Do I find it?

181
00:09:12.495 --> 00:09:13.663
杰夫: 不是现在。
&gt;&gt; Jeff: Not right away.

182
00:09:13.663 --> 00:09:16.054
是的，但是 JavaScript 是做什么的呢？
&gt;&gt; Will Sentance: No, but
what does JavaScript do?

183
00:09:16.054 --> 00:09:20.869
实际上我正要告诉你们 JavaScript 有它的非凡之处,
I was actually gonna tell you,
JavaScript has its quite remarkable,

184
00:09:20.869 --> 00:09:22.426
原型特征。
prototypal feature.

185
00:09:22.426 --> 00:09:28.392
这意味着当它找不到对象 a 给定的属性时,
That means when it does not find
on the object A given property,

186
00:09:28.392 --> 00:09:31.552
方法或数据，它不恐慌。
method or data it does not panic.

187
00:09:31.552 --> 00:09:36.383
相反，它直接进入了原始属性不是的状态
Instead it goes straight to
the __proto__ property not to be

188
00:09:36.383 --> 00:09:38.446
和原型混淆了。
confused with prototype.

189
00:09:38.446 --> 00:09:39.298
你知道这是不对的。
You see that is wrong.

190
00:09:39.298 --> 00:09:43.798
所以它是原始财产，它关注与什么相联系,
So it's the __proto__ property and
it looks at what is linking to,

191
00:09:43.798 --> 00:09:47.023
连接到原型链上,
and is linking to the proto
Up the prototype chain,

192
00:09:47.023 --> 00:09:50.700
但是，是的，在原型链上，这是可以的措辞。
but yeah, up the prototype
chain that's okay phrasing.

193
00:09:50.700 --> 00:09:52.841
向上的原型链或
Up the prototype chain or

194
00:09:52.841 --> 00:09:58.557
让我们通过它的原始引用链接到布拉登。
let's say through its proto-reference
link up to where Bradon.

195
00:09:58.557 --> 00:10:00.885
Jeff: 用户函数-Will Sentance: 用户函数存储。
&gt;&gt; Jeff: The user function-
&gt;&gt; Will Sentance: The user function store.

196
00:10:00.885 --> 00:10:01.758
我们发现了什么？
What do we find?

197
00:10:01.758 --> 00:10:02.847
杰夫: Increment。
&gt;&gt; Jeff: Increment.

198
00:10:02.847 --> 00:10:07.440
Will Sentance: Increment method，And we grab it And
&gt;&gt; Will Sentance: Increment method,
and we grab it And

199
00:10:07.440 --> 00:10:14.118
我们为它的代码创建一个全新的执行环境。
we create a brand new execution
context for its code.

200
00:10:14.118 --> 00:10:15.134
我一会儿再说这个。
I'm gonna come to that in a moment.

201
00:10:15.134 --> 00:10:19.822
但是现在让我们先来看看这个模型,
But for now let's have thumbs
on this model where look people,

202
00:10:19.822 --> 00:10:21.690
这不是很美吗？
ain't this beautiful?

203
00:10:21.690 --> 00:10:24.676
这个用户1，这个用户2。
This user 1, this user 2.

204
00:10:24.676 --> 00:10:28.394
他们都没有我们功能的单独副本
Neither of them have individual copies
of our functions it would be totally

205
00:10:28.394 --> 00:10:30.293
冗余是对记忆空间的浪费。
redundant as a waste of memory space.

206
00:10:30.293 --> 00:10:31.463
我们真的很擅长解决问题。
We really good at a problem.

207
00:10:31.463 --> 00:10:36.236
这些代码被保存在内存中，并且作为浪费的内存空间被复制。
That code is saved in memory and
copies of it as it's wasted memory space.

208
00:10:36.236 --> 00:10:40.349
相反，我们通过亲到隐藏的财产或
Instead we have through
the pro to hidden property or

209
00:10:40.349 --> 00:10:45.115
链接到一个拷贝或者一个对象
link up to a single copy or
up to a single object where all those

210
00:10:45.115 --> 00:10:50.077
我们希望所有这些对象都能访问的函数被存储。
functions we want all these
objects have access to are stored.

211
00:10:50.077 --> 00:10:55.337
这是 JavaScript 的原型本质，当我们查看它们的时候，它们是对象
And it's JavaScript prototype nature
that objects when we look on them for

212
00:10:55.337 --> 00:10:58.687
我们不会放弃，也不会找到。
a method we don't give up and
we don't find it.

213
00:10:58.687 --> 00:11:02.493
我们首先检查原始属性，然后前往那个对象。
We first go check the proto property and
head up to that object.

214
00:11:02.493 --> 00:11:06.258
也就是说它的原型是一个特征就是一个特征就像它的词法范围一样
That is its prototype was one of features
is a feature like its lexical scope

215
00:11:06.258 --> 00:11:08.602
属性是它的全局存储器的一个特征。
property is a feature
like its global memory.

216
00:11:08.602 --> 00:11:09.379
就像它是一个功能一样。
Like it's a feature.

217
00:11:09.379 --> 00:11:14.336
这是一个特性，如果我们设置对象，它们就会与其他对象建立连接
It's a feature that objects have a
connection to other objects if we set them

218
00:11:14.336 --> 00:11:16.900
通过他们的原始财产来实现。
to do so through their proto property.

219
00:11:16.900 --> 00:11:21.594
当 JavaScript 点击查找某个对象而对象没有找到它时,
And when JavaScript hits looking for
something and the object doesn't find it,

220
00:11:21.594 --> 00:11:23.397
它马上就会出错。
it does an error immediately.

221
00:11:23.397 --> 00:11:25.831
它去检查一层或更多层。
It goes and checks one layer up or
maybe more.

222
00:11:25.831 --> 00:11:26.679
我们一会儿就知道了。
We'll see in a moment.
