WEBVTT

1
00:00:00.310 --> 00:00:03.101
Will Sentance: 假设我们有这个应用程序，它将每个用户存储在我的应用程序中
&gt;&gt; Will Sentance: Let's say we have this
application storing each user in my app

2
00:00:03.101 --> 00:00:04.448
他们各自的数据。
with their respective data.

3
00:00:04.448 --> 00:00:05.272
让我们保持简单。
Let's keep it really simple.

4
00:00:05.272 --> 00:00:07.293
我们已经有了大量的数据和用户。
We already have lots of data and
lots of users.

5
00:00:07.293 --> 00:00:11.519
简单一点，用户名 Tim,
Keep it really simple, user1 name Tim,

6
00:00:11.519 --> 00:00:16.939
用户2名斯蒂芬妮，得分3，得分5。
user2 name Stephanie, score 3, score 5.

7
00:00:16.939 --> 00:00:20.373
我需要为每个用户提供的功能,
&gt;&gt; Will Sentance: The functionality
I need to have for each user, again,

8
00:00:20.373 --> 00:00:24.977
简化只是增加的能力，以增加一个分数的用户,
simplify just the ability to increment
to increase the scores user by one,

9
00:00:24.977 --> 00:00:27.187
对不起，对不起，用户得分是1。
sorry, sorry, user score by one.

10
00:00:27.187 --> 00:00:29.487
事实上，这里有很多功能。
In fact,
there'd be a ton of functionality here.

11
00:00:29.487 --> 00:00:35.189
现在，有两件事情，我不想运行我的代码或秋天的所有
Now, two things, I do not want to have
to run all over my fall of code or

12
00:00:35.189 --> 00:00:39.539
我的代码的瀑布，尝试和猎取增量函数。
my falls of code to try and
hunt out that increment function.

13
00:00:39.539 --> 00:00:42.359
在我的理想世界里，user1在我的任何地方
In my ideal world, wherever user1 is in my

14
00:00:42.359 --> 00:00:45.590
现在正在传递到我的应用程序的不同位,
application right now being passed around
into different bits of my application,

15
00:00:45.590 --> 00:00:49.359
我在它旁边有一个增量功能。
I have that increment functionality
right there adjacent to it.

16
00:00:49.359 --> 00:00:54.237
最理想的情况是，它几乎被规定为
And ideally, it's somehow pretty
much prescribed to only be

17
00:00:54.237 --> 00:00:59.954
适用于 user1数据或 user2，以及 user2数据和
applicable to the user1 data or
to the user2, and to the user2 data and

18
00:00:59.954 --> 00:01:04.209
而不是突然想要申请我的主桌。
not suddenly gonna be tried
to apply to my lead table.

19
00:01:04.209 --> 00:01:07.221
我要尝试增加我的铅表，通常是这样的。
I'm going to try to increment
my lead table, normally a thing.

20
00:01:07.221 --> 00:01:11.427
是的，所以我怎么能捆绑在一个包在一种
Yeah, so how could I bundle up
in one package in one kind of

21
00:01:11.427 --> 00:01:16.253
组织数据结构，数据与功能所以
organizing data structure,
that data with the functionality so

22
00:01:16.253 --> 00:01:20.126
我知道他们就在彼此身边。
I know that they're right
there next to each other.

23
00:01:20.126 --> 00:01:24.605
我甚至可以使用一个特殊的，威尔 · 森特斯: 点,
And I can even use a special,
&gt;&gt; Will Sentance: Dot,

24
00:01:24.605 --> 00:01:29.510
点也许是为了使用该数据的功能。
[LAUGH] dot perhaps in order to use
the functionality on that data.

25
00:01:29.510 --> 00:01:32.099
如何将功能和数据捆绑到一个地方？
How can I bundle functionality and
data in one place?

26
00:01:32.099 --> 00:01:32.870
Braden 你有什么主意吗？
Braden, you got any idea?

27
00:01:32.870 --> 00:01:34.609
说话人2: 在物体或公共汽车上。
&gt;&gt; Speaker 2: In object or bus.

28
00:01:34.609 --> 00:01:36.689
威尔 · 句子: 在一个物体中，存储在物体中。
&gt;&gt; Will Sentance: In an object,
store in object.

29
00:01:36.689 --> 00:01:38.049
让我们暂时保持简单。
Let's keep it even simple for now.

30
00:01:38.049 --> 00:01:40.799
存储在对象中，这是完全正确的。
Store in an object, that's exactly right.

31
00:01:40.799 --> 00:01:44.569
因此，对象存储函数及其相关数据。
So objects store functions
with their associated data.

32
00:01:44.569 --> 00:01:48.469
这并不是完全在 JavaScript 中实现的。
This is, well, not fully strictly
implemented in JavaScript.

33
00:01:48.469 --> 00:01:50.390
这就是封装的概念。
This is the notion of encapsulation.

34
00:01:50.390 --> 00:01:54.950
它的意思是保护和捆绑在一个地方，功能和
It's saying protect and
bundle up in one place, functionality and

35
00:01:54.950 --> 00:02:00.311
它所应用的数据，它所应用的数据，[ INAUDIBLE ]语法,
the data that it applies to, the data to
which it applies, [INAUDIBLE] grammar,

36
00:02:00.311 --> 00:02:04.790
它应用于一个小捆绑包中的其他数据。
other data to which it applies
in one little bundle package.

37
00:02:04.790 --> 00:02:07.560
这将改变我们思考代码的方式。
And it's gonna transform how
we can reason about code.

38
00:02:07.560 --> 00:02:11.530
看看这个，我的100,000行代码周围没有搜索,
Look at this, no hunting all
around my 100,000 lines of code,

39
00:02:11.530 --> 00:02:15.247
我的递增函数，我简单地把点放在这里。
my increment function,
I literally just put dot and there it is.

40
00:02:15.247 --> 00:02:19.109
我们今天所做的一切努力,
And it's gonna turn out everything
that we try and do today,

41
00:02:19.109 --> 00:02:23.670
我们今天所做的一切，都是为了达到我的最佳位置。
everything we try and do today,
getting into my optimal position.

42
00:02:23.670 --> 00:02:28.310
我们今天所做的一切都是为了我能成功吗？
Everything we try and do today is really
just gonna be about can I achieve this?

43
00:02:28.310 --> 00:02:34.449
我能在相关数据上实现运行功能吗？
Can I achieve running functionality
on the pertinent data?

44
00:02:34.449 --> 00:02:38.789
不是其他数据，不是随机的测试问题，不是随机的排名表，而是
Not other data, not random quiz questions,
not randomly league tables, but

45
00:02:38.789 --> 00:02:44.110
用户的数据，而不必去寻找功能。
on the user ones data and
not have to go hunt for the functionality.

46
00:02:44.110 --> 00:02:45.079
但它就在那里。
But it's right there.

47
00:02:45.079 --> 00:02:47.370
我把点和控制台,
I put dot and in the console,

48
00:02:47.370 --> 00:02:53.599
我甚至可以看到预先填写的增量，为我预测的。
I'd even see the increment kinda
pre-filled for me, predicted for me.

49
00:02:53.599 --> 00:02:59.400
这就是为我的数据找到相关功能的容易程度。
That's how easy it will be to find
the pertinent functionality for my data.

50
00:02:59.400 --> 00:03:00.379
这就是我的目标。
That's my goal.

51
00:03:00.379 --> 00:03:02.870
你知道吗，我就是在这里做的。
Well, you know what, I did it here.

52
00:03:02.870 --> 00:03:04.150
我在这里完成了。
I did it here, done.

53
00:03:04.150 --> 00:03:05.300
我的思维模式已经完成了。
My paradigm's done.

54
00:03:05.300 --> 00:03:09.590
我得到了数据、功能和一个对象。
I got data, functionality,
and an object done.

55
00:03:11.530 --> 00:03:14.110
但是让我们继续创建对象，因为它会变成
But let's keep creating objects
cuz it's gonna turn out

56
00:03:14.110 --> 00:03:16.800
我们很快就会厌倦这些东西的笔迹。
that we're gonna very quickly get
tired of handwriting these objects.

57
00:03:16.800 --> 00:03:18.360
但是让我们做几次。
But let's do it a few times.

58
00:03:18.360 --> 00:03:18.979
在这样做的同时,
And in doing so,

59
00:03:18.979 --> 00:03:22.610
还要熟悉一些创建对象的不同方法。
also get familiar with a few different
ways to go about creating objects.

60
00:03:22.610 --> 00:03:23.879
人们能想到另一种方法吗？
Can people think of another way?

61
00:03:23.879 --> 00:03:27.900
这里我创建了一个对象，字面上叫做完全填充对象，并且
Here I've created an object, literally
call it the full populate object, and

62
00:03:27.900 --> 00:03:29.629
我已经预先填充了它的所有值。
I've prefilled all its values.

63
00:03:29.629 --> 00:03:30.610
我能做些什么呢？
What can I do instead?

64
00:03:30.610 --> 00:03:32.400
如果我只创建一个空对象 Braden,
If I would just create an empty object,
Braden,

65
00:03:32.400 --> 00:03:34.949
后来我怎样才能给它添加属性呢？
how could I add properties
to it afterwards?

66
00:03:36.079 --> 00:03:37.240
讲者2: 组织一个班级。
&gt;&gt; Speaker 2: Make a class.

67
00:03:37.240 --> 00:03:38.591
威尔 · 森坦斯: 不，只要保持简单就好。
&gt;&gt; Will Sentance: No,
just keep it really simple.

68
00:03:38.591 --> 00:03:39.600
怎么了，马特？
Yeah, Matt?

69
00:03:39.600 --> 00:03:40.334
说话人2: 使用点运算符。
&gt;&gt; Speaker 2: Use a dot operator.

70
00:03:40.334 --> 00:03:42.719
威尔 · 森特斯: 没错，点符号，就是这个。
&gt;&gt; Will Sentance: Exactly,
dot notation, there it is.

71
00:03:42.719 --> 00:03:45.189
使用点符号创建 user2。
Creating user2 with dot notation.

72
00:03:45.189 --> 00:03:47.879
用点表示法声明空属性。
Declare empty properties
with dot notation.

73
00:03:47.879 --> 00:03:48.787
我们开始吧。
Let's get going through.

74
00:03:48.787 --> 00:03:53.038
我只是想确保我们在互动方面达成共识
I just wanna make sure that we're all
on the same page with our interaction

75
00:03:53.038 --> 00:03:53.938
用物体。
with objects.

76
00:03:55.090 --> 00:04:01.193
好的，托德，第一行，我们要在全局内存中保存什么？
Okay, Todd, line one here,
what are we saving in global memory?

77
00:04:01.193 --> 00:04:04.169
说话人2: 你把 user2这个概念定义为一个空对象。
&gt;&gt; Speaker 2: You are defining
the concept user2 as an empty object.

78
00:04:04.169 --> 00:04:05.310
威尔 · 森特斯: 是的，一个又大又旧的空物体。
&gt;&gt; Will Sentance: Yeah,
big old empty object.

79
00:04:05.310 --> 00:04:07.360
这不是一个真正的东西，只是一个空的对象。
That's not really a thing,
just an empty object.

80
00:04:07.360 --> 00:04:10.300
就是它，一个又大又旧的空物体，分配给它什么财产，托德？
There it is, big old empty object,
assigning what property to it, Todd?

81
00:04:11.740 --> 00:04:13.460
演讲者2: 下一行分配名称。
&gt;&gt; Speaker 2: The next line assigns name.

82
00:04:13.460 --> 00:04:15.509
威尔 · 森特斯: 是的，并且赋予这个属性什么价值？
&gt;&gt; Will Sentance: Yeah, and
assigning what value to that property?

83
00:04:15.509 --> 00:04:16.279
讲者二: 十位。
&gt;&gt; Speaker 2: Ten.

84
00:04:16.279 --> 00:04:18.153
威尔 · 森坦斯: 是的，对不起，[听不见] ，所以
&gt;&gt; Will Sentance: Yeah,
sorry, [INAUDIBLE], so

85
00:04:18.153 --> 00:04:21.939
他们称之为键值。
they call these different things,
key value.

86
00:04:21.939 --> 00:04:24.713
我很少在专业代码中听到这样的措辞。
I rarely hear that phrasing
in professional code.

87
00:04:24.713 --> 00:04:29.850
我们倾向于称它为属性名，然后是属性值，好的。
We would tend to call it property name,
and then the property value so, okay.

88
00:04:31.000 --> 00:04:33.884
下一个是 scores 和6。
Next one is score and 6.

89
00:04:33.884 --> 00:04:36.040
然后，马特，我们在最后一张幻灯片上做什么？
And then, Matt,
what are we doing in the last slide here?

90
00:04:36.040 --> 00:04:38.588
我们还要增加一处房产,
We're adding another property, yeah,

91
00:04:38.588 --> 00:04:42.526
我们怎么称呼对象的函数，Matt，各位？
what do we tend to call functions
on objects, Matt, everyone?

92
00:04:42.526 --> 00:04:44.307
讲者二: 方法 威尔 · 森特斯: 方法，是的，做得好,
&gt;&gt; Speaker 2: Method.
&gt;&gt; Will Sentance: Method, yeah, well done,

93
00:04:44.307 --> 00:04:46.343
没错，方法，干得好，伙计们。
exactly, method, well done, folk.

94
00:04:46.343 --> 00:04:51.615
[ INAUDIBLE ] ，就是这个，它把所有的代码都存储起来了。
[INAUDIBLE], there it is, and that's
taking all of its code and storing it.

95
00:04:51.615 --> 00:04:53.649
像往常一样，我们不运行代码，但是
And as usual,
we're not running that code but

96
00:04:53.649 --> 00:04:56.781
我们把整个函数定义从单词 function
we are taking that entire function
definition from the word function to

97
00:04:56.781 --> 00:04:59.250
结束曲括号存储在那个物体上，美丽
closing curly brace storing
on that object, beautiful
