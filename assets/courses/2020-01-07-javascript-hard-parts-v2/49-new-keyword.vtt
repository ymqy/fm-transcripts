WEBVTT

1
00:00:00.000 --> 00:00:03.565
威尔 · 森特斯: 这就是我们令人惊异的原型性质的工作是紫色的
&gt;&gt; Will Sentance: That was our amazing
prototypal nature of jobs are those purple

2
00:00:03.565 --> 00:00:06.264
代码，JavaScript 的原型本质。
lines, the prototypal
nature of JavaScript.

3
00:00:06.264 --> 00:00:09.993
这是一个非常美好的方式来确保我们不会
That's a very beautiful way
of ensuring that we don't

4
00:00:09.993 --> 00:00:14.785
必须在用户1、用户2和用户500上直接增量。
have to have increment directly on
user 1 and user 2 and user 500.

5
00:00:14.785 --> 00:00:18.361
但是我们可以访问它，因为当我们没有在垫子上找到增量时
But we have access to it because when
we don't find increment on the mat

6
00:00:18.361 --> 00:00:20.917
在对象本身上，JavaScript 不会恐慌。
on the object itself
JavaScript doesn't panic.

7
00:00:20.917 --> 00:00:25.469
它看起来是1中的原型属性，指向它链接到用户函数的地方
It looks it is proto property in 1, heads
up to where it links to user function

8
00:00:25.469 --> 00:00:30.248
存储并找到该函数的一个保存的版本，抓取它并使用它。
store and finds a single saved version
of that function, grabs it, and uses it.

9
00:00:30.248 --> 00:00:31.504
我们喜欢它。
We love it.

10
00:00:31.504 --> 00:00:38.369
但正如我所说的，它确实涉及到相当多的代码编写。
But as I say, it does involve quite
a little bit of writing of code.

11
00:00:38.369 --> 00:00:43.340
所以如果我们回头看，我们使用 object.create 手动创建对象,
So if we look back, we had creating
the object manually using object.create,

12
00:00:43.340 --> 00:00:44.759
存储在一个新用户中。
storing in a new user.

13
00:00:44.759 --> 00:00:47.915
顺便说一下，这只是一个暂时的名字，他们从来不用这个名字。
By the way, just a temporary name for
it,they never get stuck with that name.

14
00:00:47.915 --> 00:00:52.252
手动返回该对象后，我们还编写了相应的代码。
Returning out that object manually,
we wrote the code for that as well.

15
00:00:52.252 --> 00:00:56.283
创建一个使用函数存储的键。
Creating a bond to use a function store.

16
00:00:56.283 --> 00:01:00.996
如果我们可以自动化这些东西不是很好吗？
Wouldn't it be nice if we
could automate that stuff?

17
00:01:00.996 --> 00:01:02.286
你知道吗？
And you know what?

18
00:01:02.286 --> 00:01:06.114
会有一个关键词，我会用蓝色，但是
There's gonna be a key word,
I'm gonna use blue for it, but

19
00:01:06.114 --> 00:01:11.466
我要插入在运行我的函数之前，那个关键字是什么？
I'm gonna insert in front of running my
function, what is that keyword everybody?

20
00:01:11.466 --> 00:01:12.524
因为我已经写了，我不应该有，这是什么？
Cuz I've written up already I
shouldn't have, what is it?

21
00:01:12.524 --> 00:01:13.180
布莱登: 新的。
&gt;&gt; Braden: New.

22
00:01:13.180 --> 00:01:15.301
威尔 · 森坦斯: 新的，干得好，各位。
&gt;&gt; Will Sentance: New,
well done everybody.

23
00:01:15.301 --> 00:01:19.507
对不起，新的[声音] ，为什么如果我们说它是一个新的,
Sorry, new [SOUND], and
why if we say it's a new,

24
00:01:19.507 --> 00:01:23.408
有趣的是，我要说这个词和
interesting, I'm going
to say that word and

25
00:01:23.408 --> 00:01:27.944
人们，它将自动化，这么多东西为我们。
people it's going to automate so
much stuff for us.

26
00:01:27.944 --> 00:01:34.490
它会在这里自动创建一个对象。
It's going to create automatically
inside of here an object.

27
00:01:34.490 --> 00:01:37.561
所以所有蓝色的东西都是要做的东西
So everything in blue is going to be
the stuff that's going to be done for

28
00:01:37.561 --> 00:01:38.548
通过新的关键词。
us by the new keyword.

29
00:01:38.548 --> 00:01:42.000
所以我们不需要这样做，我们不需要再编写代码了。
So we don't have to do it,
we don't have to write that code anymore.

30
00:01:42.000 --> 00:01:45.966
它会自动为我们创建一个新对象。
It's gonna create a new object for
us automatically.

31
00:01:45.966 --> 00:01:49.070
它会自动为我们返回那个物体。
It's gonna return that object out for
us automatically.

32
00:01:49.070 --> 00:01:53.680
是啊,
Yeah,

33
00:01:58.879 --> 00:02:01.042
威尔 · 森塔斯: 这也是，相信它或者
&gt;&gt; Will Sentance: It's also, believe it or

34
00:02:01.042 --> 00:02:07.135
不，它会使链接到某些对象充满了功能在这里,
not, it's gonna make the link to some
object full of functions out here,

35
00:02:07.135 --> 00:02:09.907
对我们来说也是自动的。
automatically for us, as well.

36
00:02:09.907 --> 00:02:14.667
也会自动为我们设置原型属性。
Gonna set the proto property
automatically for us as well.

37
00:02:14.667 --> 00:02:18.332
我要说的是，我们可能会想到的地方？
I will say this, to where we might think?

38
00:02:18.332 --> 00:02:23.540
因为，等等，在我们手动设置寻找新用户的对象之前
Because, hold on, before we manually set
that object that we sought a new user to

39
00:02:23.540 --> 00:02:28.693
有它隐藏原型财产链接使用功能商店已经存在。
have it hidden proto property linked to
use a function store was already there.

40
00:02:28.693 --> 00:02:30.240
但是现在我认为情况就是这样。
But now I thought would be the case.

41
00:02:30.240 --> 00:02:34.188
所以我不知道我们要把我们的共享存储功能放在哪里，如果没有的话
So I don't know where we're going to
put our shared store functions if not

42
00:02:34.188 --> 00:02:38.153
在用户功能存储中，我们不能再自己控制了。
in user function store, we're not
going to control any more ourselves.

43
00:02:38.153 --> 00:02:44.753
另一个问题是，我是如何在这个对象上添加属性的？
Another thing by the way is, how did I
get to put properties on this object?

44
00:02:44.753 --> 00:02:48.765
为了能够访问这个对象，我映射了哪个标签
What label did I have mapped in order
to be able to access this object and

45
00:02:48.765 --> 00:02:50.195
粘在上面。
stick properties on it.

46
00:02:50.195 --> 00:02:51.054
我给它贴了什么标签？
What label did I give it?

47
00:02:51.054 --> 00:02:51.614
布莱登: 新用户。
&gt;&gt; Braden: New user.

48
00:02:51.614 --> 00:02:55.191
如果这个对象是为我们自动创建的,
&gt;&gt; Will Sentance: If that object is
being automatically created for us,

49
00:02:55.191 --> 00:02:57.064
我能给它贴上标签吗？
do I get to assign it a label?

50
00:02:57.064 --> 00:02:57.973
没有。
No.

51
00:02:57.973 --> 00:03:01.152
我们有几个问题，链接到哪里？
So we got a couple of questions,
where we gonna link off to?

52
00:03:01.152 --> 00:03:07.383
这个对象会自动给出什么标签？
And what's this object gonna
automatically given as a label?

53
00:03:07.383 --> 00:03:09.747
我希望这不是我们用来
I hope it's not the same
label as we have for

54
00:03:09.747 --> 00:03:14.230
其他函数调用中的其他函数，那就有点傻了，不是吗？
something else in other function calls,
that'd be a bit silly, wouldn't it?

55
00:03:14.230 --> 00:03:17.979
是的，我们不想，我们不想让它被说，例如,
Yeah, we wouldn't wanna, we wouldn't
want to have it be say for example,

56
00:03:17.979 --> 00:03:21.330
这个在另一个地方指的是完全不同的东西。
this that in another place refers
to something totally different.

57
00:03:21.330 --> 00:03:23.653
那太疯狂了。
That would be very crazy.

58
00:03:23.653 --> 00:03:30.838
好了，好了，同志们，新的关键词自动化了艰苦的工作。
All right, okay, people, so
new keyword automates the hard work.

59
00:03:30.838 --> 00:03:34.094
当我们调用返回对象的函数时,
When we call the function
that returns an object,

60
00:03:34.094 --> 00:03:37.516
有了新的关键词，我们可以自动完成两件事。
with the new keyword in
front we automate 2 things.

61
00:03:37.516 --> 00:03:41.194
首先，我们自动创建对象。
Well, firstly,
we create the object automatically.

62
00:03:41.194 --> 00:03:44.288
然后，我们看到我已经把新的在它前面。
Then, so we see I've put
the new in front of it now.

63
00:03:44.288 --> 00:03:46.260
然后我们自动返回对象。
Then we return the object automatically.

64
00:03:46.260 --> 00:03:48.507
与此同时，我们要确保把东西放进去。
In the meantime,
we make sure we stick stuff in it.

65
00:03:48.507 --> 00:03:52.175
但是现在我们需要调整如何写这个函数的函数体，userCreator,
But we now need to adjust how we write
the body of this function, userCreator,

66
00:03:52.175 --> 00:03:52.908
它的密码。
the code of it.

67
00:03:52.908 --> 00:03:56.456
我们如何引用这个自动创建的对象和
How can we refer to this
auto-created object and

68
00:03:56.456 --> 00:04:02.352
知道把我们的单一版本，共享函数的一个版本放在哪里吗？
know where to put our single versions,
one of versions of the shared functions?

69
00:04:02.352 --> 00:04:05.112
因为我没有选择把它放进什么东西里
Because I didn't get to
choose to put it in something

70
00:04:05.112 --> 00:04:07.137
叫做用户功能存储。
called user function store anymore.

71
00:04:07.137 --> 00:04:10.132
我们现在可以回答的第一个问题是，猜一猜。
The first bit we can answer right now,
have a guess.

72
00:04:10.132 --> 00:04:14.640
你认为他们把这个自动创建任何人的对象叫什么
What do you think they call this object
that automatically created anyone take

73
00:04:14.640 --> 00:04:15.675
猜猜看，彼得？
a guess, Peter?

74
00:04:15.675 --> 00:04:16.954
布莱登: 是的，威尔 · 森坦斯: 是的,
&gt;&gt; Braden: Yes
&gt;&gt; Will Sentance: Yes,

75
00:04:16.954 --> 00:04:21.279
这就是我们要说的。
this exactly is going to be called this.

76
00:04:21.279 --> 00:04:25.485
因为这指的是它唯一给定的对象或者
Given that this refers to
its only given object or

77
00:04:25.485 --> 00:04:28.468
那个物体的另一个阶段。
a different stage of that object.

78
00:04:28.468 --> 00:04:31.930
然后，当我们稍后在对象及其执行角落运行 increment 时,
Then when we later on run increment on
the object and in its execution corner,

79
00:04:31.930 --> 00:04:34.911
它指的是点左边的物体,
is that this refers to whatever
the object is to the left of the dot,

80
00:04:34.911 --> 00:04:36.261
他们是完全分开的。
they're totally separate.

81
00:04:36.261 --> 00:04:38.798
当我们阅读我们的代码时，这有点令人困惑,
That's a little bit confusing
when we read our code, well,

82
00:04:38.798 --> 00:04:41.055
不是一点点，而是非常令人困惑。
not just a little bit,
it's profoundly confusing.

83
00:04:41.055 --> 00:04:44.867
这是另一个关键的规则。
This is the other key
rule of how this works.

84
00:04:44.867 --> 00:04:49.394
它总是点左边的对象，当我们运行一个方法时,
It's always whatever the object is to
the left of the dot when we run a method,

85
00:04:49.394 --> 00:04:52.262
这是隐式分配给用户1的。
that this is implicitly
assigned to the user 1.

86
00:04:52.262 --> 00:04:57.370
如果我们使用一个新的关键字，它还有另一个角色，即自动创建的对象
It has one other role, if we use a new
keyword, the automatically created object

87
00:04:57.370 --> 00:05:02.946
都会标记这个，但它们是完全独立的。
inside of that execution context is gonna
label this, but they're totally separate.

88
00:05:02.946 --> 00:05:08.396
我们要在哪里输出我们想要的单个保存的函数版本,
Okay, where are we gonna put out single
saved version of the function we want,

89
00:05:08.396 --> 00:05:11.132
所有执行过程中产生的对象？
all objects that come from executing?

90
00:05:11.132 --> 00:05:14.869
这些都是完全不同的用户创建执行，我们希望在哪里
These are totally different executions
of user creator, where do we want all

91
00:05:14.869 --> 00:05:18.274
那些共享的功能，这些对象有一个链接来存储？
those shared functions that these
objects have a link to to be stored?

92
00:05:18.274 --> 00:05:22.266
为了理解这一点，我们需要再加上一段精彩的插曲,
To understand that, we need to add
one more preeminent interlude,

93
00:05:22.266 --> 00:05:23.461
让我们看看。
let's have a look.

94
00:05:23.461 --> 00:05:25.341
在我们开始之前,
Preeminent interlude, before we do that,

95
00:05:25.341 --> 00:05:27.536
新的关键字让我们的许多手工工作自动化了。
the new keyword automates
a lot of our manual work.

96
00:05:27.536 --> 00:05:30.632
你看，我们摆脱了对象的创建，就要完成了
You see we get rid of the creation of
the object is going to be done for

97
00:05:30.632 --> 00:05:31.584
给我们新钥匙。
us with the new key.

98
00:05:31.584 --> 00:05:34.716
当我们运行用户创建的新是要插入和
When we run user created
new is gonna insert and

99
00:05:34.716 --> 00:05:38.492
它会自动把这条线固定在那里,
it's going to automatically
stick that line up there,

100
00:05:38.492 --> 00:05:42.692
创建一个新的对象将尝试这样做，而不是新用户。
creating a new object is going to
try to do this not to new user.

101
00:05:42.692 --> 00:05:45.858
然后我们就可以用这个访问那个物体了。
We're then gonna have access
to that object using this.

102
00:05:45.858 --> 00:05:48.021
我们不再使用 newUser.name 了。
We're not gonna do newUser.name anymore.

103
00:05:48.021 --> 00:05:50.721
我们要用这个名字来修理它。
We're gonna do this name
to fix stuff in it.

104
00:05:50.721 --> 00:05:57.173
它会自动将这个对象返回给用户1。
And it's gonna automatically return
that this object out into user 1.

105
00:05:57.173 --> 00:06:03.122
但是我们的功能存储，我们与功能存储的连接已经结束了。
But our function store, our connection to
function store that's done and gone now.

106
00:06:03.122 --> 00:06:05.382
那么我们要去哪里呢？
So where are we going to?

107
00:06:05.382 --> 00:06:11.278
我们需要一个大的古老的物体，我们可以肯定，在他们的帮助下,
We need a big old object that we
can be sure that with their help,

108
00:06:11.278 --> 00:06:17.512
使用新的关键字，自动创建的对象,
with a new keyword, the object
that gets automatically created,

109
00:06:17.512 --> 00:06:22.103
它的原始属性会连接到某个对象。
its proto property will
link off to some object.

110
00:06:22.103 --> 00:06:23.552
我需要知道它会在哪里。
I need to know where that's gonna be.

111
00:06:23.552 --> 00:06:30.257
为了找出它会在哪里，让我们来看看这个小插曲。
To find out where it's gonna be, let's
take a look at this little interlude.

112
00:06:30.257 --> 00:06:35.665
函数在 JavaScript 中既是对象又是函数。
Functions are both objects and
functions in JavaScript.

113
00:06:35.665 --> 00:06:38.216
伙计们，我们需要它。
We need it over here, people.

114
00:06:38.216 --> 00:06:42.795
这里有一小段额外的插曲，对我们来说真的很重要。
A little bit of a bonus interlude here,
really important for us to understand.

115
00:06:42.795 --> 00:06:47.225
所以我们有，记忆，你知道它只是一个,
So we have, memory, you know it's just a,

116
00:06:47.225 --> 00:06:52.446
让我们做一个，威尔 · 森塔斯: 一点工作。
let's do a,
&gt;&gt; Will Sentance: Bit of work.

117
00:06:52.446 --> 00:06:56.752
是啊，看看这是基于
Yeah, look at that was based on

118
00:06:56.752 --> 00:07:01.398
我们的一位观众的建议。
advice from one of our audience.

119
00:07:01.398 --> 00:07:04.153
这里的第一行，丹，我们在内存中做什么？
So line 1 here, Dan,
what are we doing in memory?

120
00:07:04.153 --> 00:07:06.872
丹: 我们存储的是 multiplyBy2函数。
&gt;&gt; Dan: We are storing
the function multiplyBy2.

121
00:07:06.872 --> 00:07:13.535
威尔 · 森坦斯: 是的，存储倍增2函数，就是这个。
&gt;&gt; Will Sentance: Yeah, store
the function multiplyBy2, there it is.

122
00:07:13.535 --> 00:07:19.110
好的，2号线，杰夫，我们在那条线上做什么？
Okay, line 2 Jeff,
what are we doing in that line?

123
00:07:19.110 --> 00:07:23.596
杰夫: 我们正在 multilyby2上创建一个物业商店,
&gt;&gt; Jeff: We are creating
a property store on multiplyBy2,

124
00:07:23.596 --> 00:07:25.896
威尔 · 桑坦斯: 但它是一个函数,
&gt;&gt; Will Sentance: But it's a function,

125
00:07:25.896 --> 00:07:27.353
除非是杰夫？
unless Jeff?

126
00:07:27.353 --> 00:07:28.747
杰夫: 是一个物体。
&gt;&gt; Jeff: It's an object.

127
00:07:28.747 --> 00:07:30.454
一个函数加一个对象。
&gt;&gt; Will Sentance: A function
plus an object.

128
00:07:30.454 --> 00:07:34.632
一旦 JavaScript 看到这个关键字函数,
It turns out as soon as that
JavaScript sees that keyword function,

129
00:07:34.632 --> 00:07:36.391
知道函数即将到来,
knows a function is coming,

130
00:07:36.391 --> 00:07:42.790
我们得到一个函数加，威尔 · 森坦斯: a
we get a function plus,
&gt;&gt; Will Sentance: A big

131
00:07:42.790 --> 00:07:44.793
旧物附着。
old object attached.

132
00:07:44.793 --> 00:07:50.439
如果我们在函数的末尾使用括号，我们马上就会看到。
If we use parens on the end of
the function, well, we’ll see in a second.

133
00:07:50.439 --> 00:07:53.380
如果我们在函数标签的末尾使用点，则
If we use dot on the end of
the function label, the label for

134
00:07:53.380 --> 00:07:55.918
这个函数，我们可以接触到 Jeff 的哪一部分？
the function,
which bit do we get access to Jeff?

135
00:07:55.918 --> 00:07:57.269
杰夫: 那是什么？
&gt;&gt; Jeff: What’s that?

136
00:07:57.269 --> 00:08:00.319
如果我们在多个 by2标签的末尾使用点,
&gt;&gt; Will Sentance: If we use dot on
the end of the multiplyBy2 label,

137
00:08:00.319 --> 00:08:02.798
函数对象组合的哪一部分。
which bit of the function object combo.

138
00:08:02.798 --> 00:08:03.723
我叫他们，我们有哪一部分？
I call them, which bit do we have?

139
00:08:03.723 --> 00:08:09.697
我们得到对象位的访问权，正好通过点，进入它。
We get access to the object bit, exactly
right through the dot, into it we go.

140
00:08:09.697 --> 00:08:11.151
我们要在里面放什么，布莱登？
And what are we gonna store in it, Braden?

141
00:08:11.151 --> 00:08:12.170
布莱登: 5。
&gt;&gt; Braden: 5.

142
00:08:12.170 --> 00:08:13.838
威尔 · 森特斯: 是的，什么地产的名称？
&gt;&gt; Will Sentance: Yeah,
on what property name?

143
00:08:13.838 --> 00:08:14.660
存储。
&gt;&gt; Braden: Stored.

144
00:08:14.660 --> 00:08:16.851
威尔 · 森特斯: 存储，看看这个，太棒了。
&gt;&gt; Will Sentance: Stored,
look at that, fantastic.

145
00:08:16.851 --> 00:08:20.302
但也许看看下一行,
But maybe, look at that next line,

146
00:08:20.302 --> 00:08:25.827
也许当我们运行 multimyby2，输入3。
maybe when we then run
multiplyBy2 with the input of 3.

147
00:08:25.827 --> 00:08:29.403
也许这样做不再有效，因为这样做可能会覆盖函数
Maybe that doesn't work anymore because
maybe doing this overwrote the function

148
00:08:29.403 --> 00:08:30.399
暗号，是吗，布莱登？
code, did it Braden?

149
00:08:30.399 --> 00:08:33.177
不，是什么让我们现在仍然使用函数位,
No, what allows us now to
still use the function bit,

150
00:08:33.177 --> 00:08:34.917
我们用的是什么符号？
what symbols we're using here?

151
00:08:34.917 --> 00:08:35.629
布莱登: 巴黎人。
&gt;&gt; Braden: The parens.

152
00:08:35.629 --> 00:08:39.934
威尔 · 森坦斯: parenns，意思是去使用函数位,
&gt;&gt; Will Sentance: Parens, and
that means go use the function bit,

153
00:08:39.934 --> 00:08:42.354
它会返回6。
it's gonna return out 6.

154
00:08:42.354 --> 00:08:47.657
但是，也许使用函数会覆盖对象。
But maybe that using the function
is overwritten the object, maybe.

155
00:08:47.657 --> 00:08:50.628
如果我们使用点符号，我们还能访问我们的对象吗？
Braden do we still get access to our
object if we use a dot notation?

156
00:08:50.628 --> 00:08:51.432
布莱登: 是的。
&gt;&gt; Braden: Yes.

157
00:08:51.432 --> 00:08:52.142
威尔 · 森坦斯: 是的，我们知道。
&gt;&gt; Will Sentance: Yeah, we do.

158
00:08:52.142 --> 00:08:56.570
函数对象，我们说的是对象，但是
Function object and
we're talking about an object as much, but

159
00:08:56.570 --> 00:08:58.866
它在每个功能中都有。
it is in every function is there.

160
00:08:58.866 --> 00:09:02.197
但结果会非常非常非常有用。
But it's gonna turn out here to be super,
super, super useful.

161
00:09:02.197 --> 00:09:05.181
但是如果你想相信所有的功能也有,
But if you want to believe
will all functions also have,

162
00:09:05.181 --> 00:09:08.177
非常好的现场什么所有的函数也默认有。
very nice spot what all
functions also have by default.

163
00:09:08.177 --> 00:09:08.840
原型？
&gt;&gt; Braden: Prototype?

164
00:09:08.840 --> 00:09:10.967
威尔 · 森塔斯: a，我不想这么说。
&gt;&gt; Will Sentance: A,
I don't wanna say that.

165
00:09:10.967 --> 00:09:16.216
一个财产，不，好吧，是的，那是什么，但是，不，好吧，是的，他们做，天哪，是的。
A property, no well, yeah, that's what,
but a, no, well, yes they do, gosh, yeah.

166
00:09:16.216 --> 00:09:18.999
我们将会看到这一点，尽管你会在 OOP 大厅中看到暂停。
We're gonna see that,
though you'll see that in OOP hall pause.

167
00:09:18.999 --> 00:09:22.952
专门研究 OOP haber，但是现在对我们来说更重要的是，它们有一个属性。
Specialize OOP Habert, but more important
to us right now, they have a property.

168
00:09:22.952 --> 00:09:25.390
没什么神奇的当你看到 doc 原型的时候,
Nothing magical,
when you see the doc prototype,

169
00:09:25.390 --> 00:09:28.750
我们认为，也许这其中有某种神奇的意外收获。
we think, maybe there's some kind
of magical bonus in all that.

170
00:09:28.750 --> 00:09:31.475
它是一个物体的属性，这个属性的名字是什么？
It's a property of an object and
the name of the property is what Braden?

171
00:09:31.475 --> 00:09:34.421
2.
&gt;&gt; Braden: MultiplyBy2.

172
00:09:34.421 --> 00:09:36.134
威尔 · 森特斯: 不完全是，彼得，房子的名字是？
&gt;&gt; Will Sentance: Not quite, Peter,
the name of the property is?

173
00:09:36.134 --> 00:09:36.703
原型。
&gt;&gt; Peter: Prototype.

174
00:09:36.703 --> 00:09:37.336
原型。
&gt;&gt; Will Sentance: Prototype.

175
00:09:37.336 --> 00:09:42.397
没错，这个性质只是原型和 o。
Exactly, that property
is just prototype and o.

176
00:09:42.397 --> 00:09:43.998
这就是有趣的地方。
Here is where it gets interesting.

177
00:09:43.998 --> 00:09:48.653
所有对象格式的函数都会自动启用
It's always on that all functions in
their object format automatically have

178
00:09:48.653 --> 00:09:49.875
他们的财产。
a property on them.

179
00:09:49.875 --> 00:09:53.125
我的意思是，为什么点点，实际上是自动在那里,
I mean, why did the dot dot dot,
actually was that automatically there,

180
00:09:53.125 --> 00:09:53.971
整个原型？
whole prototype?

181
00:09:53.971 --> 00:09:56.476
它不是隐藏的财产。
It is not a hidden property.

182
00:09:56.476 --> 00:09:59.293
就像是对象位的一个属性。
It's like a it's a property
on the object bit.

183
00:09:59.293 --> 00:10:00.341
我们只是不想看到这一点。
We just don't tend to look at this bit.

184
00:10:00.341 --> 00:10:03.235
我们需要控制台日志多次按下一点下来。
We'd need to console log multiple
by to press a little down.

185
00:10:03.235 --> 00:10:07.434
我的意思是，我猜那些东西是对我们隐藏起来的，而且就在那里。
I mean, I guess the objects kind of
hidden from us and it's on there.

186
00:10:07.434 --> 00:10:09.226
这是什么？
What is it?

187
00:10:09.226 --> 00:10:13.384
丹，默认的原型属性是什么？
Dan, what is the prototype
property default to be?

188
00:10:13.384 --> 00:10:14.124
空物体。
&gt;&gt; Dan: Empty object.

189
00:10:14.124 --> 00:10:15.534
威尔 · 森塔斯: 一个又大又旧的空物体。
&gt;&gt; Will Sentance: A big old empty object.

190
00:10:15.534 --> 00:10:19.736
看看这个。
Look at that.

191
00:10:19.736 --> 00:10:24.721
意思是，我们要使用的函数，当它得到执行和
Meaning, the function that we're gonna
use new one when it gets executed and

192
00:10:24.721 --> 00:10:29.780
它会自动创建一个迫切需要链接的对象,
it creates an object automatically that
desperately needs a place to link to,

193
00:10:29.780 --> 00:10:35.243
一个旧的大空对象，在其中存储我们的函数与我们一起存储函数。
an old big empty object, in which to store
our functions with us to store functions.

194
00:10:35.243 --> 00:10:40.386
这个函数不仅仅是一个函数，它还是一个什么杰夫？
That function is not just a function,
it's also a what Jeff?

195
00:10:40.386 --> 00:10:41.086
杰夫: 一个物体。
&gt;&gt; Jeff: An object.

196
00:10:41.086 --> 00:10:41.769
威尔 · 森塔斯: 一个客体。
&gt;&gt; Will Sentance: An object.

197
00:10:41.769 --> 00:10:45.639
那个物体不是空的，里面有什么？
And that object is not empty,
it's got what in that?

198
00:10:45.639 --> 00:10:46.725
杰夫: 一个原型财产。
&gt;&gt; Jeff: A prototype property.

199
00:10:46.725 --> 00:10:51.097
威尔 · 森坦斯: 一个正确的原型，说得好，那是什么，马克？
&gt;&gt; Will Sentance: A prototype properly,
nicely put, which is what, Mark?

200
00:10:51.097 --> 00:10:54.039
马特: 一个又大又旧的空物体。
&gt;&gt; Matt: A big old empty object.

201
00:10:54.039 --> 00:10:57.648
威尔 · 森塔斯: 我们认为在哪些地方，人们可能会觉得它有意义
&gt;&gt; Will Sentance: Where do we think
folk that it might make sense for

202
00:10:57.648 --> 00:10:59.937
我们得到了新的关键字
us to have the new keyword or for

203
00:10:59.937 --> 00:11:05.221
决定了新的关键字自动创建对象
JavaScript to have decided the new
keywords auto created object inside

204
00:11:05.221 --> 00:11:10.153
创建一个函数，让它拥有自己的协议
the running of the userCreate
a function for it to have its protocol

205
00:11:10.153 --> 00:11:15.195
如果它不能指定它的用户函数存储，那么连接是什么呢？
connection be to if it can't specify
that its user function store?

206
00:11:15.195 --> 00:11:16.739
马特，你觉得在哪里说得通？
Matt, where do you think
it might make sense?

207
00:11:16.739 --> 00:11:17.524
马特: 原型属性。
&gt;&gt; Matt: The prototype property.

208
00:11:17.524 --> 00:11:20.455
Will Sentance: 我们将要运行的函数的 Prototype 属性
&gt;&gt; Will Sentance: Prototype property of
the function that we're then going to run

209
00:11:20.455 --> 00:11:24.090
新的关键字，或者我们要运行新的关键字，这样它创建
the new keyword or we're going to run with
the new keyword on such that it creates

210
00:11:24.090 --> 00:11:25.461
里面有个自动物体。
an automatic object inside.

211
00:11:25.461 --> 00:11:30.308
它的原始属性
And that's gonna have a bond for
its proto property to

212
00:11:30.308 --> 00:11:34.625
那个原型属性，也就是一个物体。
that prototype property,
which is an object.

213
00:11:34.625 --> 00:11:39.168
协议不会链接使用函数存储，但是
The protocol is going to not link
to use the function store, but

214
00:11:39.168 --> 00:11:40.894
连接到这个对象。
link up to this object.

215
00:11:40.894 --> 00:11:44.838
因此，我们最好把我们的函数，我们希望所有的对象出来
So we better put our functions that
we want all objects that come out of

216
00:11:44.838 --> 00:11:49.326
自动，或出来运行用户创建的新关键字在前面
the auto, or come out to running user
created with the new keyword in front that

217
00:11:49.326 --> 00:11:53.746
自动创建一个对象，它需要有一个链接的地方
creates an object automatically, which
needs somewhere to have a link to for

218
00:11:53.746 --> 00:11:55.114
它的共同功能。
its shared functions.

219
00:11:55.114 --> 00:11:59.870
它们自动成为创建对象的函数
They're automatically gonna be that
function that creates the object with

220
00:11:59.870 --> 00:12:02.990
对象版本中新关键字的帮助,
the help of the new keyword
in its object version,

221
00:12:02.990 --> 00:12:06.798
在它的原型属性中，它本身就是一个对象。
in the prototype property of it,
which is itself An object.
