WEBVTT

1
00:00:00.600 --> 00:00:04.522
威尔 · 森坦斯: 303毫秒。
&gt;&gt; Will Sentance: At 303 milliseconds.

2
00:00:07.118 --> 00:00:11.740
威尔 · 森塔斯(笑) : 我不知道为什么每个人都害怕这种期待。
&gt;&gt; Will Sentance: [LAUGH] I don't know
why everyone, fears this anticipation.

3
00:00:11.740 --> 00:00:12.919
这是显而易见的。
It's obvious, surely.

4
00:00:12.919 --> 00:00:15.480
我知道队列是怎么工作的，我甚至在队列之间放了一个逗号，所以
I know how queues work,
I even put a little comma between, so

5
00:00:15.480 --> 00:00:17.609
我们真的知道排队是怎么回事。
we really know how queues work.

6
00:00:17.609 --> 00:00:21.570
我的事件循环，在这里，让我们确保它在这里，在这里。
My event loop, there it is let's make
sure it's on there, there it is.

7
00:00:21.570 --> 00:00:25.748
事件循环，就是检查这个是否为空的循环。
The event loop, that's the one that's
gonna do the checking if this is empty.

8
00:00:25.748 --> 00:00:26.868
是空的吗？
Was it empty?

9
00:00:26.868 --> 00:00:27.718
是空的吗？
Was it empty?

10
00:00:27.718 --> 00:00:28.524
是空的吗？
Was it empty?

11
00:00:28.524 --> 00:00:29.100
没有。
No.

12
00:00:29.100 --> 00:00:30.699
全局上下文运行完毕了吗？
Was the global context finished running?

13
00:00:30.699 --> 00:00:31.449
没有。
No.

14
00:00:31.449 --> 00:00:33.520
所以事情没有进展，没有。
So the event was going nope, nope.

15
00:00:34.590 --> 00:00:36.229
但是它变成了3毫秒。
But it turned to three milliseconds.

16
00:00:36.229 --> 00:00:37.600
事件循环检查调用堆栈,
The event loop checks the call stack,

17
00:00:37.600 --> 00:00:42.030
进一步检查，全局代码运行，然后它会说，我们可以走了吗？
checks it any further, global code to run,
and it goes, are we good to go?

18
00:00:42.030 --> 00:00:44.890
我们可以走了，我们可以检查我们的队列了。
We're good to go,
we're good to check our queue.

19
00:00:46.079 --> 00:00:48.619
什么，在那个时候，它会运行吗？
What, at that point, is it gonna run?

20
00:00:48.619 --> 00:00:50.109
这应该很明显吧？
Well, it should be obvious?

21
00:00:50.109 --> 00:00:51.210
谁愿意做志愿者？
Who would like to volunteer?

22
00:00:52.530 --> 00:00:53.689
我不想要正确的答案,
I don't want the right answer,

23
00:00:53.689 --> 00:00:56.674
我想知道排队所说的答案，就是这个答案。
I want the answer that follows what
a queue says is gonna be the answer here.

24
00:00:56.674 --> 00:00:57.331
观众: (笑)威尔 · 森塔斯: 布雷登,
&gt;&gt; Audience: [LAUGH]
&gt;&gt; Will Sentance: Brayden,

25
00:00:57.331 --> 00:00:57.899
拜托，谢谢。
please, thank you.

26
00:00:57.899 --> 00:00:58.835
布雷登: 火车，喂？
&gt;&gt; Brayden: Train hello?

27
00:00:58.835 --> 00:01:01.564
威尔 · 桑塔斯: 当然，因为打印机[听不见]已经打印出来了
&gt;&gt; Will Sentance: Of course because
printers [INAUDIBLE] bcnf so

28
00:01:01.564 --> 00:01:05.147
我知道排队是怎么回事,
long it's in the front of,
I know how a queue works and yet,

29
00:01:05.147 --> 00:01:09.382
他从根本上来说是错的，我的意思是肯定是好的，而不是一些事情
he is fundamentally wrong I mean
surely nice rather some things and yet

30
00:01:09.382 --> 00:01:12.897
这次不行[笑]观众: [笑]
not this time [LAUGH]
&gt;&gt; Audience: [LAUGH]

31
00:01:12.897 --> 00:01:13.882
威尔 · 森坦斯: 好吧,
&gt;&gt; Will Sentance: All right,

32
00:01:13.882 --> 00:01:17.337
你觉得 Brayden 到底在跑什么？
what do you think runs actually Brayden?

33
00:01:17.337 --> 00:01:18.903
布雷登: 展览。
&gt;&gt; Brayden: The display.

34
00:01:18.903 --> 00:01:20.450
威尔 · 森特斯: 是的。
&gt;&gt; Will Sentance: Yeah.

35
00:01:20.450 --> 00:01:23.239
但这没有道理，我知道队列是如何工作的。
But that makes no sense,
I know how queues work.

36
00:01:23.239 --> 00:01:25.817
知识分子，有没有人可以放手一搏,
Can anybody take a leap
of faith intellectual,

37
00:01:25.817 --> 00:01:28.750
这里可能会发生什么？
on what might be happening here instead?

38
00:01:28.750 --> 00:01:30.200
这次由我来照顾凯拉。
I'm gonna tend to Kayla on this one.

39
00:01:31.450 --> 00:01:32.656
排队的队伍不一样。
&gt;&gt; Kayla: It's a different queue.

40
00:01:32.656 --> 00:01:33.759
威尔 · 森特斯: 她说对了。
&gt;&gt; Will Sentance: She got it right.

41
00:01:33.759 --> 00:01:36.219
我告诉你，在我做这个演讲的所有时间里，我会说一个或者
I tell you, in all the time I've
given this talk, I would say one or

42
00:01:36.219 --> 00:01:38.530
有两倍的人会这么做。
two times that people
would take that leap.

43
00:01:38.530 --> 00:01:41.900
凭直觉的信念，对凯拉大声疾呼，完全正确。
Of intuit faith, so
huge shout out to Kayla, exactly right.

44
00:01:41.900 --> 00:01:43.020
还有一个额外的队列。
There's an additional queue.

45
00:01:43.020 --> 00:01:44.281
别误会,
Now don't get me wrong,

46
00:01:44.281 --> 00:01:47.899
我留下的这个大空间可能是个线索。
this big space here that I left might
have been something of a giveaway.

47
00:01:47.899 --> 00:01:50.233
观众: (笑)威尔 · 森塔斯: 但是那真是太棒了,
&gt;&gt; Audience: [LAUGH]
&gt;&gt; Will Sentance: But that is fantastic,

48
00:01:50.233 --> 00:01:51.729
谢谢 Kayla。
thank you to Kayla.

49
00:01:51.729 --> 00:01:55.409
完全正确，事实上还有另一个队列。
Exactly right,
there is in fact another queue.

50
00:01:55.409 --> 00:01:58.993
在规范中，他们称之为任务队列。
It's called, they call this in the spec,
the task queue.

51
00:01:58.993 --> 00:02:01.572
所以，你可以猜猜另一个叫什么。
So, you can maybe take a guess
what the other one is called.

52
00:02:01.572 --> 00:02:04.591
它被称为微任务队列。
It's called the microtask queue.

53
00:02:04.591 --> 00:02:12.209
这就是微任务队列。
There it is, the microtask queue.

54
00:02:12.209 --> 00:02:16.170
当显示被触发时，我们会在哪里思考
And where do we think when
display is triggered, and

55
00:02:16.170 --> 00:02:18.759
准备好跑了吗，我们认为显示器会出现吗？
ready to run,
do we think display shows up?

56
00:02:18.759 --> 00:02:21.670
凯拉是在回复队列还是微任务队列？
Kayla is it in the callback queue,
or the microtask queue?

57
00:02:21.670 --> 00:02:22.420
微任务队列。
&gt;&gt; Kayla: The microtask queue.

58
00:02:22.420 --> 00:02:26.197
威尔 · 森坦斯: 微任务队列，她正好进入微任务队列。
&gt;&gt; Will Sentance: The microtask queue,
she is spot on into the microtask queue.

59
00:02:26.197 --> 00:02:29.822
顺便说一句,
It went display, with by the way,

60
00:02:29.822 --> 00:02:34.822
准备插入的高论点,
the high argument ready
to be inserted into it,

61
00:02:34.822 --> 00:02:38.949
高达270毫秒的数据。
the high data at 270 milliseconds.

62
00:02:38.949 --> 00:02:44.134
在那里，让我们把它从队列的后面拿出来。
There it is, let's get it out
of the back of the queue here.

63
00:02:44.134 --> 00:02:46.281
不不不不。
No, no, no, no, no.

64
00:02:46.281 --> 00:02:51.620
不在这里，感谢布雷登的配合。
Not here, thank you to Brayden for
playing along.

65
00:02:51.620 --> 00:02:57.590
不，不在队伍的后面，那么，在哪里呢？
No, not at the back of the queue there,
and so, where?

66
00:02:57.590 --> 00:03:00.604
一旦303毫秒的事件循环消失,
Once the event loop at
303 milliseconds goes,

67
00:03:00.604 --> 00:03:03.409
我们清楚同步全球代码了。
we're clear on
the synchronous global code.

68
00:03:03.409 --> 00:03:07.161
Kayla 你觉得会不会是第一个,
Where Kayla,
do you think it heads to first,

69
00:03:07.161 --> 00:03:10.730
你觉得它会先排到哪个队？
which queue do you think
it heads to first?

70
00:03:10.730 --> 00:03:13.695
微任务队列 Will Sentance: 微任务队列
&gt;&gt; Kayla: The microtask queue
&gt;&gt; Will Sentance: The microtask queue

71
00:03:13.695 --> 00:03:18.780
她的位置，它抓取显示，它排队，抓取它的代码。
she's spot on, it grabs display
it dequeues it, grabs its code.

72
00:03:20.039 --> 00:03:21.599
它把它放在调用堆栈上。
It puts it on the call stack.

73
00:03:23.189 --> 00:03:28.719
通过自动插入参数,
With the inserted argument automatically,

74
00:03:28.719 --> 00:03:32.860
的值高，它添加了父母自动 JavaScript。
of the value high, it adds
the parental automatically JavaScript.

75
00:03:32.860 --> 00:03:34.456
它会自动插入参数 JavaScript。
It inserts the argument
JavaScript automatically.

76
00:03:34.456 --> 00:03:35.118
我喜欢。
I love that.

77
00:03:35.118 --> 00:03:38.840
所以这点非常重要。
So that's very important to sort of spot.

78
00:03:38.840 --> 00:03:44.729
然后它执行它，然后，对马特来说。
And it executes it, and so what, to Matt.

79
00:03:44.729 --> 00:03:48.449
马特，在303毫秒的时候，我们的控制台会显示什么？
Matt, what's gonna show up in our console,
at 303 milliseconds?

80
00:03:48.449 --> 00:03:49.920
马特: 高 威尔 · 森特斯: 会很高,
&gt;&gt; Matt: High.
&gt;&gt; Will Sentance: It's gonna be high,

81
00:03:49.920 --> 00:03:51.349
我应该问托德的。
I should have asked Todd.

82
00:03:51.349 --> 00:03:56.349
会很高精确到303毫秒,
It's gonna be high,
exactly at 303 milliseconds,

83
00:03:56.349 --> 00:04:00.039
我们在我们的控制台里很兴奋。
we get high in our console.

84
00:04:01.360 --> 00:04:04.981
最后，我们可怜的小,
And finally, our poor little,

85
00:04:04.981 --> 00:04:09.680
微任务队列现在是空的。
the microtask queue is now empty.

86
00:04:09.680 --> 00:04:12.469
事件循环终于结束了。
And the event loop finally goes.

87
00:04:12.469 --> 00:04:15.669
是时候进入回调队列了。
It's time to go down
to the callback queue.

88
00:04:15.669 --> 00:04:17.750
它在哪里找到了什么？
Where what does it find?

89
00:04:17.750 --> 00:04:20.829
但是我们的小朋友打印你好,
But our little friend print hello,

90
00:04:20.829 --> 00:04:25.451
已经等了304毫秒了。
who's been waiting there for
304 milliseconds.

91
00:04:25.451 --> 00:04:31.937
但是，从调用堆栈中删除显示之后，它运行完毕,
But, after removing display from
the call stack, it's finished running,

92
00:04:31.937 --> 00:04:36.427
我们终于到了304毫秒
we're finally at 304 milliseconds,
are able for

93
00:04:36.427 --> 00:04:41.649
事件循环检查最后的队列，回调队列。
the event loop to check our final queue,
the callback queue.

94
00:04:41.649 --> 00:04:47.069
其中304毫秒，print hello 已经坐在那里准备运行。
Where for 304 milliseconds, print hello
has been sitting there ready to run.

95
00:04:47.069 --> 00:04:50.290
这是梦想，但现在是它的时刻。
It's dreamed, but now is its moment.

96
00:04:50.290 --> 00:04:52.827
看看它有多自豪。
Look how proud it is.

97
00:04:52.827 --> 00:04:55.949
它跳起来，进入调用堆栈。
It jumps up, into the call stack.

98
00:04:57.040 --> 00:05:03.850
在那里，它在调用堆栈上以304毫秒的速度打印 hello。
There it is print hello on the call
stack at 304 milliseconds.

99
00:05:03.850 --> 00:05:10.730
那么在304毫秒时，我们在控制台中看到了什么呢？
What therefore Ethan at 304 milliseconds,
what do we see in our console then?

100
00:05:10.730 --> 00:05:12.839
什么是控制台日志，但是？
What's gonna console log but?

101
00:05:12.839 --> 00:05:13.509
伊森: 你好。
&gt;&gt; Ethan: Hello.

102
00:05:13.509 --> 00:05:14.800
威尔 · 森坦斯: 你好。
&gt;&gt; Will Sentance: Hello.

103
00:05:14.800 --> 00:05:15.735
没错。
Exactly.

104
00:05:15.735 --> 00:05:19.021
[声音]哇，伙计们，干得好。
[SOUND] Wow people, well done.

105
00:05:19.021 --> 00:05:26.430
天哪，这就是幕后的同步 JavaScript 的整个模型。
My goodness, that is the entire model of a
synchronous JavaScript behind the scenes.

106
00:05:26.430 --> 00:05:28.043
我们有两个队列。
We have two queues.

107
00:05:28.043 --> 00:05:32.082
我们将 print hello 加入队列，然后从调用堆栈中取出它。
We enqueue print hello, we pop it
off the call stack at that point.

108
00:05:32.082 --> 00:05:37.696
我们有两个队列，任何从 JavaScript 中抛出的函数,
We have two queues, any function
that is thrown out of JavaScript,

109
00:05:37.696 --> 00:05:42.324
或者至少一个链接会从 JavaScript 中删除,
or at least a link back to it
is thrown out of JavaScript,

110
00:05:42.324 --> 00:05:47.654
通过传统的回调 facade 函数，比如 set timeout。
via the old school callback facade
functions like set timeout.

111
00:05:47.654 --> 00:05:53.180
这些函数在后台工作完成后，位于回调队列的第二位。
Those functions when the background work
is complete, second in the callback queue.

112
00:05:54.389 --> 00:06:00.029
任何通过 then 方法附加到承诺对象的函数,
Any function that is attached to
a promise object via the then method,

113
00:06:00.029 --> 00:06:03.519
然后自动触发运行 JavaScript
and then auto triggered to
run from within JavaScript

114
00:06:03.519 --> 00:06:08.060
当 promise 对象的 value 属性自动更新时,
when the value property that promise
object gets updated automatically,

115
00:06:08.060 --> 00:06:14.250
作为背景工作的结果，从双管齐下的立面功能，如获取。
as a result of the background work from
a two pronged facade function like fetch.

116
00:06:14.250 --> 00:06:17.639
这个函数不会进入回调队列。
That function ain't going
in the callback queue.

117
00:06:17.639 --> 00:06:20.379
它进入了微任务队列。
It's going in the microtask queue.

118
00:06:20.379 --> 00:06:22.649
当所有全局代码运行完毕时,
And when all global code
is finished running, and

119
00:06:22.649 --> 00:06:26.209
调用栈上什么都没有，事件循环检查队列。
there's nothing on the call stack,
the event loop goes and checks the queues.

120
00:06:26.209 --> 00:06:27.170
它先检查哪一个？
Which does it check first?

121
00:06:28.680 --> 00:06:30.089
微任务队列。
The microtask queue.

122
00:06:30.089 --> 00:06:31.891
它去除函数的队列，运行它，并且
It dequeues the function, runs it, and

123
00:06:31.891 --> 00:06:34.441
直到最后它才检查回调队列。
then only finally then does
it check the callback queue.
