WEBVTT

1
00:00:00.520 --> 00:00:04.653
结束函数得到背包给我们
&gt;&gt; Will Sentance: Closure functions
getting back packs give our

2
00:00:04.653 --> 00:00:07.729
功能持久的记忆。
functions persistent memories.

3
00:00:07.729 --> 00:00:08.606
看看这个,
Look at this,

4
00:00:08.606 --> 00:00:13.079
我的新功能有一个永久性的数据存储。
my new function has a persistent store
of data attached to it permanent.

5
00:00:13.079 --> 00:00:16.765
它就在附近，哪儿也去不了，一个隐藏处,
It sticks around,
it's not going anywhere, a cache,

6
00:00:16.765 --> 00:00:22.350
数据的永久存储为编写专业代码提供了全新的工具包。
permanent store of data gives entirely new
toolkit for writing professional code.

7
00:00:22.350 --> 00:00:24.824
首先是辅助函数，你可以在挑战中看到它们,
So firstly helper functions,
you see them in the challenges,

8
00:00:24.824 --> 00:00:27.307
普通的专业耳机，就像一旦你记住。
everyday professional headphones,
like once you memorize.

9
00:00:27.307 --> 00:00:29.664
让我们花点时间来看看这些。
Let's actually take
a second to look at these.

10
00:00:29.664 --> 00:00:34.168
所以一旦记住了，他就是一个例子。
So once a memorize,
he would be an example.

11
00:00:34.168 --> 00:00:36.924
也许我可以用红色，让我看看。
Maybe I can use red, let's see.

12
00:00:36.924 --> 00:00:41.889
所以如果我做一个1到5的乘以2,
So if I were to do a one to five
version of multiply by two,

13
00:00:41.889 --> 00:00:47.398
我第一次运行它的时候，输入7乘以2。
the first time I run it multiply
by two with the input of seven.

14
00:00:47.398 --> 00:00:50.667
它会给我14。
It would give me out 14.

15
00:00:50.667 --> 00:00:55.625
下次我运行它的时候，如果输入10，它就会发出 sorry，或者
Next time I run it, with the input
of ten it would give out sorry, or

16
00:00:55.625 --> 00:01:00.140
这样的事情，你不能再控制我了。
something like that,
you can't run me again.

17
00:01:00.140 --> 00:01:02.570
因为当我运行它的时候,
Because when I ran it,

18
00:01:02.570 --> 00:01:07.989
我会在运行另一个返回函数的运行程序中创建它。
I would have created it inside the runner
running another function returned out.

19
00:01:07.989 --> 00:01:09.519
然后我把它扔回柜台上。
And I throw it back over the counter.

20
00:01:09.519 --> 00:01:13.028
当我运行它的时候，我写的逻辑是它做乘法运算，但是
When I run it I written the logic
that it does the multiplication, but

21
00:01:13.028 --> 00:01:15.402
然后在背包里增加账户。
then it increments
accounts in the backpack.

22
00:01:15.402 --> 00:01:18.653
下次我运行它时，它会检查那个背包。
Next time I run it,
it checks that backpack.

23
00:01:18.653 --> 00:01:20.430
伯爵已经是一个了。
Count is already one.

24
00:01:20.430 --> 00:01:23.712
而不是做数学回报抱歉。
And instead of even doing
the math returns out sorry.

25
00:01:23.712 --> 00:01:27.319
它可能通常不这样做，而是实际上可能通常存储值
It might typically instead to do this it
might actually typically store the value

26
00:01:27.319 --> 00:01:28.388
14个，还有大概一包。
of 14 and about pack.

27
00:01:28.388 --> 00:01:31.018
下一次，它会返回原来的值。
And next time,
it's gonna return on that original value.

28
00:01:31.018 --> 00:01:32.968
这在实践中非常有用。
This is super useful in practice.

29
00:01:32.968 --> 00:01:35.835
显然不是绝望的这一个，但超级有用的实践。
Obviously not desperate for this one,
but super useful in practice.

30
00:01:35.835 --> 00:01:39.608
如果你正在构建任何你想锁定的应用程序
If you're building any App where
you want to lock down maybe for

31
00:01:39.608 --> 00:01:44.537
例如一个获胜的功能，当应用程序完成游戏结束。
example like a winning function, that when
the apps finish the game is finished.

32
00:01:44.537 --> 00:01:47.722
你不希望有人，重新运行那个函数，你希望这样做
And you want you don't want to have
someone, rerun that function, you want to

33
00:01:47.722 --> 00:01:50.774
锁定该函数，它只能运行一次，它的制胜功能。
lock that function down it can only be
run once it's the winning function.

34
00:01:50.774 --> 00:01:54.746
这是一个函数，当某人赢得比赛时，所有的一切都会触发
It's a function that when the when
somebody won the game triggers all the all

35
00:01:54.746 --> 00:01:57.930
比如，关于赢不赢井字棋的事。
the stuff to do on winning or
not it tic tac toe, for example.

36
00:01:57.930 --> 00:02:01.236
您不希望能够重置单元格中的任何值。
You don't wanna be able to reset
any of the values in the cells.

37
00:02:01.236 --> 00:02:04.439
一旦它有一个 o，它就被锁定了，你不能再运行它了。
Once it's got an o, it's locked down,
you can't run it again.

38
00:02:04.439 --> 00:02:06.010
一旦它找到一个真正的干净和
Once it finds a really clean and

39
00:02:06.010 --> 00:02:10.312
可读的方式锁定代码，而不是运行它多次，这是有点不错。
readable way of locking down code to not
run it multiple times, that's kinda nice.

40
00:02:10.312 --> 00:02:15.334
记忆，标准的计算机科学实践,
Memorization, standard
computer science practice,

41
00:02:15.334 --> 00:02:20.776
如果我有一个这样的任务，这开始成为
of saying, if I have a task like,
that's starting to become

42
00:02:20.776 --> 00:02:27.645
我通过 tall 得到的太多信息就像是找到了最终的素数。
my [LAUGH] too much information via tall
is like finding the end prime number.

43
00:02:27.645 --> 00:02:32.668
任何慢投和质数都可以，假设是127,000。
Any in slow toss and prime number
that's fine suppose like 127,000.

44
00:02:32.668 --> 00:02:35.459
很明显，我的随机数生成不是很好。
Okay, clearly my random number
generation is not very good.

45
00:02:35.459 --> 00:02:41.276
我得到了编码127,000中最少的随机数之一。
I've got one of the least random
numbers in coding 127,000.

46
00:02:41.276 --> 00:02:44.347
第一，如果我想找到这个质数,
And one,
if I try to find that prime number,

47
00:02:44.347 --> 00:02:49.335
第127,000个质数，这需要一点时间。
the 127,000th prime number,
that's gonna take a bit of time.

48
00:02:49.335 --> 00:02:54.126
但在我的运行时间，在我的应用程序，如果我运行一次，它可能会再次发生。
But in my run time, in my app,
if I run it once, it may happens again.

49
00:02:54.126 --> 00:02:56.409
我不会经常关闭我的应用程序并重新启动它。
I'm not turning my app off and
starting it again very often.

50
00:02:56.409 --> 00:03:00.106
所以如果我运行一次，我可能需要再运行一次，通常是这样。
So if I run it once,
I may need to run it again, typically.

51
00:03:00.106 --> 00:03:03.004
我需要重新计算吗？
Do I wanna recalculate that?

52
00:03:03.004 --> 00:03:07.546
或者我想把第 n 个基本功能定义，放入一个背包
Or do I want to have that nth prime
function definition have a backpack into

53
00:03:07.546 --> 00:03:12.086
我有一个带键和值对的对象，每次运行它的时候
which I have an object with key and
value pairs where every time I run it with

54
00:03:12.086 --> 00:03:16.801
一个输入，当我第一次用一个输入运行它的时候，我做了艰苦的工作，弄清楚。
an input, first time I run it with
an input, I do the hard work, figure out.

55
00:03:16.801 --> 00:03:20.818
我不知道，也许是第 n 个质数，也许是第827,000或者
I don't know, maybe the nth prime number,
maybe the 827,000th or

56
00:03:20.818 --> 00:03:23.634
第一个素数，我不知道，不管它是什么。
first prime numbers I don't know,
whatever it is.

57
00:03:23.634 --> 00:03:27.222
然后，在函数的背包中的键值对中,
And then, in my key value pairs
in the backpack of the function,

58
00:03:27.222 --> 00:03:31.954
我会得到一个键127,001和一个质数的值。
I'm going to have a key 127, 001 and
a value of whatever that prime number is.

59
00:03:31.954 --> 00:03:35.008
127,000第一个素数，也许是我不知道。
The 127,000 1st prime number,
maybe it's I don't know.

60
00:03:35.008 --> 00:03:39.884
很好，也许是257,133。
That's good.
Maybe get 257,133.

61
00:03:39.884 --> 00:03:42.114
这就对了，高风险。
There you go, high risk there.

62
00:03:42.114 --> 00:03:43.776
正在安装。
It is installing that.

63
00:03:43.776 --> 00:03:46.917
下次我运行这个函数的时候,
Next time I run the function, and prime,

64
00:03:46.917 --> 00:03:51.153
要么说明我对质数一无所知。
that either shows I have no
idea about prime numbers or.

65
00:03:51.153 --> 00:03:54.138
下次我用这个输入来写函数的时候。
Next time I write the function
with that with that inputs.

66
00:03:54.138 --> 00:03:56.670
我不会再从头开始想了。
I ain't gonna figure it out
myself from scratch again.

67
00:03:56.670 --> 00:03:58.180
我去看看背包。
I'm going to go look in the backpack.

68
00:03:58.180 --> 00:04:00.205
检查一下已经完成了，那是什么？
Check it's been done with, what was that?

69
00:04:00.205 --> 00:04:06.974
只需要一个步骤，一个眼神，抓住，然后返回，非常好。
And with one step, one look up,
grab and return, super nice.

70
00:04:06.974 --> 00:04:10.683
这就是记忆的概念，赋予我们功能
This is the notion of memorization,
giving our functions

71
00:04:10.683 --> 00:04:15.086
以前输入输出组合的持久记忆。
persistent memories of their
previous input output combinations.

72
00:04:15.086 --> 00:04:17.353
这是非常有效的。
And that's super effective.

73
00:04:17.353 --> 00:04:20.903
但是还有更多的迭代器和生成器。
But there's more iterators and generators.

74
00:04:20.903 --> 00:04:23.862
不是一个愿望就是用词汇范围的圈地来达到最大的目的
Wasn't a wish use lexical scoping
enclosure to achieve the most

75
00:04:23.862 --> 00:04:24.637
现代的。
contemporary.

76
00:04:24.637 --> 00:04:25.762
这是一个非常空洞的陈述。
It's a very empty statement.

77
00:04:25.762 --> 00:04:30.310
它们是某种完整的部分，新的坚硬的部分，他看到了它。
They are something in whole parts,
new hard parts he was seeing it.

78
00:04:30.310 --> 00:04:34.963
我认为这是一种非常优雅的访问数据的方式。
I think this is a very elegant
way of accessing data.

79
00:04:34.963 --> 00:04:36.928
所以我们看到早期的完整循环是一个痛苦的屁股。
So we saw early the full
loop is a pain in the ass.

80
00:04:36.928 --> 00:04:38.766
我不在乎索引,
I don't really care about the index,

81
00:04:38.766 --> 00:04:41.990
我关心的是数组在该位置的值，即元素。
I care about the value in that
position of the array, the element.

82
00:04:41.990 --> 00:04:45.872
如果我能创建一个函数,
Well, it wouldn't be amazing if I
could creat a function that when run,

83
00:04:45.872 --> 00:04:48.305
它给出了我右边的第一个元素？
it gives me out the first
element in my right?

84
00:04:48.305 --> 00:04:52.308
再次运行它，它的输出是下一个元素，再次运行它，它的输出是
Run it again, its output is the next
element, run it again its output is

85
00:04:52.308 --> 00:04:56.606
接下来，它是如何记住之前给出的前一个元素的？
the next, how's it remembering
previously giving out previous element?

86
00:04:56.606 --> 00:05:01.269
不要担心，在背包里它存放在小柜台上，跟踪
Don't worry, in the backpack it store
in little counter that's tracking

87
00:05:01.269 --> 00:05:03.201
通过潜在的数据。
through the underlying data.

88
00:05:03.201 --> 00:05:04.908
产生这样的说法是一个更大的水平。
Generating say that's
an even larger level.

89
00:05:04.908 --> 00:05:09.062
如果我真的可以暂停一个函数的运行会怎么样？
What if I could actually appear to
pause the running of a function?

90
00:05:09.062 --> 00:05:10.851
或者它运行的是什么函数？
Or what is it running a function?

91
00:05:10.851 --> 00:05:13.629
它的内存和函数中的线性。
Well, its memory and
the liner in the function.

92
00:05:13.629 --> 00:05:15.843
就是这样，如果我回到函数,
That's it,
if I were to come back to a function,

93
00:05:15.843 --> 00:05:17.468
我只需要记忆中的东西。
all I need is what was in the memory.

94
00:05:17.468 --> 00:05:19.052
当我还是我的时候,
And while I was I on a generation,

95
00:05:19.052 --> 00:05:21.891
它说你回来继续运行一个函数，怎么做？
it says you come back to
continue running a function, how?

96
00:05:21.891 --> 00:05:24.120
因为它存储了所有的实时数据。
Because it stored all the live data.

97
00:05:24.120 --> 00:05:26.832
在背包里，意思是当你回来后再开始运行它。
In the backpack, meaning when you
come back and start running it again.

98
00:05:26.832 --> 00:05:31.026
它只是从背包里拿出一天的时间，里面有你所有的数据
It just grabs a day from the backpack and
there is all your data is you went and

99
00:05:31.026 --> 00:05:32.699
你又回来了。
you are back in the function.

100
00:05:32.699 --> 00:05:34.386
模块模式，对吗？
Module pattern, right?

101
00:05:34.386 --> 00:05:36.297
这真的很有趣。
This is really interesting.

102
00:05:36.297 --> 00:05:40.987
我们希望数据能够持续到应用程序的生命周期。
We want to have data that persists for
the lifespan of application.

103
00:05:40.987 --> 00:05:42.696
我们通常把它放在哪里？
Where can we normally puts it?

104
00:05:42.696 --> 00:05:45.906
我们不能把它放在函数调用中，因为它会被删除。
We can not put it inside a function
call because he gets deleted.

105
00:05:45.906 --> 00:05:48.288
一旦退出函数，他就将其放入 global 中。
Once you exit the function,
he put it in global.

106
00:05:48.288 --> 00:05:52.185
但是在大量的基础代码中，有100,000行代码和100个视图
But in a lot of code base with that
100,000 lines of code with 100 view

107
00:05:52.185 --> 00:05:52.726
说唱歌手。
rappers.

108
00:05:52.726 --> 00:05:57.911
你不会让全球记忆被全球标签所污染
You ain't having global memory
polluted with the global label

109
00:05:57.911 --> 00:06:02.906
结果就是你的团队得到了很大的发展，他们喜欢这个标签。
results as a lot of developing
your team who love that label.

110
00:06:02.906 --> 00:06:04.809
你知道宣布与汗的帮助有些，但
And you know declaring with
Khan's help somewhat but

111
00:06:04.809 --> 00:06:06.420
只是现在没有人能在全球范围内宣布。
just now no one else can
declare it globally.

112
00:06:06.420 --> 00:06:08.105
我觉得这样好多了。
I think that much better.

113
00:06:08.105 --> 00:06:11.536
所以我们用设计模式来保存实时数据的状态
So instead we have design patterns that
preserved state that's live data for

114
00:06:11.536 --> 00:06:14.706
在不污染全局名称空间的情况下保持应用程序的有效性,
the life of your application without
polluting the global namespace,

115
00:06:14.706 --> 00:06:15.677
多种模式。
multiple patterns.

116
00:06:15.677 --> 00:06:17.223
其中之一就是其中的许多。
One of them is many of them.

117
00:06:17.223 --> 00:06:19.807
如果他做到了同样的事情，他们在做什么？
If he's achieved the same thing,
what are they doing?

118
00:06:19.807 --> 00:06:20.656
模型专利在做什么？
What's the model patent doing?

119
00:06:20.656 --> 00:06:24.329
你知道它在做什么，就是在背包里保护国家。
You know what it's doing,
is protecting state inside backpacks.

120
00:06:24.329 --> 00:06:28.588
它说有一种方法可以维持应用生命的状态。
It saying there is a way of maintaining
state for the life of application.

121
00:06:28.588 --> 00:06:31.723
那是魔法，或者根本不是魔法。
And that's by the magic,
or not magic at all.

122
00:06:31.723 --> 00:06:35.447
这是通过数据的保护，可以接口，但
That's by having data that is protected,
can be interfaced with, but

123
00:06:35.447 --> 00:06:39.122
只有通过一个非常非常干净的界面来运行这个函数。
only through a very, very clean
interface of running that function.

124
00:06:39.122 --> 00:06:42.113
并确保你通过正确的东西，以获得访问，并
And making sure you pass in
the right stuff, to get access, and

125
00:06:42.113 --> 00:06:44.043
在背包中存储和保存数据。
store and persist data in the backpack.

126
00:06:44.043 --> 00:06:50.369
节点模块模式只是在背包中使用闭包。
And the node module pattern is all
just using closure In the backpack.

127
00:06:50.369 --> 00:06:53.331
你可以看到这个 JavaScript。
And you see this JavaScript.

128
00:06:53.331 --> 00:06:55.987
我们明天再来看看
We'll see to it tomorrow, call-backs and

129
00:06:55.987 --> 00:06:59.300
如果是这个州，所有的承诺都依赖于结束。
promises also all rely on
closure if it's this state.

130
00:06:59.300 --> 00:07:03.404
这意味着同步工作，我们将在明天看到,
What this means is in a sync job,
which we'll see tomorrow,

131
00:07:03.404 --> 00:07:08.007
你经常送出一个任务，这个任务在未来很长一段时间都不会完成。
you often send off a task that's
gonna complete long in the future.

132
00:07:08.007 --> 00:07:10.343
当这样做的时候，你要在这些数据上运行一个函数。
When it does, you're going to
run a function on that data.

133
00:07:10.343 --> 00:07:14.113
你可能想要使用最初设置这个函数时存在的数据
And you may want to use data that was
there when that function was initially set

134
00:07:14.113 --> 00:07:15.922
抛球最初是这样安排的。
up and the toss was initially set up.

135
00:07:15.922 --> 00:07:17.882
但是等等，那一天已经过去了，不是吗？
But hold on,
that day's all gone, hasn't it?

136
00:07:17.882 --> 00:07:22.790
不，这些可以使用的数据被保存在功能背包里。
Nope, that data that could ever be used
is held on into the functions backpack.

137
00:07:22.790 --> 00:07:25.869
这意味着当我们最终运行这个函数时，例如，我们去
Meaning when we end up running
the function, for example, we go and

138
00:07:25.869 --> 00:07:27.867
和推特联系带回推文,
speak to Twitter, bring back send tweets,

139
00:07:27.867 --> 00:07:30.531
触发一个函数来自动运行这些 tweets。
trigger a function to run
automatically on those tweets.

140
00:07:30.531 --> 00:07:34.939
也许它需要一些当初定义这个函数时就存在的数据
Maybe it needs some data that was there
when that function was initially defined

141
00:07:34.939 --> 00:07:38.838
和 Twitter 的对话任务已经建立，但是数据还在吗？
and the speak to Twitter task was set up,
but it that data still there?

142
00:07:38.838 --> 00:07:39.670
当然是了。
Well, of course it is.

143
00:07:39.670 --> 00:07:41.980
别担心，因为它就储存在背包里。
Don't worry,
cuz it's stored in the backpack.
