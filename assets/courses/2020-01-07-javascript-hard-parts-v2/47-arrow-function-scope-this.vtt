WEBVTT

1
00:00:00.003 --> 00:00:03.911
威尔 · 森特斯: 我认为这是美好时刻的范围
&gt;&gt; Will Sentance: I think this is
the scope of nice moment to see

2
00:00:03.911 --> 00:00:09.500
现在越来越标准的做法。
the increasingly more standard
way of doing this nowadays.

3
00:00:09.500 --> 00:00:15.400
使用这个特性的新方法来定义或声明
That uses this feature of a new
way of defining or declaring or

4
00:00:15.400 --> 00:00:20.850
在 JavaScript 中保存函数，我们昨天看到的。
saving functions in JavaScript
that we saw yesterday.

5
00:00:20.850 --> 00:00:23.629
这就是我们的箭头函数风格。
Which was our arrow function style.

6
00:00:23.629 --> 00:00:26.975
因为我们的箭头函数样式，声明或
Cuz our arrow function style,
of declaring or

7
00:00:26.975 --> 00:00:31.789
保存功能，将句子: 自动,
saving functions,
&gt;&gt; Will Sentance: Automatically,

8
00:00:31.789 --> 00:00:36.030
我现在要告诉你们，这是词汇学上的范围。
I'm gonna tell you right now,
is lexically scoped.

9
00:00:36.030 --> 00:00:40.750
这意味着我们保存函数的地方，或者，让我明确一下，不，对不起。
That means where we save the function or,
let me set that clear on that, no, sorry.

10
00:00:40.750 --> 00:00:44.490
这个作业的词汇范围。
Is, it's this assignment
is lexically scoped.

11
00:00:44.490 --> 00:00:48.130
也就是说，当我们保存函数时，当我们执行它时,
That is to say, when we save the function,
when we execute it,

12
00:00:48.130 --> 00:00:53.009
它的设置取决于函数保存的位置。
what this is set to is determined
by where the function was saved.

13
00:00:53.009 --> 00:00:56.729
所以如果它保存在用户1的位置，当我们最终运行它时,
So if it was saved where this is user 1,
when we end up running it,

14
00:00:56.729 --> 00:01:01.240
内部的这个值就是函数保存的位置，也就是 User1。
this inside will be this value from where
the function was saved, which is User1.

15
00:01:01.240 --> 00:01:02.719
让我们看看这个例子。
So let's just see that example here.

16
00:01:03.719 --> 00:01:06.969
我们现在已经定义了一个箭头函数，让我们做一个小小的改变。
We've defined in now with an arrow
function, let's make this slight change.

17
00:01:06.969 --> 00:01:10.700
让我们一起快速执行它，再一次，确保我们已经得到它。
Let's quickly execute it together,
one more time, make sure we've got it.

18
00:01:10.700 --> 00:01:14.579
让我们再快速地执行一次，所以我们在这里执行。
Let's quickly execute it one more time,
so we're executing here.

19
00:01:14.579 --> 00:01:15.799
这些都是小小的错综复杂，但是
These are little intricacies here, but

20
00:01:15.799 --> 00:01:18.289
我想给大家带来一些有趣的附加信息。
little fun bonus bits I wanted
to include for you all.

21
00:01:18.289 --> 00:01:21.530
所以我们正在运行 user1.increment。
So we're running user1.increment.

22
00:01:21.530 --> 00:01:26.170
它通过 user1从函数存储中运行增量方法。
It runs the increment method
from function store via user1.

23
00:01:26.170 --> 00:01:28.210
我说过你很快就会过去的。
I said you go through that quickly.

24
00:01:28.210 --> 00:01:30.590
1.increment，user1 is in？
Dan, user1.increment, user1 is in?

25
00:01:30.590 --> 00:01:31.680
讲者2: 全局存储器。
&gt;&gt; Speaker 2: Global memory.

26
00:01:32.710 --> 00:01:36.289
句子: 全局内存，我们寻找增量的方法，它在那里吗？
&gt;&gt; Will Sentance: Global memory, we look
for the increment method, is it there?

27
00:01:36.289 --> 00:01:38.650
演讲者2: 没有，所以我们进入原型，然后
&gt;&gt; Speaker 2: Nope, so
we go to the proto, and

28
00:01:38.650 --> 00:01:41.460
让我找到它在用户函数应该存储对象。
let me find it in the user
function should store object.

29
00:01:41.460 --> 00:01:44.700
威尔 · 森坦斯: 太棒了，我们拿到了它的代码，然后我们想执行它。
&gt;&gt; Will Sentance: Fantastic, we grab
its code, and we thought executing it.

30
00:01:44.700 --> 00:01:47.378
第一件事和本地记忆丹是什么？
And the first thing and
local memory Dan is?

31
00:01:47.378 --> 00:01:51.676
演讲者2: 常数在1，这。
&gt;&gt; Speaker 2: Constant at 1, this.

32
00:01:51.676 --> 00:01:53.980
是的，作为一个参数，没有问题，是什么？
&gt;&gt; Will Sentance: Yeah,
as a parameter, no problem, which is?

33
00:01:53.980 --> 00:01:54.837
讲者2: 用户1 威尔 · 森塔斯: 这是什么
&gt;&gt; Speaker 2: User1.
&gt;&gt; Will Sentance: Which is what

34
00:01:54.837 --> 00:01:56.885
我们希望如此，因为我们正在运行这个函数
we hope because that's what
we're running this function

35
00:01:56.885 --> 00:01:59.159
我们希望这会影响到。
owns that we hope it's
going to affect this.

36
00:01:59.159 --> 00:02:01.609
我们总是希望拥有自己的功能和数据。
We always wanna have our functionality and
our data.

37
00:02:01.609 --> 00:02:04.319
能够直接在数据上使用该功能
Able to use the functionality
directly on the data right there and

38
00:02:04.319 --> 00:02:06.329
这就是我们的目的。
then that's the kind of
the whole goal of this.

39
00:02:06.329 --> 00:02:08.240
所以不要忘记，当我们进入这些错综复杂的
So don't forget that as we go
into these intricacies and

40
00:02:08.240 --> 00:02:10.240
别忘了总体目标。
don't forget that overall goal.

41
00:02:10.240 --> 00:02:11.780
这是一个多么美妙的好看。
This is what a fantastic looking good.

42
00:02:13.379 --> 00:02:14.668
我们来声明这个函数 Dan。
Let's declare that function Dan.

43
00:02:14.668 --> 00:02:18.110
讲者2:1及。
&gt;&gt; Speaker 2: At 1 and.

44
00:02:18.110 --> 00:02:20.710
威尔 · 句子: 在箭头函数星中，它没有什么不同。
&gt;&gt; Will Sentance: In the arrow
function star, but it's no different.

45
00:02:20.710 --> 00:02:21.399
就是这个。
There it is.

46
00:02:22.900 --> 00:02:24.740
然后我们马上用它做什么，丹？
And we immediately do what with it, Dan?

47
00:02:24.740 --> 00:02:26.045
演讲者2: 我们称之为执行。
&gt;&gt; Speaker 2: We call it, e execute it.

48
00:02:26.045 --> 00:02:28.420
威尔 · 森塔斯: 我们称之为执行。
&gt;&gt; Will Sentance: We call it,
e execute it.

49
00:02:28.420 --> 00:02:30.180
全新的什么，丹？
Brand new what, Dan?

50
00:02:30.180 --> 00:02:31.094
演讲者2: 有点像执行。
&gt;&gt; Speaker 2: Execution kinda.

51
00:02:31.094 --> 00:02:36.379
威尔 · 森塔斯: 执行是美丽的，在它的本地记忆里。
&gt;&gt; Will Sentance: Execution beautiful,
and in it's local memory.

52
00:02:36.379 --> 00:02:38.439
因为它是一个箭头函数。
Because it's an arrow function.

53
00:02:38.439 --> 00:02:43.629
我不知道，我认为我们需要它，它在我们的职能。
I don't know, I though we necessitated it,
it's in our function.

54
00:02:43.629 --> 00:02:51.420
它是局部内存中的这个分配，它是全局的吗,
It's this assignment inside the local
memory, will it be global because note,

55
00:02:51.420 --> 00:02:56.420
我们的一个简单规则是，任何运行在右手边的函数
our one simple rule is any function
that's being run to the right hand side

56
00:02:56.420 --> 00:02:59.329
不管左手边是什么，那就是列表赋值。
of the dot whatever the left hand side
that's going to be the list assignment.

57
00:02:59.329 --> 00:03:02.889
但是当这里没有点的时候，它将全局默认为窗口。
But when there's no dot here,
it defaults the global to the window.

58
00:03:04.430 --> 00:03:07.629
除非该函数被定义为箭头函数,
Unless that function was
defined as an arrow function,

59
00:03:07.629 --> 00:03:11.569
在这种情况下，丹，我们的这个任务将是什么？
in which case Dan our this
assignment will be what?

60
00:03:11.569 --> 00:03:12.449
演讲者2: 用户1 still。
&gt;&gt; Speaker 2: User1 still.

61
00:03:12.449 --> 00:03:17.193
Will Sentance: 用户一，围绕定义的这个任务到底是什么
&gt;&gt; Will Sentance: User one, exactly what
was this assignment around the definition

62
00:03:17.193 --> 00:03:19.489
其中的1在词典上是作用域。
of that 1 is lexically scoped.

63
00:03:19.489 --> 00:03:21.770
它静止的范围，这个任务。
It staticly the scope, this assignment.

64
00:03:21.770 --> 00:03:24.719
这是一个静态的或词汇上的这个作业，也就是说它来自
It's a statically or lexically this
assignment, that is to say it's from

65
00:03:24.719 --> 00:03:30.840
定义的那一刻，我们把它设置为 User1。
the moment of definition that
we set our this to User1.

66
00:03:30.840 --> 00:03:36.180
因此，我们的代码行 this.score 加上,
Therefore, our line of
code this.score plus plus,

67
00:03:36.180 --> 00:03:38.206
会怎么评估 Todd 呢？
is going to evaluate to what Todd, now?

68
00:03:38.206 --> 00:03:41.425
讲者2: User1.score + + 。
&gt;&gt; Speaker 2: User1.score++.

69
00:03:41.425 --> 00:03:46.185
威尔 · 森坦斯: 太棒了，user1.score + + 。
&gt;&gt; Will Sentance: Fantastic,
user1.score++.

70
00:03:46.185 --> 00:03:48.069
你得再上几层楼。
You gotta go a few levels out.

71
00:03:48.069 --> 00:03:52.659
1,2,3，这是我们的分数财产。
1, 2, 3, there's our score property.

72
00:03:52.659 --> 00:03:56.992
它会增加到4，让我们把它增加到,
It would increment to four but,
let's increment it to,

73
00:03:58.759 --> 00:04:01.989
威尔 · 森塔斯: 5，神奇的人们。
&gt;&gt; Will Sentance: 5, fantastic people.

74
00:04:01.989 --> 00:04:05.466
现在我认为这是一个很好的方法来解决这个问题
This now I think is a nice way
of solving this problem for

75
00:04:05.466 --> 00:04:07.459
写下这些干净的代码。
writing this clean code here.

76
00:04:07.459 --> 00:04:13.610
好了，各位，现在我们从拇指开始
All right people, let's have to
start with thumbs here at this point

77
00:04:13.610 --> 00:04:17.439
有没有人想加点大拇指什么的尽管说吧 Peter。
on any of those bonus pieces anyone want
to add any thumbs, yeah, go ahead Peter.

78
00:04:17.439 --> 00:04:20.389
说话人2: 是否声明增量
&gt;&gt; Speaker 2: Would
declaring the increment

79
00:04:20.389 --> 00:04:24.850
作为一个箭头功能，以及帮助我们呢？
property as an arrow
function as well help us?

80
00:04:24.850 --> 00:04:26.050
威尔 · 森塔斯: 但是会吗？
&gt;&gt; Will Sentance: Would it though?

81
00:04:26.050 --> 00:04:30.019
因为如果我们这样做，当我们运行增量时。
Because if we did so,
when we ran that increment.

82
00:04:30.019 --> 00:04:34.370
所以彼得的问题是，如果我们把增量当作一个箭头函数呢？
So Peter's question there is what if we
say an increment as an arrow function?

83
00:04:35.899 --> 00:04:41.165
如果我们运行它，这个分配是否取决于它在哪里运行
If we ran it, would it's this assignment
be determined by where it's being run

84
00:04:41.165 --> 00:04:46.365
点的右边还是存储位置，在全局数据库里？
to the right hand side of the dot or by
where it was stored, which was in global?

85
00:04:46.365 --> 00:04:49.737
因此，整个系统就会崩溃。
By where it was stored, and therefore
the whole thing would fall apart.

86
00:04:49.737 --> 00:04:51.586
现在，这将不是 User1。
And now this will not be User1.

87
00:04:51.586 --> 00:04:54.786
所以我们不想使用包含的箭头函数
So we don't want to use arrow
functions for our include for

88
00:04:54.786 --> 00:04:56.168
我们对物体的方法。
our methods on objects.

89
00:04:56.168 --> 00:04:59.668
但是对于它们内部的函数，我们要指出这一点
But for the functions inside of them
that we want to have point there this to

90
00:04:59.668 --> 00:05:02.047
他们被定义的方法，完美无缺。
the method in which they were defined,
perfect.
