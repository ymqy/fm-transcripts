WEBVTT

1
00:00:00.210 --> 00:00:02.250
那么应该重新命名什么呢？
&gt;&gt; Will Sentance: Then
should be renamed what?

2
00:00:02.250 --> 00:00:05.929
它应该被重命名为 this，store 函数以便以后运行。
It should be renamed this,
store function to run later.

3
00:00:07.440 --> 00:00:08.614
没错。
Yeah, exactly.

4
00:00:08.614 --> 00:00:12.320
将来的 data.store 我以后自动运行我的时候
Future data.store me to run
me later automatically when

5
00:00:12.320 --> 00:00:15.730
从前面的获取调用中产生的后台任务完成并
the background task that came out of
the fetch call previously completes and

6
00:00:15.730 --> 00:00:16.899
数值可能会更新。
the value probably gets updated.

7
00:00:16.899 --> 00:00:20.289
虽然不够吸引人，但确实很准确。
Not catchy but it is accurate.

8
00:00:21.660 --> 00:00:24.870
所以，我还要再加一个好处。
So, I will add one more benefit though.

9
00:00:24.870 --> 00:00:29.809
所以，人们认为更干净，可读的风格，我会说，像 pseudo synchronous,
So, people think kind of cleaner, readable
style, I'll say, like pseudo synchronous,

10
00:00:29.809 --> 00:00:32.829
看起来你运行得很好，但实际上不是。
it sort of looks like you're running
it right then but you really are not.

11
00:00:32.829 --> 00:00:36.950
你传入的函数会像以前一样自动运行，不是你传入的，而是
You're passing in a function that's gonna
be auto run as before, not by you, but

12
00:00:36.950 --> 00:00:37.840
作者: JavaScript。
by JavaScript.

13
00:00:37.840 --> 00:00:41.850
它接受的是一个你没有放进去的输入，是 java 放进去的。
And it's taking an input that you didn't
put in there, java who put in there.

14
00:00:41.850 --> 00:00:44.700
从背景来看，那个高音符号是自动的
From the background work,
that high string that's gonna be auto

15
00:00:44.700 --> 00:00:47.390
自动运行时插入显示功能。
inserted into display
function when it's auto run.

16
00:00:47.390 --> 00:00:50.469
我很喜欢。顺便说一下，一旦你看到 JavaScript
I love it.
By the way, once you see that JavaScript

17
00:00:50.469 --> 00:00:54.340
或者一旦你看到 JavaScript 正在使用这个函数代码来显示，并且
or once one sees that JavaScript is
taking that function code of display, and

18
00:00:54.340 --> 00:00:57.289
它会自动为你输入指纹。
it's running it for you by putting
print on it for you automatically.

19
00:00:57.289 --> 00:00:58.789
它将输入插入到
And it's inserting the input for

20
00:00:58.789 --> 00:01:03.000
你自然而然地，在这个意义上，这是非常慷慨的语言。
you automatically,
it's very generous language in that sense.

21
00:01:04.530 --> 00:01:09.340
这种设计有一个很大的好处，那就是错误处理过程。
There is one big benefit to this design,
and it's that error handling process.

22
00:01:09.340 --> 00:01:11.420
所以这真的很棒。
So this is really nice.

23
00:01:11.420 --> 00:01:16.310
结果是人们，在这个承诺对象上，实际上还有另一个数组
It turns out people, there's actually
another array on this promise object

24
00:01:16.310 --> 00:01:22.260
在幕后，另一个隐藏属性，它被称为拒绝。
behind the scenes, another hidden
property and it's called On Rejection.

25
00:01:23.510 --> 00:01:26.019
它也是一个数组，我们可以把函数放进去。
And it's also an array into
which we can put functions.

26
00:01:27.629 --> 00:01:31.329
当你与外部世界，尤其是网络上的东西互动时,
When you interact with the outside
world especially network stuff,

27
00:01:31.329 --> 00:01:32.310
你总是会犯错。
you get errors all the time.

28
00:01:33.340 --> 00:01:37.170
你不想运行你的显示功能，所以 Twitter 上的用户得到了一个可爱的
You don't wanna run your display function
so the user on Twitter gets a lovely

29
00:01:37.170 --> 00:01:39.170
广播了错误的全部细节。
broadcast of the full
details of the error.

30
00:01:40.299 --> 00:01:44.229
理想情况下，我们应该有一个单独的函数来处理这个错误。
Ideally we would have a separate function
is gonna run that handles that error.

31
00:01:44.229 --> 00:01:46.509
也许它以某种方式为你记录了它，但是
Maybe it logs it for you in some way, but

32
00:01:46.509 --> 00:01:48.390
可能只是给用户一个更好的体验。
probably just gives the user
a better experience.

33
00:01:48.390 --> 00:01:51.673
它正在做类似的事情，也许，不管它是什么。
It's doing something similar,
maybe, whatever it might be.

34
00:01:51.673 --> 00:01:55.379
现在，我们如何处理这个问题呢？
Now, how can we handle that?

35
00:01:55.379 --> 00:01:59.359
好吧，你知道吗，我保证我会给我们这个惊人的功能。
Well, you know what, the promise I'll
just give us this amazing feature.

36
00:01:59.359 --> 00:02:03.355
这意味着如果我们得到的是一个错误，而不是我们想要的实际响应对象,
That means if we get an error back not
the actual response object that we want,

37
00:02:03.355 --> 00:02:06.250
任何错误，它都不会运行显示功能。
any error,
it's not gonna run that display function.

38
00:02:06.250 --> 00:02:09.590
它甚至不会自动触发任何功能和未完成。
It's not even gonna auto trigger any
of the functions and unfulfilled.

39
00:02:09.590 --> 00:02:13.090
它会触发任何你存储在拒绝中的功能。
It's going to trigger any functions
that you stored in on rejection.

40
00:02:14.360 --> 00:02:15.969
我们如何在那里得到函数？
How do we get functions in there?

41
00:02:15.969 --> 00:02:23.264
有两种方法一种是写未来数据有人知道吗？
Well, there's two ways, one would
be to write futureData.anyone know?

42
00:02:23.264 --> 00:02:23.789
演讲者2: . 接住。
&gt;&gt; Speaker 2: .catch.

43
00:02:23.789 --> 00:02:26.909
威尔 · 森塔斯:。 接着，完全正确，凯拉说得对。 抓住。
&gt;&gt; Will Sentance: .catch, spot on,
exactly, Kayla's right, .catch.

44
00:02:26.909 --> 00:02:31.229
我们在这里传递的任何函数，都会进入你们的拒绝数组。
And any function we pass in there
is going in your rejection array.

45
00:02:31.229 --> 00:02:35.469
另一种方法是作为第二个参数传递给 then,
The other way is to pass to
then as the second argument,

46
00:02:37.520 --> 00:02:41.259
无论你想要什么功能，它都会在这里自动运行。
whatever function you want that's
gonna go in here to auto run on error.

47
00:02:41.259 --> 00:02:44.050
第一个参数，将该函数设置为未实现。
First argument,
stick that function in unfulfilled.

48
00:02:44.050 --> 00:02:46.990
然后我们接受第二个参数，第二个输入和
Then we'll take the second argument,
the second input and

49
00:02:46.990 --> 00:02:49.150
把这个功能植入你的排斥系统。
stick that function in your rejected.

50
00:02:49.150 --> 00:02:50.310
真是太好了,
That's really nice,

51
00:02:50.310 --> 00:02:54.280
毫无疑问，这是一个非常好的错误处理方法。
that's a really really nice error
handling approach without a doubt.

52
00:02:55.409 --> 00:02:59.949
好了，伙计们，我们有了，我们现在有了规则
All right folks, so there we have it,
we now have rules for

53
00:02:59.949 --> 00:03:05.039
我们异步延迟代码的执行承诺延迟函数。
the execution of our asynchronously delay
code hold promise deferred functions.

54
00:03:05.039 --> 00:03:07.650
这就是丹所说的承诺延迟作用,
This is what Dan was saying
promise deferred functions,

55
00:03:07.650 --> 00:03:10.500
那些承诺延迟他们逃跑的人
ones that were attached to
a promise to delay them running

56
00:03:10.500 --> 00:03:12.189
直到背景里发生了什么事。
until something happened
in the background.

57
00:03:12.189 --> 00:03:16.750
将它们存储在微任务队列和传递的回调函数中
Store them in the micro task queue and
callback functions ones that were passed

58
00:03:16.750 --> 00:03:20.759
类似计时器这样的外观函数,
in to one of these facade
functions like timer, sorry,

59
00:03:20.759 --> 00:03:23.680
设置超时，让他们进入回调队列。
set timeout,
have them go in the callback queue.

60
00:03:25.379 --> 00:03:30.280
当 web 浏览器功能，也就是 API 完成后,
When the web browser feature,
otherwise known as API finishes,

61
00:03:30.280 --> 00:03:34.699
将函数添加到调用堆栈中，换句话说，运行它。
add the function to the call stack,
in other words, run it.

62
00:03:35.969 --> 00:03:40.069
当调用堆栈为空且所有全局代码运行完毕时,
When call stack is empty and
all global code is finished running,

63
00:03:41.490 --> 00:03:44.469
让事件循环为我们检查这个条件。
have the event loop check
this condition for us.

64
00:03:44.469 --> 00:03:46.409
在我们知道代码是我会运行下一步,
Before we know it code
is I would run next,

65
00:03:46.409 --> 00:03:52.000
将微任务队列中的函数优先于回调队列中的函数。
prioritize functions in the micro
task queue over the callback queue.

66
00:03:53.659 --> 00:03:58.990
承诺网页浏览器的特性，回调和微任务队列以及
Promises web browser features,
the callback and micro task queues and

67
00:03:58.990 --> 00:04:03.349
事件循环使我们能够构建非阻塞应用程序。
the event loop enable us to
build non blocking applications.

68
00:04:03.349 --> 00:04:07.169
我们不必在这个 JavaScript 线程中等待。
We don't have to wait in this
single JavaScript thread.

69
00:04:07.169 --> 00:04:09.169
我们必须在这里等待我们的数据回来。
We'd have to wait here for
our data to come back.

70
00:04:09.169 --> 00:04:11.689
没有等待这条线，取我们不坐在这条线等待
No waiting on this line, fetch we're
not sitting on this line waiting for

71
00:04:11.689 --> 00:04:12.849
数据回来。
the data to come back.

72
00:04:12.849 --> 00:04:13.360
不不不。
No, no, no, no.

73
00:04:13.360 --> 00:04:14.764
我的意思是，不是我们做的普通代码,
I mean, no in regular code we do,

74
00:04:14.764 --> 00:04:18.240
在函数代码中，你要一直站在那条线上直到你完成它。
in function code, you're staying
on that line til you finished it.

75
00:04:18.240 --> 00:04:19.509
但它不是一个常规的函数调用。
But it's not a regular function call.

76
00:04:19.509 --> 00:04:21.689
这是一个用于设置后台工作的 facade 函数。
It's a facade function for
setting up background work.

77
00:04:23.209 --> 00:04:24.139
不管要花多长时间,
However long it takes,

78
00:04:24.139 --> 00:04:28.189
我们不能预测我们的浏览器功能什么时候会在后台完成。
we can't predict when our Browser features
work will finish in the background.

79
00:04:28.189 --> 00:04:29.649
我们不知道它什么时候结束。
We can't know exactly
when it's gonna finish.

80
00:04:29.649 --> 00:04:34.319
所以我们不能让一行代码运行后台数据
So we can't kinda have the line of code
that's gonna use that background data run

81
00:04:34.319 --> 00:04:35.110
现在。
right now.

82
00:04:35.110 --> 00:04:36.509
因为我们告诉它什么时候该跑,
Because we tell it when to run,

83
00:04:36.509 --> 00:04:40.209
我们必须依靠 JavaScript 来知道后台工作何时完成,
we got to rely on JavaScript that knows
when the background work is done,

84
00:04:40.209 --> 00:04:43.939
自动触发函数在那个时刻运行。
to automatically trigger
the function to run on that moment.

85
00:04:45.360 --> 00:04:50.550
这就是为什么我们人们可以建立这些非阻塞的动态,
This is what allows us people to
build these non blocking dynamic,

86
00:04:50.550 --> 00:04:52.209
快速应用。
fast applications.

87
00:04:52.209 --> 00:04:55.860
我们可以在后台设置大量的东西
We can handle setting up a ton
of stuff in the background

88
00:04:55.860 --> 00:05:00.850
当我们在前台比赛，运行我们的代码，响应,
while we race on in the foreground,
running our code, being responsive,

89
00:05:00.850 --> 00:05:05.269
响应用户交互，构建这些动态应用程序。
responsive to users interactions,
building these dynamic applications.

90
00:05:05.269 --> 00:05:08.339
这就是让 JavaScript 变得非常非常特别，非常好用的原因。
This is what really makes JavaScript
very very special and very usable.
