WEBVTT

1
00:00:00.330 --> 00:00:01.266
威尔 · 森特斯: 丹，说吧。
&gt;&gt; Will Sentance: Dan, go ahead.

2
00:00:01.266 --> 00:00:06.133
阿丹: 有两种，第一种是如果你有第二次处决的话
&gt;&gt; Dan: Kind of two, the first one
is if you had a secondary execution

3
00:00:06.133 --> 00:00:11.298
上下文包装，能给我一个第二层的背包吗？
context wrapping, can you have
a back pack of the second level?

4
00:00:11.298 --> 00:00:11.836
威尔 · 森特斯: 是的，绝对是的。
&gt;&gt; Will Sentance: Yeah, absolutely yes.

5
00:00:11.836 --> 00:00:14.423
所以，我会说，去实验，但它是一个链。
So, I would say that,
go experiment, but it is a chain.

6
00:00:14.423 --> 00:00:18.803
这就是所谓的，我们马上就会知道它的名字，但是
This is what's called, well, we're gonna
learn the name of this in a moment, but

7
00:00:18.803 --> 00:00:22.259
是的，当然，你可以去玩。
yeah, it is, absolutely,
you can go play with that, for sure.

8
00:00:22.259 --> 00:00:25.158
但是，是的，这是一个链条，是的，第二个问题？
But yes, it is a chain,
yeah, second question?

9
00:00:25.158 --> 00:00:30.797
你能有一个回调来访问数据吗？
&gt;&gt; Dan: Can you have a callback
that accesses the data?

10
00:00:30.797 --> 00:00:33.945
威尔 · 森坦斯: 哇，那么你是说，我们可以在这里传递一个函数,
&gt;&gt; Will Sentance: Wow, so you're saying,
could we pass into here a function that,

11
00:00:33.945 --> 00:00:35.331
- 你是不是...-是的,
is that what you're-
&gt;&gt; Dan: Yeah,

12
00:00:35.331 --> 00:00:37.014
然后访问这些变量？
that would then access the variables?

13
00:00:37.014 --> 00:00:39.712
威尔 · 森特斯: 是的，这就是所谓的功能装饰。
&gt;&gt; Will Sentance: Yeah, so
this is what's called function decoration.

14
00:00:39.712 --> 00:00:42.389
很多技巧都包含在，抱歉,
Many of the techniques enclosed in a,
sorry,

15
00:00:42.389 --> 00:00:46.509
在函数式编程中使用这个原则,
in functional programming use this
principle, where you would pass,

16
00:00:46.509 --> 00:00:51.402
我想做一个半成品的版本。
one knows a to detail, I want to do like a
half, sort of half-baked version of this.

17
00:00:51.402 --> 00:00:55.662
去看函数式编程霍尔部分，我们这样做绝对完整,
Go watch the functional programming Hall
parts where we do this in absolute full,

18
00:00:55.662 --> 00:00:57.468
但我们可以在这里加个函数。
but we can take a function in here.

19
00:00:57.468 --> 00:01:00.576
我们可以在这里定义一个全新的功能，所以她得到了一个背包。
We can define a brand new function
in here, so she gets a backpack.

20
00:01:00.576 --> 00:01:05.170
然后，该函数将可以访问参数函数
That function will then have
access to the argument function

21
00:01:05.170 --> 00:01:09.420
传递到外层，当我们回来时，在它的背包里。
passed into outer,
when we return out in its backpack.

22
00:01:09.420 --> 00:01:13.013
我的意思是，我们可以在背包里存储代码，然后运行这个功能。
I mean, we can store code in
the backpack and run the function.

23
00:01:13.013 --> 00:01:16.983
这意味着返回输出函数将是，我们可以使它的行为变得漂亮
Meaning that that returned-out function
will be, we could make it behave pretty

24
00:01:16.983 --> 00:01:20.388
类似于传入的函数，但是有一些变化。
similarly to the function that got
passed in, but with some changes.

25
00:01:20.388 --> 00:01:23.188
它的表现很相似，因为它在幕后,
It's behaving similar,
because it's in the, behind the scenes,

26
00:01:23.188 --> 00:01:25.228
用它的背包来运行这个功能。
gonna be running the function
from its backpack.

27
00:01:25.228 --> 00:01:26.960
这是个半生不熟的答案。
That's a half-baked answer.

28
00:01:26.960 --> 00:01:31.194
但是绝对的，你也可以在背包里存储代码。
But absolutely, you can literally
store code in the backpack as well.

29
00:01:31.194 --> 00:01:34.454
这就是为什么可以携带、部分应用和
And that's what enables carrying,
partial application and

30
00:01:34.454 --> 00:01:36.341
功能装饰技术。
function decoration techniques.

31
00:01:36.341 --> 00:01:40.664
他们所有人都坐在这上面，但是坐在我们身上传递一个函数，这个函数的结尾是
All of them sit on this, but sit on us
passing a function in which ends up

32
00:01:40.664 --> 00:01:43.979
在全新的退货功能的背包里。
in the brand new returned
out function's backpack.

33
00:01:43.979 --> 00:01:45.924
这就是装饰的过程,
And that is the decoration process,

34
00:01:45.924 --> 00:01:48.628
不同于其他语言的处理装饰。
different to other languages
handle decoration.

35
00:01:48.628 --> 00:01:51.182
装饰就是你编辑一个函数或者看起来,
Decoration's where you edit a function or
appear to,

36
00:01:51.182 --> 00:01:54.792
在现实中，你所做的，全新的功能，使用装饰,
in reality what you're doing, brand
new function that uses the decorated,

37
00:01:54.792 --> 00:01:56.694
他背包里的变化功能。
the change function from his backpack.

38
00:01:56.694 --> 00:02:01.269
这是什么东西，不要担心，如果你要去，这到底是什么意思？
That's something that, don't worry if
you're going what the hell does that mean?

39
00:02:01.269 --> 00:02:04.623
但是，如果你想了解更多关于它去看函数式编程热点。
But if you want to learn more about it go
watch the functional programming hotpots.

40
00:02:04.623 --> 00:02:07.391
可能是唯一一个。
Could be the, be the only person.

41
00:02:07.391 --> 00:02:08.990
我相信它会非常受欢迎。
I'm sure it can be very popular.

42
00:02:08.990 --> 00:02:10.108
肯定会爆炸的。
I'm sure it's gonna blow up.

43
00:02:10.108 --> 00:02:10.615
好极了。
Excellent.

44
00:02:10.615 --> 00:02:11.372
好的，谢谢你，丹。
All right, thank you, Dan.

45
00:02:11.372 --> 00:02:13.301
问得好 Peter。
Great questions, Peter.

46
00:02:13.301 --> 00:02:16.665
彼得: 非常类似，您称其中的计数器数据为 private，并且
&gt;&gt; Peter: Very similarly, you called
the counter data private within there, and

47
00:02:16.665 --> 00:02:20.489
然后你可以在那里存储一个函数，这将是一个私有函数。
then you could store a function there, and
then that would be a private function.

48
00:02:20.489 --> 00:02:22.193
威尔 · 森塔斯: 是的，二等兵这个词。
&gt;&gt; Will Sentance: Yes, the term private.

49
00:02:22.193 --> 00:02:26.710
我必须小心，因为所有这些术语都是一般术语
I gotta be careful on that because all
these terms are general terms that have

50
00:02:26.710 --> 00:02:31.027
不同语言中有很多相互矛盾的定义，所以这是私人的吗？
many competing definitions in
different languages, so is it private?

51
00:02:31.027 --> 00:02:35.912
好吧，只要我们能用它做某些事情，那么可能就不会。
Well, as long as we can do certain
things with it then probably not.

52
00:02:35.912 --> 00:02:39.389
是不是我们不能突然随机覆盖
Is it private in the sense that we're not
able to suddenly randomly override to

53
00:02:39.389 --> 00:02:40.401
全球记忆？
the global memory,?

54
00:02:40.401 --> 00:02:41.143
当然。
Sure.

55
00:02:41.143 --> 00:02:42.781
所以这些术语都要小心,
So just be careful with
any of these terms,

56
00:02:42.781 --> 00:02:45.247
它们在不同的语言中都有点难以捉摸。
they're all a little bit elusive
across different languages.

57
00:02:45.247 --> 00:02:47.028
是的，请讲。
Yeah, go ahead [INAUDIBLE].

58
00:02:47.028 --> 00:02:50.598
发言人4: 网上有一个关于范围和
&gt;&gt; Speaker 4: There's a question
from online about scope and

59
00:02:50.598 --> 00:02:54.088
基本上，范围在哪里发挥作用？
is basically where does
scope come into play?

60
00:02:54.088 --> 00:02:56.625
威尔 · 森坦斯: 你马上就能看到了，绝对的，是的。
&gt;&gt; Will Sentance: You'll see it
in one second, absolutely, yeah.

61
00:02:56.625 --> 00:02:58.165
是的，说吧，杰森。
Yeah, go ahead, Jason.

62
00:02:58.165 --> 00:03:01.973
杰森: 错误传播，我们正在嵌套一些调用,
&gt;&gt; Jason: Error propagation,
we're nesting a bunch of calls,

63
00:03:01.973 --> 00:03:04.716
我们正在进行一系列操作。
we're nesting a bunch of operations.

64
00:03:04.716 --> 00:03:07.639
我仍然可以在这些变量上做一个访问错误,
I can still make an access
error on those variables,

65
00:03:07.639 --> 00:03:10.838
我仍然可以请求一个不存在的数组中的 MSE。
I can still ask for
an MSE in an array that doesn't exist.

66
00:03:10.838 --> 00:03:16.466
但是现在我们已经有了一系列的引用来传播我们的错误。
But now we've got a chain of references
to propagate our error through.

67
00:03:16.466 --> 00:03:21.121
威尔 · 森坦斯: 是的，我的意思是这是一个有趣的挑战
&gt;&gt; Will Sentance: Yeah, I mean this is
this is one of the interesting challenges

68
00:03:21.121 --> 00:03:25.329
当我们都使用传统的控制台日志时,
is that when we all using
traditional console logging,

69
00:03:25.329 --> 00:03:28.030
我发现控制台日志我的新功能。
I find console log my new function.

70
00:03:28.030 --> 00:03:33.525
它附加了一堆状态数据，这些数据在我的控制台上看不到。
It's got a bunch of state data attached to
it that I don't get to see on my console.

71
00:03:33.525 --> 00:03:35.899
这很难调试。
That's gonna be pretty hard to debug.

72
00:03:35.899 --> 00:03:37.781
当然，除非我们知道发生了什么。
Unless we know what's happening,
of course.

73
00:03:37.781 --> 00:03:42.780
现在，亲切的铬开发工具给我们的能力
Now, kindly the chrome dev
tools do give us the ability

74
00:03:42.780 --> 00:03:46.377
暂停我们的行刑。
to pause our execution at this moment.

75
00:03:46.377 --> 00:03:50.456
如果我们这样做，我们就会看到右手边背包里的东西。
And if we do, we'll see the contents
of the backpack on the right-hand side.

76
00:03:50.456 --> 00:03:53.019
他们给它起了个正式的名字，我马上就告诉你们。
They give it the official name,
which I'll tell you in a second.

77
00:03:53.019 --> 00:03:56.609
有一件事我做了，没有人提出来，但我想提出来。
There's one thing I did, nobody raised,
but I do want to bring up.

78
00:03:56.609 --> 00:03:57.579
说吧，马克。
Yeah, go ahead, Mark.

79
00:03:57.579 --> 00:04:01.653
Mark: If in outer-Mark: 你创建了另一个变量-
&gt;&gt; Mark: If in outer-
&gt;&gt; Mark: You created another variable-

80
00:04:01.653 --> 00:04:02.818
威尔 · 森塔斯: 问题是,
&gt;&gt; Will Sentance: There's the question,

81
00:04:02.818 --> 00:04:03.653
说吧，马克。
go ahead, Mark.

82
00:04:03.653 --> 00:04:05.437
如果 incrementCounter 没有调用。
&gt;&gt; Mark: If incrementCounter doesn't call.

83
00:04:05.437 --> 00:04:06.627
不引用，不引用。
&gt;&gt; Will Sentance: Doesn't reference,
doesn't reference.

84
00:04:06.627 --> 00:04:08.009
马克: 不参考，他明白吗？
&gt;&gt; Mark: Doesn't reference,
does he get it?

85
00:04:08.009 --> 00:04:12.266
威尔 · 森塔斯: 这是完美的，就像马克将要给出的问题一样。
&gt;&gt; Will Sentance: There it is perfect,
as in question Mark is about to give.

86
00:04:12.266 --> 00:04:13.383
是的，问得好，马克。
Yes, fantastic question, Mark.

87
00:04:13.383 --> 00:04:15.415
我们要弄清楚每个人都被马克问过这个问题。
We'll be clear everyone
got that question by Mark.

88
00:04:15.415 --> 00:04:16.461
马克说等一下。
Mark said hold on.

89
00:04:16.461 --> 00:04:21.893
但如果在我创造的这个本地记忆里,
But what if, in this local
memory I created, let's call it,

90
00:04:21.893 --> 00:04:26.702
我不知道，马克的计数器，年份，还有这个。
I don't know, Mark's counter and
the year and this.

91
00:04:26.702 --> 00:04:30.154
Mark 的计数器是7，返回的输出函数,
Mark's counter is seven,
the returned out function,

92
00:04:30.154 --> 00:04:32.584
我可以编辑这个返回的函数吗？
can I edit this returned out function?

93
00:04:32.584 --> 00:04:39.596
不，因此，马克的计数器放在背包里。
No, therefore, that,
Mark's counter goes in the backpack.

94
00:04:39.596 --> 00:04:41.117
我可以直接在背包上买东西吗？
Can I get anything on a backpack directly?

95
00:04:41.117 --> 00:04:43.252
不，我只能通过运行函数得到它。
No, I can only get it by
running the function.

96
00:04:43.252 --> 00:04:47.591
所以我确切地知道，或者说 Java 确切地知道返回可能的结果的时刻
So I know exactly, or Java knows exactly
the moment of returning out what could

97
00:04:47.591 --> 00:04:49.579
在那个背包里找不到。
ever be accessed in that backpack.

98
00:04:49.579 --> 00:04:53.891
所以在现代版本中，JavaScript 的实现
And so in modern versions of,
the implementations of JavaScript in

99
00:04:53.891 --> 00:04:58.062
我认为39英里 / 小时。
the chrome engine and
other engines as well, I think for 39 on.

100
00:04:58.062 --> 00:05:02.896
优化---- 把什么放进背包。
JavaScript optimizes,
what is put into the backpack.

101
00:05:02.896 --> 00:05:06.910
这个链接构成了整个本地内存，它只是指向这个链接到达的地方的一个链接。
The link is made the entire local memory,
and it's just a link to where that stops.

102
00:05:06.910 --> 00:05:10.346
是的，这不是如果我们宣布马克的计数器里面的外部将是
Yeah, this isn't if we declare Mark's
counter inside of outer is gonna be

103
00:05:10.346 --> 00:05:13.019
当我们完成外部运行时,
stored, it's just when we're
finished running outer,

104
00:05:13.019 --> 00:05:14.560
通常都会被删除。
normally it will all be deleted.

105
00:05:14.560 --> 00:05:19.711
相反，这个函数所引用的任何东西
Instead, anything that the function ever
makes reference to when it would get

106
00:05:19.711 --> 00:05:25.271
最终运行，得到拉出与其背面的函数到我的新函数。
run eventually, gets pulled out with the
function on its back into my new function.

107
00:05:25.271 --> 00:05:30.225
但如果 Mark 的计数器从未被引用从未被引用,
But if that thing, Mark's counter is
never referenced, never referred to,

108
00:05:30.225 --> 00:05:33.826
从未被函数使用过，它会返回作业,
never used by the function and
it gets returned out jobs,

109
00:05:33.826 --> 00:05:38.577
你可以直接查看这个函数，它有没有引用过？
you can literally look into this
function and go, does it ever reference?

110
00:05:38.577 --> 00:05:42.865
没有，没有提到马克的柜台，只有柜台。
Nope, no reference made to Mark's counter,
only to counter.

111
00:05:42.865 --> 00:05:46.855
所以在背包里是没有意义的，因为那就是我们所说的
And so there's no point in being in the
backpack cuz that would be what's called

112
00:05:46.855 --> 00:05:47.637
内存泄漏。
a memory leak.

113
00:05:47.637 --> 00:05:51.566
也就是说，使用计算机内存中的空间。
That is a say specifically,
use space in the computer's memory.

114
00:05:51.566 --> 00:05:54.052
有了标签，就有了与标签一起使用的数据,
With a label,
you've got data used with a label,

115
00:05:54.052 --> 00:05:56.428
我们再也不能做那个标签了。
where we can't ever act
as that label anymore.

116
00:05:56.428 --> 00:05:58.612
所以数据是完全不可访问的,
And so
that data is completely inaccessible,

117
00:05:58.612 --> 00:06:01.694
因为它实际上是在浪费计算机内存中的空间。
as it is literally just wasting
space in the computer's memory.

118
00:06:01.694 --> 00:06:03.017
这就是内存泄漏。
That's what a memory leak is.

119
00:06:03.017 --> 00:06:04.762
这里的情况就是这样。
And that would be the case here.

120
00:06:04.762 --> 00:06:07.538
我们知道马克的计数器是7,
That would be stored,
we'd have Mark's counter is 7, and yet,

121
00:06:07.538 --> 00:06:10.119
如果我们运行 myNewFunction，它就不会引用它，并且
if we ran myNewFunction,
it never makes reference to it, and

122
00:06:10.119 --> 00:06:12.416
我们不能直接到达，所以这只是浪费空间。
we can't get to directly so
it's just waste of space.
