WEBVTT

1
00:00:00.147 --> 00:00:04.605
威尔 · 森塔斯: 我认为值得从人们开始谈论一些话题
&gt;&gt; Will Sentance: I think it is worth
starting off people with some words about

2
00:00:04.605 --> 00:00:07.198
这个同步会把我们带到哪里。
where this a sync is gonna take us.

3
00:00:07.198 --> 00:00:08.537
我们会兑现承诺。
Promises we're gonna cover promises.

4
00:00:08.537 --> 00:00:13.394
如果你看到了某个困难的部分，那么你就会记得它是,
If you've seen v one of hard parts,
then you remember that it's,

5
00:00:13.394 --> 00:00:17.754
我认为，我们有传统的 ES5回调模式。
we got, I think,
to the traditional ES5 callback model.

6
00:00:17.754 --> 00:00:20.408
我们看到回调队列是这样的。
And we saw the callback queue
is all these sort of pieces.

7
00:00:20.408 --> 00:00:25.809
在 ES6中，可能最重要的附加特性是承诺。
In ES6, probably the most significant
additional feature was promises.

8
00:00:25.809 --> 00:00:32.301
所以他们不会和回收模式有根本的不同。
Under the hood, so they're not going to be
radically different to the callback model.

9
00:00:32.301 --> 00:00:36.872
然后我们将会看到我认为是什么使得 JavaScript 成为最重要的特性
Then we're gonna see the key feature of
what I think makes JavaScript the most

10
00:00:36.872 --> 00:00:38.851
强大而通俗的语言。
powerful and popular language.

11
00:00:38.851 --> 00:00:41.712
在网络世界中，这是一个同步性。
A certainly in the web world,
and that is it's a synchronicity.

12
00:00:41.712 --> 00:00:44.082
这就是使动态 web 应用成为可能的原因。
This is what makes dynamic
web applications possible.

13
00:00:44.082 --> 00:00:50.371
这就意味着当你点击大量松弛的表情符号时。
This is what means that when you're
clicking lots of slack emoji responses.

14
00:00:50.371 --> 00:00:52.637
我们还能做什么？
What else would we do?

15
00:00:52.637 --> 00:00:55.564
当你点击那些松弛的表情符号时,
When you're clicking all
those slack emoji responses,

16
00:00:55.564 --> 00:00:59.231
并不是所有的数据都在你本地电脑上更新。
they're not all being updated on
your local machine on your computer.

17
00:00:59.231 --> 00:01:02.844
这些都是通过互联网发送的,
It's so
that's all being sent over the internet,

18
00:01:02.844 --> 00:01:06.456
千里之外回来确认
thousands of miles away
coming back confirming and

19
00:01:06.456 --> 00:01:11.837
然后以某种方式同时发生在一种单线程语言中。
then somehow all happening simultaneously
in a single threaded language.

20
00:01:11.837 --> 00:01:15.597
这可能已经让你停下来思考事件循环
Already that might give you pause for
thought of the event loop which is gonna

21
00:01:15.597 --> 00:01:18.710
结果发现这是 Joshua 发球的方式
turn out to be Joshua's way of
teeing up what's going to run and

22
00:01:18.710 --> 00:01:21.198
他在跑什么，接下来要跑什么。
what he's running and
what's going to run next.

23
00:01:21.198 --> 00:01:25.533
然后一些非常有趣的，这些微任务队列，我想大声说出来
And then some really interesting these the
micro task queue that I wanna shout out

24
00:01:25.533 --> 00:01:28.021
杰克 · 阿奇博尔德，我们的英国朋友,
Jake Archibald, our fellow British friend,

25
00:01:28.021 --> 00:01:31.271
他是谈论市场的人之一
who is one of the people who talked
about the market ask you and

26
00:01:31.271 --> 00:01:34.743
谁喜欢你和网页浏览器的功能真的很重要。
it really important who likes you and
the web browser features.

27
00:01:34.743 --> 00:01:39.448
但我们又回到了起点。
But we're back where we started.

28
00:01:39.448 --> 00:01:41.912
我们要重新回到马鞍上
We are going to get back in the saddle so

29
00:01:41.912 --> 00:01:46.381
通过提醒自己乔布斯会如何宽恕常规代码来说话。
to speak by reminding ourselves how
jobs would excuse regular code.

30
00:01:46.381 --> 00:01:47.879
好了，开始了，各位。
Okay, here we go, people.

31
00:01:47.879 --> 00:01:49.700
我们回来了。
We're back.

32
00:01:49.700 --> 00:01:50.990
我们回来了。
We're back.

33
00:01:50.990 --> 00:01:51.837
我们回来了。
We're back.

34
00:01:51.837 --> 00:01:56.546
一号线到凯拉一号线我们在这里做什么？
So line one is over to Kayla line one,
what are we doing here?

35
00:01:56.546 --> 00:01:59.838
请记住，运行代码有两部分，分别逐行和逐行检查
Remember there's two parts running
code going through it line by line and

36
00:01:59.838 --> 00:02:00.858
边走边存东西。
saving stuff as we go.

37
00:02:00.858 --> 00:02:04.801
第一行 Kayla 我们在第一行做什么？
So Kayla, the line one, what are we
doing in our very first line here?

38
00:02:04.801 --> 00:02:06.927
我们在定义恒定标准
&gt;&gt; Kayla: We're defining constant norm and

39
00:02:06.927 --> 00:02:09.662
将值设置为3
setting the value to three
&gt;&gt; Will Sentance: Beautiful where's that

40
00:02:09.662 --> 00:02:10.298
被拯救？
being saved?

41
00:02:10.298 --> 00:02:11.909
数据保存在哪里？
Where's that data being saved?

42
00:02:11.909 --> 00:02:12.838
在全球记忆中。
&gt;&gt; Kayla: In global memory.

43
00:02:12.838 --> 00:02:13.492
威尔 · 森塔斯: 太棒了。
&gt;&gt; Will Sentance: Fantastic.

44
00:02:13.492 --> 00:02:16.621
所以 norm 在整体内存中被赋值为3美。
So norm is assigned a value of
3 in global memory beautiful.

45
00:02:16.621 --> 00:02:19.526
让我们看看托德，下一行我们要做什么？
Let's go over to Todd,
what are we doing Todd in the next line?

46
00:02:19.526 --> 00:02:22.074
托德: 我们定义的函数乘以2。
&gt;&gt; Todd: Our defined
function multiplied by two.

47
00:02:22.074 --> 00:02:24.806
威尔 · 森塔斯: 太棒了，也就是说我们接受了它的标签,
&gt;&gt; Will Sentance: Fantastic, and
that is to say we're taking its label,

48
00:02:24.806 --> 00:02:28.990
这是它的标识符，然后把包括参数在内的所有代码
that's its identifier, and then taking all
the code of it including the parameter as

49
00:02:28.990 --> 00:02:33.022
一个占位符，用来填充数据，最后我们用这个代码。
a placeholder, that's gonna be filled in
with data and we end up using this code.

50
00:02:33.022 --> 00:02:36.263
在使用此代码时使用值排序，并且
Sort of with a value in using this code,
and

51
00:02:36.263 --> 00:02:39.506
我们一次性全部保留下来，太棒了。
we are saving it all in one go, fantastic.

52
00:02:39.506 --> 00:02:41.747
下一行。
Next line.

53
00:02:41.747 --> 00:02:44.334
让我们把马特留在左手边。
Let us have Matt left hand side.

54
00:02:44.334 --> 00:02:47.147
Matt: 你要在全局内存中定义常量输出。
&gt;&gt; Matt: You are gonna define
the constant output in the global memory.

55
00:02:47.147 --> 00:02:50.599
威尔 · 森特斯: 美丽的每个人在这一点上都是如此的专业。
&gt;&gt; Will Sentance: Beautiful
everybody is so pro at this point.

56
00:02:50.599 --> 00:02:52.015
非常好。
It is very nice.

57
00:02:52.015 --> 00:02:53.723
定义内存的常量输出。
Define the constant output of memory.

58
00:02:53.723 --> 00:02:57.060
马特，我要在那个恒定输出中存储什么？
Matt, what am I gonna store
in that constant output?

59
00:02:57.060 --> 00:02:58.985
马特: 乘以二的结果。
&gt;&gt; Matt: The result of multiplied by two.

60
00:02:58.985 --> 00:03:02.270
威尔 · 森坦斯: 编码的结果乘以二。
&gt;&gt; Will Sentance: The result
of coding multiplied by two.

61
00:03:02.270 --> 00:03:05.330
很漂亮，那么现在，各位，是吗？
Beautiful, so for now, everybody it is?

62
00:03:05.330 --> 00:03:06.264
观众: 未初始化。
&gt;&gt; Audience: Uninitialized.

63
00:03:06.264 --> 00:03:07.877
威尔 · 森特斯: 非常好，特别照顾。
&gt;&gt; Will Sentance: Very nice,
taken care of specially.

64
00:03:07.877 --> 00:03:13.007
好了，我们不要用乘以2来调用
All right, so
let's not get calling multiply by 2

65
00:03:13.007 --> 00:03:18.969
输入的范数是值，3，它的输出,
with the input of norm which is the value,
3, its output,

66
00:03:18.969 --> 00:03:24.723
它的返回值将被存储到输出中。
it's returned value is going
to be stored into outputs.

67
00:03:24.723 --> 00:03:27.875
我们要创造一个全新的世界吗？
And we're gonna create,
everybody, a brand new?

68
00:03:27.875 --> 00:03:28.873
观众: 执行情境。
&gt;&gt; Audience: Execution context.

69
00:03:28.873 --> 00:03:32.110
威尔 · 森塔斯: 我也觉得很棒。
&gt;&gt; Will Sentance: Fantastic
in line with me as well.

70
00:03:32.110 --> 00:03:33.259
好了。
There we go.

71
00:03:33.259 --> 00:03:36.807
安德鲁，我们去民间。
And Andrew we go folk.

72
00:03:36.807 --> 00:03:40.194
是的，形状很好。
Yeah, very nicely shaped.

73
00:03:40.194 --> 00:03:43.991
它就在那里，我们的第一件事就是进入它的本地记忆
There it is and
into its local memory our first thing

74
00:03:43.991 --> 00:03:48.772
存储为分配给哪个参数名的值3，Jeff？
stored as a value three assigned
to what parameter name, Jeff?

75
00:03:48.772 --> 00:03:49.475
杰夫: 输入号码。
&gt;&gt; Jeff: Input number.

76
00:03:49.475 --> 00:03:51.564
威尔 · 句子: 输入数字，是的，民众。
&gt;&gt; Will Sentance: Input number, yes folk.

77
00:03:51.564 --> 00:03:56.811
这是输入的数字，然后丹通过函数的主体告诉我
There it is input number then Dan told
me through the body of the function

78
00:03:56.811 --> 00:03:58.483
阿丹: 我们在定义恒定的结果。
&gt;&gt; Dan: We are defining constant result.

79
00:03:58.483 --> 00:04:01.570
威尔 · 森塔斯: 结果丹: 我们给
&gt;&gt; Will Sentance: Results
&gt;&gt; Dan: And we're assigning the value of

80
00:04:01.570 --> 00:04:04.867
输入数乘以2？
input number multiplied by 2
&gt;&gt; Will Sentance: Which is?

81
00:04:04.867 --> 00:04:07.026
然后我们做什么？
&gt;&gt; Dan: 6
&gt;&gt; Will Sentance: And then we do what?

82
00:04:07.026 --> 00:04:11.560
丹: 我们返回指定的值
Dan
&gt;&gt; Dan: We return out the value assigned

83
00:04:11.560 --> 00:04:13.045
来标记结果。
to label result.

84
00:04:13.045 --> 00:04:14.829
威尔 · 森塔斯: 说得很好，完全正确。
&gt;&gt; Will Sentance: Very nicely put,
exactly.

85
00:04:14.829 --> 00:04:20.600
然后加入全局常量，输出，就是这个，完美。
And adding comes into the global constant,
output, there it is, perfect.

86
00:04:20.600 --> 00:04:22.029
各位，我想说的是,
People, I wanna just talk about,

87
00:04:22.029 --> 00:04:24.411
不过，看看执行的过程。
though, look at the journey
of the thread of execution.

88
00:04:24.411 --> 00:04:27.031
从现在开始我要用绿色。
I'm gonna do in green from now on.

89
00:04:27.031 --> 00:04:30.358
当我们点到这条线时，乘以2。
When we hit this line here,
the of multiply by two.

90
00:04:30.358 --> 00:04:34.411
我们的执行线程，记住，这是我们运行代码所需要的一半。
Our thread of execution, remember, that's
the half of what we need to run code.

91
00:04:34.411 --> 00:04:38.461
我们需要运行代码的能力，就像这个左边这样,
We need the ability to run code,
sort of this left-hand side here,

92
00:04:38.461 --> 00:04:41.461
还有储存东西的能力，这两个部分。
and the ability to store stuff,
those two parts.

93
00:04:41.461 --> 00:04:43.526
当我们开始运行 multiply by 2时。
When we started running multiply by2.

94
00:04:43.526 --> 00:04:46.735
所以我们开始运行我们的代码，我们的执行线程正在崩溃。
So we started running our code,
our thread of execution was going down.

95
00:04:46.735 --> 00:04:51.389
它按下标签输出，然后运行更多的代码。
It hit label output, and
then go run some more code.

96
00:04:51.389 --> 00:04:55.872
所以我们的执行线程必须用来运行这个函数的代码。
So our thread of execution had to be
used to run the code of that function.

97
00:04:55.872 --> 00:05:00.550
我们进入它，直到我们完成这个函数,
Into it we went and
until we finished inside this function,

98
00:05:00.550 --> 00:05:05.238
我们允许进入下一行代码和全局代码？
where we allow to move on to
the next line of code and global?

99
00:05:05.238 --> 00:05:09.314
不，因为 JavaScript 是一种同步语言,
No, because JavaScript is
a synchronous language,

100
00:05:09.314 --> 00:05:14.295
是一种同步语言，它意味着我们要做每一行,
JavaScript is a synchronous language
that means we do each line,

101
00:05:14.295 --> 00:05:18.658
我们完成它，当我们完成，我们去下一行，好吗。
we finish it,
when we finish that we go next line, okay.

102
00:05:18.658 --> 00:05:21.850
所以我们开始，我们做了里面的所有代码
So into we went and
we did all the code inside of it and

103
00:05:21.850 --> 00:05:25.805
直到我们完成它，我们没有退出，到下一行。
until we finished with it,
we did not exit out to the next line.

104
00:05:25.805 --> 00:05:31.151
当我们这样做的时候，我们关闭了这个执行环境，然后继续前进。
And when we did, at that point we closed
this execution context and we moved on.

105
00:05:31.151 --> 00:05:33.391
然后我们在全球的下一行。
And then we hit our next line in global.

106
00:05:33.391 --> 00:05:36.374
但是你可以想象我们运行代码的语言,
But you could imagine the language
where we would have run our code,

107
00:05:36.374 --> 00:05:38.937
我们的线程会被乘以2运行它
our thread would have gone into
multiplied by two run it and

108
00:05:38.937 --> 00:05:41.465
我们会在 global 继续我们的执行线程。
we'd have continued our thread
of execution in global.

109
00:05:41.465 --> 00:05:42.526
但不是在 JavaScript 中。
But not in JavaScript.

110
00:05:42.526 --> 00:05:47.034
在 JavaScript 中，如果我们有一行代码要做，我们就必须去做。
In JavaScript, if we have a line
of code to do, we have to do it.

111
00:05:47.034 --> 00:05:49.026
这是我们唯一能做的代码行
It's the only line of code we can do and

112
00:05:49.026 --> 00:05:52.156
我们必须完成它，然后才能进入下一行，好吗？
we had to finish on it before
we move to the next line, okay?

113
00:05:54.937 --> 00:05:56.620
威尔 · 森特斯: 你可能已经在想，坚持住,
&gt;&gt; Will Sentance: Already you
might be thinking hold on,

114
00:05:56.620 --> 00:05:58.312
如果那条线是条很慢的线呢？
what if that line is a really slow line?

115
00:05:58.312 --> 00:06:01.971
假设这条线可能是在和 Twitter 对话,
Suppose that lines a line that
might be speaking to Twitter,

116
00:06:01.971 --> 00:06:04.062
在互联网上的速度真的很慢。
over the Internet really slowly.

117
00:06:04.062 --> 00:06:12.218
好的，下一行是声明新的输出。
All right,
next line we hit is declaring new output.

118
00:06:12.218 --> 00:06:17.146
后面的亚当，我们要怎么做才能得到我们的价值
Adam in the back, what are we gonna
do in order to get our value or

119
00:06:17.146 --> 00:06:22.076
为了完成这行代码，最后一行代码,
in order to finish this line of code,
the final line of coding,

120
00:06:22.076 --> 00:06:24.125
我们该怎么办？
what do we gotta go and do?

121
00:06:24.125 --> 00:06:25.451
这最后一句话告诉我们要做什么？
What is this final line telling us to do?

122
00:06:25.451 --> 00:06:27.422
声明新的输出。
Declare new output.

123
00:06:27.422 --> 00:06:31.300
亚当: 把它分配给求值，然后乘以二，再乘以十。
&gt;&gt; Adam: Assign it to evaluation and
multiply by two with an input of ten.

124
00:06:31.300 --> 00:06:33.879
威尔 · 森塔斯: 绝对的，所以，这意味着我们得走了
&gt;&gt; Will Sentance: Absolutely,
so, that means we gotta go and

125
00:06:33.879 --> 00:06:35.355
执行这个函数。
execute this function.

126
00:06:35.355 --> 00:06:40.576
快速地为它创建一个新的执行上下文
Create a new execution context for
it very quickly

127
00:06:40.576 --> 00:06:46.543
创建一个新的执行上下文进入它，我们要去
create a new execution context
into it we're gonna go and

128
00:06:46.543 --> 00:06:52.012
在本地内存中，我们会有输入号码,
in local memory,
we are going to have input number,

129
00:06:52.012 --> 00:06:56.882
分配给10个结果，我们知道这个权利？
assigned to 10 result, we know this right?

130
00:06:56.882 --> 00:07:03.468
结果将是20，返回的值将结果输出到新的输出。
Result will be 20 and the return of
value result out into new output.

131
00:07:03.468 --> 00:07:08.077
我们的执行线程，我们唯一的执行线程，唯一的执行线程
Our thread of execution, our single
thread of execution, the single do one

132
00:07:08.077 --> 00:07:12.485
在这里的时候，我们可以运行更多的代码吗？
thing at a time while inside of here,
can we be running any further code?

133
00:07:12.485 --> 00:07:15.887
没有，等我们做完了我们就可以出来了。
No, and when we're finished
with that we can come out.
