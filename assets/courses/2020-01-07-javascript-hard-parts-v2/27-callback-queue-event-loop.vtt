WEBVTT

1
00:00:00.150 --> 00:00:01.470
威尔 · 森塔斯: 我们找到了我们的公主。
&gt;&gt; Will Sentance: We have our printHello.

2
00:00:01.470 --> 00:00:02.509
我们有自己的区域。
We have our blockFor1Sec.

3
00:00:02.509 --> 00:00:04.610
我们将这个命名为 setTimeout。
We're going to call this setTimeout.

4
00:00:04.610 --> 00:00:08.054
对 JavaScript 有兴趣吗，凯拉？
Is setTimeout doing anything in
JavaScript of interest, Kayla?

5
00:00:08.054 --> 00:00:09.688
屏幕外的女性: 没有。
&gt;&gt; off screen female: No.

6
00:00:09.688 --> 00:00:11.119
不，在 JavaScript 中什么都没有。
&gt;&gt; Will Sentance: No,
nothing in JavaScript.

7
00:00:11.119 --> 00:00:12.936
然后我们会叫出1秒区。
Then we're gonna call out blockFor1Sec.

8
00:00:12.936 --> 00:00:14.686
然后我们来看看,
And then we're gonna, let's see,

9
00:00:14.686 --> 00:00:17.634
也许下次我们不会叫出1秒区了。
well maybe we're not gonna call
out blockFor1Sec for next.

10
00:00:17.634 --> 00:00:20.019
谁知道呢，我们拭目以待。
Who knows, we shall see.

11
00:00:20.019 --> 00:00:23.920
这就是我们的全球记忆。
So, there's our global memory.

12
00:00:23.920 --> 00:00:27.637
一号线凯拉有什么事吗？
Line one, Kayla, what are we up to?

13
00:00:27.637 --> 00:00:29.449
我们正在定义 printHello 函数。
&gt;&gt; off screen female: We're
defining the printHello function.

14
00:00:29.449 --> 00:00:34.539
非常好，我们正在定义 printHello 函数。
&gt;&gt; Will Sentance: Very nice,
we're defining the printHello function.

15
00:00:34.539 --> 00:00:37.787
好极了，下一句是杰夫。
Excellent, next line over to Jeff.

16
00:00:37.787 --> 00:00:40.405
关闭屏幕男: 我们定义一个函数，blockfor1秒。
&gt;&gt; off screen male: We define a function,
blockFor1Second.

17
00:00:40.405 --> 00:00:44.408
威尔 · 森坦斯: blockFor1Sec，没错，就是这个。
&gt;&gt; Will Sentance: blockFor1Sec,
exactly, there it is.

18
00:00:44.408 --> 00:00:46.737
我们不知道怎么回事，我是说，我们知道怎么回事。
We don't know how it's, I mean,
we know how it's gonna work.

19
00:00:46.737 --> 00:00:48.838
我们不会写出代码但如果我们运行它,
We're not writing its code out,
but if we ran it,

20
00:00:48.838 --> 00:00:51.539
你会运行某种 for 循环，或者类似的东西。
you would run some sort of for
loop, or something like that.

21
00:00:51.539 --> 00:00:53.450
绝对不是定时器，只是要说清楚。
Definitely not a timer, just be clear.

22
00:00:53.450 --> 00:00:55.009
这是一个很容易掉进去的陷阱。
It's an easy trap to fall into.

23
00:00:55.009 --> 00:00:57.729
现在，事情变得有趣了。
Now, things get interesting.

24
00:00:57.729 --> 00:01:02.935
现在，我们开始我们的第一个 facade 函数
Now, we hit our first facade function for

25
00:01:02.935 --> 00:01:08.445
网页浏览器的一个特性，setTimeout。
a feature of the web browser, setTimeout.

26
00:01:08.445 --> 00:01:15.353
我们会邀请伊森，不，不，不，伊森的台词很棒。
And we're going to invite Ethan, no, no,
no [LAUGH] Ethan's line was excellent.

27
00:01:15.353 --> 00:01:18.254
我们不会再重蹈覆辙了。
We're not gonna put even
through that again.

28
00:01:18.254 --> 00:01:20.680
这次是0。
printHello, and this time is 0.

29
00:01:20.680 --> 00:01:22.736
我是说，第二次等待。
I mean, the second wait.

30
00:01:22.736 --> 00:01:28.388
好的，我应该从那里把它们给你。
Okay, I should give
them to you from there.

31
00:01:28.388 --> 00:01:31.771
我们对 JavaScript 有什么感兴趣的吗？
setTimeout, do we have anything
in JavaScript of any interest?

32
00:01:31.771 --> 00:01:35.120
不，相反，在一个命令中
No, what instead is in a command to

33
00:01:35.120 --> 00:01:37.816
我们屏幕上的哪一部分
which part of our-
&gt;&gt; off screen male: It's gonna send

34
00:01:37.816 --> 00:01:39.640
给浏览器发信息？
a message to the web browser?

35
00:01:39.640 --> 00:01:44.856
威尔 · 森坦斯: 说得好，它会在浏览器中触发,
&gt;&gt; Will Sentance: Very nicely put,
it's gonna trigger in the web browser,

36
00:01:44.856 --> 00:01:48.700
计时器的开关，计时器的开关。
the switching on of the timer, of a timer.

37
00:01:48.700 --> 00:01:52.825
它需要什么信息，马克，才能成为一个有效的计时器？
And what information does it need here,
Mark, to be an effective timer?

38
00:01:52.825 --> 00:01:53.610
屏幕外的男性: 实际时间。
&gt;&gt; off screen male: The actual time.

39
00:01:53.610 --> 00:01:54.478
是的，对吗？
&gt;&gt; Will Sentance: Yeah, right?

40
00:01:54.478 --> 00:01:59.182
0毫秒，还有，伊森？
0 milliseconds, and also, Ethan?

41
00:01:59.182 --> 00:02:01.760
关闭屏幕男: 功能定义 printHello？
&gt;&gt; off screen male: The function
definition printHello?

42
00:02:01.760 --> 00:02:04.469
威尔 · 森特斯: 是的，那就是我们要在计时器完成后运行的东西。
&gt;&gt; Will Sentance: Yeah, that's what we're
gonna run on the completion of the timer.

43
00:02:04.469 --> 00:02:06.375
很好，非常好。
Perfect, very nice.

44
00:02:06.375 --> 00:02:09.139
这一切大概发生在什么时间？
And this is all happening
at roughly what time?

45
00:02:09.139 --> 00:02:13.699
也许0毫秒或者类似的东西，大概0毫秒，就是这样。
Maybe 0 milliseconds or something like
that, roughly 0 milliseconds, there it is.

46
00:02:15.000 --> 00:02:21.409
现在，我们需要下面的所有东西来成为我们的 Web 浏览器。
Now, we need everything below
here to be our Web Browser.

47
00:02:21.409 --> 00:02:24.516
就是这样,
So there it is,

48
00:02:24.516 --> 00:02:29.302
网页浏览器功能。
Web Browser features.

49
00:02:32.495 --> 00:02:36.776
网页浏览器的功能定时器在网页浏览器。
&gt;&gt; Will Sentance: Web Browser
features Timer in the web browser.

50
00:02:36.776 --> 00:02:42.003
所以我们说我们的功能
So we'd say the feature we're

51
00:02:42.003 --> 00:02:46.030
用的是计时器。
gonna use is the Timer.

52
00:02:46.030 --> 00:02:50.959
打开计时器，将其时间设置为完成0毫秒。
Turn on a timer, set its time to
completion to be 0 milliseconds.

53
00:02:52.199 --> 00:02:56.420
当它完成的时候，再次提醒我们，马特，当它完成的时候。
On its completion, just remind us,
again, Matt, on completion.

54
00:02:56.420 --> 00:02:57.900
我们希望发生什么？
What do we want to have happen?

55
00:02:57.900 --> 00:03:00.099
你想让它运行 printHello。
&gt;&gt; off screen male: You want
it to run the printHello.

56
00:03:00.099 --> 00:03:03.560
完美，运行 printHello 函数。
&gt;&gt; Will Sentance: Perfect,
run the printHello function.

57
00:03:03.560 --> 00:03:07.560
所以我们要把一个参考信息传递到网页浏览器,
So we're going to pass into
the web browser a reference,

58
00:03:07.560 --> 00:03:09.370
一个回到我们想要在 JavaScript 中运行的函数的链接。
a link back to the function
we want to run in JavaScript.

59
00:03:09.370 --> 00:03:14.020
但是现在把它想象成函数，所以只是在 JavaScript 或者
But think of it as being the function is
now, so just be outside of JavaScript or

60
00:03:14.020 --> 00:03:16.203
至少它已经准备好了,
at least it's sitting there ready,

61
00:03:16.203 --> 00:03:19.670
希望在某个时候能在 JavaScript 中运行。
hopefully to be run back inside
JavaScript at some point.

62
00:03:19.670 --> 00:03:24.442
现在提问这次我想请凯拉帮忙。
Now question,
I wanna turn to Kayla on this one.

63
00:03:24.442 --> 00:03:28.979
凯拉是0毫秒,
Kayla, is at 0 milliseconds,

64
00:03:28.979 --> 00:03:34.531
0毫秒计时器完成了吗？
is our 0 millisecond timer complete?

65
00:03:34.531 --> 00:03:36.037
屏幕外的女性: 没有。
&gt;&gt; off screen female: No.

66
00:03:36.037 --> 00:03:40.054
句子: 0分钟计时器在0毫秒，你认为呢？
&gt;&gt; Will Sentance: 0 minute timer at
0 milliseconds, what do you think?

67
00:03:40.054 --> 00:03:45.170
是这样吗? 威尔 · 森坦斯: 它完成了吗？
Is that kinda,
&gt;&gt; Will Sentance: Is it complete?

68
00:03:45.170 --> 00:03:47.373
它怎么会超过0毫秒呢？
How would it take any
longer than 0 milliseconds?

69
00:03:47.373 --> 00:03:49.298
托德，你没有完成。
Todd, you didn't complete.

70
00:03:49.298 --> 00:03:51.713
好的，我的问题是,
&gt;&gt; off screen male: Okay,
so my question would be,

71
00:03:51.713 --> 00:03:56.221
0毫秒和0毫秒是一样的吗？
is that 0 milliseconds the same
as that 0 milliseconds?

72
00:03:56.221 --> 00:03:57.530
威尔 · 森坦斯: 是的，0毫秒,
&gt;&gt; Will Sentance: Yeah, 0 milliseconds,

73
00:03:57.530 --> 00:03:59.973
我们的0毫秒计时器完成了，各位。
our 0 millisecond timer is complete,
people.

74
00:03:59.973 --> 00:04:01.016
好了，干得好。
There you go, good job.

75
00:04:01.016 --> 00:04:05.935
0毫秒，我们的0毫秒计时器就完成了，对吧？
0 milliseconds, our 0 millisecond
timer is definitely complete, right?

76
00:04:05.935 --> 00:04:07.830
我不知道这需要多少毫秒的时间。
I don't know how many more than
milliseconds it would take.

77
00:04:07.830 --> 00:04:11.289
这就像，是的，0毫秒是一个完整的计时器。
It's like, yeah,
0 millisecond is a complete timer.

78
00:04:11.289 --> 00:04:14.402
因为疯狂的是，它就像已经完成了。
Because crazily, it's like done.

79
00:04:14.402 --> 00:04:15.265
已经结束了，就是这样。
It's done, it's all it is.

80
00:04:15.265 --> 00:04:18.167
这是一个0毫秒的计时器。
It's a 0 millisecond timer.

81
00:04:18.167 --> 00:04:22.033
所以我假设 printHello 被抓住了
So I presume printHello gets grabbed and

82
00:04:22.033 --> 00:04:27.562
威尔 · 森塔斯: 打电话给斯塔克。
put on to the,
&gt;&gt; Will Sentance: Call Stack.

83
00:04:29.391 --> 00:04:30.606
威尔 · 森特斯: 我们认为人们是怎样的？
&gt;&gt; Will Sentance: What do we think people?

84
00:04:33.444 --> 00:04:35.742
威尔 · 森塔斯: 然而，它是完整的，所以它的时间
&gt;&gt; Will Sentance: And yet,
it is complete and so it's time for

85
00:04:35.742 --> 00:04:37.803
函数到调用堆栈上。
the function to go onto the Call Stack.

86
00:04:40.959 --> 00:04:44.120
威尔 · 森特斯: 我要确保我的脚是最好的。
&gt;&gt; Will Sentance: I'm making
sure I stand on my best foot.

87
00:04:44.120 --> 00:04:45.480
特纳告诉我这是我最好的角度。
Turner told me this is my best angle.

88
00:04:46.949 --> 00:04:50.920
它是完整的，所以我想你得到，民间,
It is complete, so I guess you get, folk,

89
00:04:50.920 --> 00:04:54.230
我们还需要知道另一个谜题。
there's another part to the puzzle
that we need to know about.

90
00:04:54.230 --> 00:04:55.831
我就不拐弯抹角了。
And I'm not gonna beat
around the bush on it.

91
00:04:55.831 --> 00:04:58.449
我现在要说的就是这个。
I'm gonna talk about it right now,
which is this.

92
00:04:58.449 --> 00:05:01.709
它叫做，它是一个队列。
It's called, it's a queue.

93
00:05:01.709 --> 00:05:04.413
当你们谈论这件事的时候，我从几个人那里听到了这个词。
I heard the word said from a few
people when you were talking about it.

94
00:05:04.413 --> 00:05:07.714
这是一个队列，我们怎么称呼这些？
It's a queue of, what do we call these?

95
00:05:07.714 --> 00:05:10.963
我们把传递到其他函数中的 baby 函数叫什么？
What do we call baby functions that
get passed into other functions?

96
00:05:10.963 --> 00:05:13.569
作为输入传递到其他函数的小函数。
Little functions that get passed
as inputs into other functions.

97
00:05:13.569 --> 00:05:14.086
男: 回电。
&gt;&gt; off screen male: Callback.

98
00:05:14.086 --> 00:05:20.235
Will Sentance: Callback，所以它是一个回调队列。
&gt;&gt; Will Sentance: Callback,
so it's a queue of callbacks.

99
00:05:20.235 --> 00:05:23.055
回调队列。
A callback queue.

100
00:05:23.055 --> 00:05:28.033
不要以这种方式混淆它，或者不要将这些回调与那些回调混淆
Do not by the way confuse it, or do not
confuse these callbacks with the ones

101
00:05:28.033 --> 00:05:32.819
我们昨天看到它们运行在高阶函数的内部。
we saw yesterday where they run
inside of the higher order function.

102
00:05:32.819 --> 00:05:36.129
不，不，不，这个是被抓住扔出去的。
No, no, no, this one is grabbed and
thrown right out of.

103
00:05:36.129 --> 00:05:37.254
这只是一个命令。
This is just a command.

104
00:05:37.254 --> 00:05:40.987
没有任何一点是 printHello 运行内部的 setTimeout。
At no point is printHello
run inside of setTimeout.

105
00:05:40.987 --> 00:05:42.966
他们只是抓住这个功能，设置它，然后
They just grabbed that function,
set it and

106
00:05:42.966 --> 00:05:45.860
把计时器放进网页浏览器，就存在这里了。
threw into the timer into the web
browser and it's stored here.

107
00:05:47.750 --> 00:05:50.161
或者至少一个指向它最初定义的地方的链接存储在那里。
Or at least a link to where it was
originally defined is store there.

108
00:05:51.649 --> 00:05:52.524
此刻,
At this moment,

109
00:05:52.524 --> 00:05:56.471
在0毫秒时，printHello 不会直接进入调用堆栈。
at 0 milliseconds, printHello ain't
going on the Call Stack directly.

110
00:05:56.471 --> 00:06:01.569
它必须在这里排队进入回调队列,
It's gonna have to queue itself up
here into the callback queue it goes,

111
00:06:01.569 --> 00:06:04.860
在0毫秒，准备运行。
at 0 milliseconds, ready to run.

112
00:06:04.860 --> 00:06:07.839
这是我们的朋友 printHello
There's our friend printHello, and

113
00:06:07.839 --> 00:06:11.850
它会放在回调队列中，准备运行。
it's gonna sit in the callback
queue ready to run.

114
00:06:15.910 --> 00:06:19.670
威尔 · 森坦斯: 但它仍然准备好了，所以我想现在,
&gt;&gt; Will Sentance: But
it's still ready so I guess now,

115
00:06:19.670 --> 00:06:25.250
当我们完成 setTimeout 的时候，我们会继续,
as we complete the setTimeout,
we're gonna pile on,

116
00:06:25.250 --> 00:06:31.942
加速到我们的下一条线，丹，以1毫秒的速度。
accelerated on to our next line which,
Dan, at 1 millisecond.

117
00:06:31.942 --> 00:06:33.963
屏幕外的男性: 我们要叫做 blockFor1Sec？
&gt;&gt; off screen male: We're
going to call blockFor1Sec?

118
00:06:33.963 --> 00:06:35.840
威尔 · 森特斯: 可是，小王子正坐在那儿等着呢。
&gt;&gt; Will Sentance: But, little
printHello is sitting there waiting.

119
00:06:37.399 --> 00:06:38.370
谁认为丹是对的？
Who thinks Dan's right?

120
00:06:39.379 --> 00:06:40.444
丹说得很对。
Dan is spot on.

121
00:06:40.444 --> 00:06:44.393
我们要打电话给1秒区。
We are gonna call blockFor1Sec.

122
00:06:44.393 --> 00:06:46.913
非常有趣。
Most interesting.

123
00:06:46.913 --> 00:06:51.019
1 / sec.
blockFor1Sec.

124
00:06:51.019 --> 00:06:52.800
全新的执行环境。
Brand new execution context.

125
00:06:52.800 --> 00:06:56.327
我们不会过一遍细节。
We're not gonna sort of
go through its details.

126
00:06:56.327 --> 00:07:00.970
但是，我为它添加了如此多的细节，全新的执行环境。
But, I'm adding so much detail for
it, brand new execution context.

127
00:07:00.970 --> 00:07:02.689
就是这个。
There it is.

128
00:07:02.689 --> 00:07:05.980
然后我们的死刑线就会编织进来。
And our thread of execution
is gonna weave in.

129
00:07:05.980 --> 00:07:07.290
它将进入调用堆栈。
It's going on the call stack.

130
00:07:08.709 --> 00:07:17.372
1 / sec，我们以1毫秒进入它。
blockFor1Sec, we go into
it at 1 millisecond.

131
00:07:17.372 --> 00:07:20.860
里面需要1000毫秒。
It's gonna take 1,000 milliseconds inside.

132
00:07:23.007 --> 00:07:24.829
威尔 · 森塔斯: 现在我们有个问题。
&gt;&gt; Will Sentance: Now
we have the question.

133
00:07:26.600 --> 00:07:31.303
在任何时候，我们是否认为，当我们在 blockFor1Sec 时，它正在做 for 循环,
At any moment, do we think, while we
are in blockFor1Sec, it's doing for loop,

134
00:07:31.303 --> 00:07:32.930
很多很多的重复。
lots and lots of iteration.

135
00:07:32.930 --> 00:07:34.058
在那里的任何时刻,
At any moment there,

136
00:07:34.058 --> 00:07:38.149
我们认为 printHello 可以在调用堆栈上运行吗？
do we think printHello is allowed out of
that queue to be run on the call stack?

137
00:07:39.480 --> 00:07:40.129
并非如此。
It's not.

138
00:07:41.360 --> 00:07:44.319
但是我的天啊，它已经等了0毫秒了。
But my goodness,
it's been waiting for 0 milliseconds.

139
00:07:46.170 --> 00:07:53.327
我们将以1001毫秒的速度从1秒区出来。
We're gonna come out of
blockFor1Sec at 1001 milliseconds.

140
00:07:53.327 --> 00:07:59.853
我们的小 printHello 会说，好的，最后，你完成了你的功能。
And our little printHello is gonna say,
okay, finally, you finish your function.

141
00:07:59.853 --> 00:08:03.362
你把它从调用堆栈上弹出来，我们把它从调用堆栈上弹出来。
You popped it off the call stack,
let's pop it off the call stack.

142
00:08:03.362 --> 00:08:07.470
好吧，我终于可以出去了。
Okay, finally, I'm allowed out.

143
00:08:07.470 --> 00:08:14.122
它一直在那里焦急地等待，非常兴奋，说，“我想出来。”。
And it's been waiting there quite eagerly,
very excited, say, I wanna come out.

144
00:08:14.122 --> 00:08:18.410
我想从队列中走出来进入调用堆栈。
I wanna [LAUGH] be out of
the queue into the call stack.

145
00:08:19.990 --> 00:08:22.629
最后在1001毫秒，我们认为会发生什么？
And finally at 1001 milliseconds,
what do we think happens?

146
00:08:22.629 --> 00:08:23.230
可以出去吗？
Is it allowed out?

147
00:08:23.230 --> 00:08:23.922
男: 是的。
&gt;&gt; off screen male: Yes.

148
00:08:23.922 --> 00:08:25.889
威尔 · 森特斯: 不，它仍然不允许外出。
&gt;&gt; Will Sentance: No,
it's still not allowed out.

149
00:08:25.889 --> 00:08:26.952
(笑声)
[LAUGH]
&gt;&gt; [LAUGH]

150
00:08:26.952 --> 00:08:27.667
威尔 · 森特斯: 相反,
&gt;&gt; Will Sentance: Instead,

151
00:08:27.667 --> 00:08:33.308
我们可怜的小 printHello 会坐在那里，然后用什么来代替呢，Todd？
our poor little printHello is gonna sit
there and what's gonna run instead, Todd?

152
00:08:33.308 --> 00:08:34.052
先给我登陆。
&gt;&gt; off screen male: The console.log
me first.

153
00:08:34.052 --> 00:08:38.051
威尔 · 森特斯: console.log me first，exactly right。
&gt;&gt; Will Sentance: console.log me first,
exactly right.

154
00:08:38.051 --> 00:08:40.760
我们的 console.log 我第一。
Our console.log me first.

155
00:08:40.760 --> 00:08:45.168
在那里它进入我们的控制台
There it is into our console will be

156
00:08:45.168 --> 00:08:50.038
记录在1001毫秒。
logged at 1,001 milliseconds.

157
00:08:50.038 --> 00:08:51.631
我先说。
Me first.

158
00:08:51.631 --> 00:08:54.386
完全正确。
Exactly right.

159
00:08:54.386 --> 00:08:56.342
我的天啊。
My goodness.

160
00:08:56.342 --> 00:09:00.144
现在是1002毫秒,
Now at 1002 milliseconds,

161
00:09:00.144 --> 00:09:04.379
你们说出来都很紧张。
you're all nervous to even say it.

162
00:09:04.379 --> 00:09:10.184
在1002毫秒，现在，好的，这是我的声音，我会用 Mile 的 yes 声音。
At 1002 milliseconds, now surely, okay,
that's my voice, I'll do Mile's yes voice.

163
00:09:10.184 --> 00:09:13.743
现在，布雷登，你认为什么才能被允许跑步
Now, Brayden, what do you think
is gonna be allowed to run and

164
00:09:13.743 --> 00:09:15.188
被放在调用堆栈上吗？
be put on the call stack?

165
00:09:15.188 --> 00:09:15.721
屏幕外的男性: printHello。
&gt;&gt; off screen male: printHello.

166
00:09:15.721 --> 00:09:18.283
威尔 · 森塔斯: 《王子》 ，完全正确。
&gt;&gt; Will Sentance: printHello,
exactly right.

167
00:09:18.283 --> 00:09:23.270
在1002毫秒，printHello 抓住了
At 1002 milliseconds,
printHello grabbed out

168
00:09:23.270 --> 00:09:28.366
放在调用堆栈上，就是这个,
of the queue, put on the call stack,
and there it is,

169
00:09:28.366 --> 00:09:33.604
printhello 的执行时间为1002毫秒。
printHello is executed
at 1,002 milliseconds.

170
00:09:33.604 --> 00:09:36.307
因此，布雷登，我们在控制台上看到了什么？
Therefore, Brayden,
we see in our console, what?

171
00:09:36.307 --> 00:09:36.838
银幕下的男性: 你好。
&gt;&gt; off screen male: Hello.

172
00:09:36.838 --> 00:09:40.559
威尔 · 森坦斯: 你好，没错。
&gt;&gt; Will Sentance: Hello, exactly.

173
00:09:40.559 --> 00:09:44.437
天啊，又来了。
My god, there we go.

174
00:09:44.437 --> 00:09:46.706
所以乡亲们，你们能不能试着确定。
So folk, can you try and ascertain.

175
00:09:51.205 --> 00:09:55.538
威尔 · 森特斯: 是的，你能试着弄清楚我们的基本原则是什么吗,
&gt;&gt; Will Sentance: Yes, can you try and
ascertain what is our fundamental,

176
00:09:55.538 --> 00:09:59.980
这就是我刚学会的一个词的最低点。
that was my low point trying
to use a word I just learned.

177
00:09:59.980 --> 00:10:06.024
我们能否试着弄清楚我们的规则是为了什么
Can we try and
ascertain what was our rule for

178
00:10:06.024 --> 00:10:09.840
当队列中的一个函数
when a function in the queue that's being

179
00:10:09.840 --> 00:10:14.539
通过使用这些外观函数之一抛出，进入网页浏览器。
thrown out by using one of these facade
functions, out into the web browser.

180
00:10:14.539 --> 00:10:16.759
并不是真的在 JavaScript 中做任何事情。
setTimeout ain't really doing
anything in JavaScript.

181
00:10:16.759 --> 00:10:19.731
相反，它只是抓住那个函数，[声音] ，把它扔到这里。
Instead, it's just grabbing that function,
[SOUND], throwing it out here.

182
00:10:19.731 --> 00:10:24.368
是什么规则使得它在排队之后,
What is the rule by which after it's
been sitting in the queue, queued up,

183
00:10:24.368 --> 00:10:29.279
准备运行，通过这种方式它被允许从队列中到调用堆栈上。
ready to run, by which it's allowed
out of that queue onto the call stack.

184
00:10:29.279 --> 00:10:30.181
有人能猜出来吗？
Can anyone take a guess?

185
00:10:30.181 --> 00:10:31.224
大概分为两部分。
There's sort of two parts to it.

186
00:10:31.224 --> 00:10:32.471
是的，说吧，马特。
Yeah, go ahead, Matt.

187
00:10:32.471 --> 00:10:34.941
当当前运行的执行上下文完成时。
&gt;&gt; off screen male: When the execution
context currently running is complete.

188
00:10:34.941 --> 00:10:41.750
威尔 · 森特斯: 绝对是，所以如果你在调用堆栈上有任何东西，就必须离开。
&gt;&gt; Will Sentance: Absolutely, so if you've
got any on the call stack, gotta be gone.

189
00:10:41.750 --> 00:10:43.350
但不仅如此。
But it's more than that.

190
00:10:43.350 --> 00:10:44.750
太严格了。
It's so strict.

191
00:10:44.750 --> 00:10:45.799
是的，凯拉。
Yeah, Kayla.

192
00:10:45.799 --> 00:10:48.049
银幕外的女性: 全球执行环境必须完成。
&gt;&gt; off screen female: The global
execution context has to be done.

193
00:10:48.049 --> 00:10:52.559
Will Sentance: 它实际上是所有的同步代码，所有的常规执行。
&gt;&gt; Will Sentance: It's in fact all
synchronous code, all regular execution.

194
00:10:52.559 --> 00:10:57.154
也就是说你有可能正如 Kayla 所说,
Meaning you could have,
which is exactly what Kayla's saying,

195
00:10:57.154 --> 00:11:01.344
你可以有一百万根木头，排成一行。
you could literally have
a million console.logs in a row.

196
00:11:01.344 --> 00:11:05.157
你可以有一个 console.log 的无限 while 循环，并且
You could have an infinite
while loop of console.log, and

197
00:11:05.157 --> 00:11:08.269
队伍永远不会让 printHello 退队。
the queue would never dequeue printHello.

198
00:11:08.269 --> 00:11:11.889
它甚至不会抓取它并将其放到调用堆栈上。
It would never even grab it and
put it on the call stack.

199
00:11:11.889 --> 00:11:15.613
对我来说我承认当我第一次意识到,
And that, to me, I will admit,
when I first realized that,

200
00:11:15.613 --> 00:11:17.224
我得去看看。
I had to go and check that.

201
00:11:17.224 --> 00:11:22.299
我简直不敢相信你真的，真的有一百万块圆木。
I couldn't believe you could literally,
literally have a million console.logs.

202
00:11:22.299 --> 00:11:24.980
而且他们都会在任何事情被排除在队伍之外之前跑掉。
And they would all run before
anything was out of the queue.

203
00:11:24.980 --> 00:11:26.389
这听起来很疯狂，但是
That seems insane, but

204
00:11:26.389 --> 00:11:32.659
它实际上让我们能够确定，我们的代码何时会用完一个队列。
it actually allows us to be certain of
when our code will run out of a queue.

205
00:11:32.659 --> 00:11:38.419
这可能不是我所知道的那个时刻的意义上的确定。
It may not be the certain in
the sense of I know the moment.

206
00:11:38.419 --> 00:11:39.250
但我知道顺序。
But I do know the order.

207
00:11:40.259 --> 00:11:44.970
所有常规代码将首先运行，直到我碰到队列中的任何东西,
All regular code will run first until
I ever touch anything from the queue,

208
00:11:44.970 --> 00:11:46.429
直到我把任何东西从队列中拿出来。
until I ever put anything
out of the queue.

209
00:11:47.720 --> 00:11:50.889
那么，JavaScript 是如何实现的呢？
So, how does JavaScript implement that?

210
00:11:50.889 --> 00:11:54.879
嗯，它有一个小小的特点，非常深刻的特点。
Well, it has a little tiny feature,
very profound feature.

211
00:11:54.879 --> 00:11:57.240
但实际上它只能做一件事,
But really, it just does this one thing,

212
00:11:57.240 --> 00:12:01.340
也就是说在每行代码运行之前我都要检查。
which says I'm gonna check before
every single line of code run.

213
00:12:01.340 --> 00:12:03.580
调用堆栈是空的吗？
Is the call stack empty?

214
00:12:03.580 --> 00:12:05.190
调用堆栈是空的吗？
Is the call stack empty?

215
00:12:05.190 --> 00:12:06.389
有什么事情在排队吗？
Is there something in the queue?

216
00:12:06.389 --> 00:12:09.460
如果调用堆栈不是空的，如果还有其他全局代码要运行，如果
If the call stack is not empty, if there's
still further global code to run, if

217
00:12:09.460 --> 00:12:13.929
还有更多的全局代码要运行，那么我甚至不会去查看队列。
there's still further global code to run,
then I will not even go look at the queue.

218
00:12:13.929 --> 00:12:15.909
但如果调用堆栈是空的或
But if the call stack's empty or

219
00:12:15.909 --> 00:12:20.789
如果我下到队列，我抓住函数，把它放在调用堆栈上。
if I head down to the queue, I grab
the function, I put it on the call stack.

220
00:12:20.789 --> 00:12:24.039
这个被称为小特征的东西是什么？
And what is that known
as that little feature?

221
00:12:24.039 --> 00:12:27.269
这个小功能可以非常非常快速地检查
That little feature that does the very,
very fast checking

222
00:12:27.269 --> 00:12:30.029
每一行代码运行之前，它都会检查。
every single line before it runs
any line of code, it checks.

223
00:12:30.029 --> 00:12:31.610
调用堆栈上有什么东西吗？
Is there anything on the call stack?

224
00:12:31.610 --> 00:12:32.868
如果有的话，就去做吧。
If there is, just do it.

225
00:12:32.868 --> 00:12:34.909
还有什么东西在全局运行吗，快点。
Is there anything left running global,
do it.

226
00:12:34.909 --> 00:12:38.720
如果都完成了，就去排队。
If it's all finished,
head down to the queue.

227
00:12:38.720 --> 00:12:44.881
这个特性被称为事件，Will Sentance: Loop。
And that feature is known as the Event,
&gt;&gt; Will Sentance: Loop.

228
00:12:44.881 --> 00:12:48.433
而它的工作就是非常简单地不断地快速检查。
And it's job is simply to very
quickly be checking constantly.

229
00:12:48.433 --> 00:12:49.267
调用堆栈是空的吗？
Is the call stack empty?

230
00:12:49.267 --> 00:12:50.131
还有什么要排队的吗？
Is there anything in the queue?

231
00:12:50.131 --> 00:12:50.982
调用堆栈是空的吗？
Is the call stack empty?

232
00:12:50.982 --> 00:12:51.831
还有什么要排队的吗？
Is there anything in the queue?

233
00:12:51.831 --> 00:12:53.255
是否有任何全局代码要运行？
Is there any global code to run?

234
00:12:53.255 --> 00:12:56.289
不，我终于可以下去了。
No, finally I get to go down.

235
00:12:56.289 --> 00:13:00.841
所以我的事件循环始终，是调用堆栈在 blockFor1Sec 为空,
So my event loop throughout goes,
is the call stack empty at blockFor1Sec,

236
00:13:00.841 --> 00:13:01.616
所有人？
everybody?

237
00:13:01.616 --> 00:13:02.384
男: 没有 威尔 · 森特斯: 不,
&gt;&gt; off screen male: No.
&gt;&gt; Will Sentance: No,

238
00:13:02.384 --> 00:13:05.671
我们还是得在1秒内跑完。
we stil got to run in blockFor1Sec.

239
00:13:05.671 --> 00:13:09.971
在1,001毫秒时，还有更多的全局代码需要运行吗？
At 1,001 milliseconds,
is there further global code still to run?

240
00:13:09.971 --> 00:13:10.845
男: 是的 威尔 · 森坦斯: 是的，所以
&gt;&gt; off screen male: Yes.
&gt;&gt; Will Sentance: Yeah, so

241
00:13:10.845 --> 00:13:12.659
事件循环，不，你不能。
the event loop goes, no, you can't.

242
00:13:13.690 --> 00:13:18.340
最后，当所有全局代码运行完毕后，会发生什么？
Finally, when all global code is
finished running, what happens?

243
00:13:18.340 --> 00:13:23.659
它走向队列，它说，是的，我已经准备好进入队列。
It heads down to the queue, it goes, yes,
I'm ready to head down into the queue.

244
00:13:23.659 --> 00:13:27.028
它抓住 printHello，并且它位于调用堆栈上并执行它。
It grabs printHello, and
it sits on the call stack and executes it.

245
00:13:27.028 --> 00:13:31.938
它为我们放上插入语，没有问题，并运行了 printHello。
It puts the parenthesis on for us,
no problem and runs printHello.

246
00:13:31.938 --> 00:13:39.279
对于这个问题，直到他有了6个，就是异步 JavaScript 的整个模型。
And for that until he has six was the
entire model of Asynchronous JavaScript.

247
00:13:39.279 --> 00:13:42.926
因此，让我们对这个概念，我们已经保存了我们的功能
So let's have thumbs on this notion
that we have saved our functions for

248
00:13:42.926 --> 00:13:44.278
1sec 的另一个区块。
another blockFor1Sec.

249
00:13:44.278 --> 00:13:47.374
我们使用 setTimeout 来触发计时器,
We use setTimeout to trigger a timer,

250
00:13:47.374 --> 00:13:52.139
一个相关的 printHello 函数被传递给它。
an associated printHello
function was passed to it.

251
00:13:52.139 --> 00:13:55.019
是的，它说0毫秒，直到这个函数可以运行。
Yes, it said 0 milliseconds until
that function could be run.

252
00:13:55.019 --> 00:13:57.210
但是我们现在知道这到底意味着什么呢？
But what do we now know that really means?

253
00:13:57.210 --> 00:14:00.720
这意味着它是0毫秒，直到这个函数被放入,
It means that it's 0 milliseconds
until that function is put into the,

254
00:14:00.720 --> 00:14:04.490
正如彼得所暗示的，加入了回调队伍。
exactly as Peter's hinting,
into the callback queue.

255
00:14:04.490 --> 00:14:08.160
然后我们所有的全局代码都会继续运行，不管需要多长时间。
And then all our global code's gonna
continue running, however long it takes.

256
00:14:08.160 --> 00:14:14.158
当一切都结束时事件循环就开始了,
And when it's all done,
then the event loop goes,

257
00:14:14.158 --> 00:14:18.076
万岁，调用堆栈完成了。
hooray, the Call Stack is done.

258
00:14:18.076 --> 00:14:21.798
所有的全局沿海地区都完成运行，我们从回调队列中获取并
All global coast finish running, and
we grab from the Callback Queue and

259
00:14:21.798 --> 00:14:23.570
将 printHello 放入调用堆栈。
put printHello in the Call Stack.
