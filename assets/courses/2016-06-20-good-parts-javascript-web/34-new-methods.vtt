WEBVTT

1
00:00:00.000 --> 00:00:03.906
[音乐]
[MUSIC]

2
00:00:03.906 --> 00:00:06.945
&gt；&gt；Douglas Crockford：我们添加了很多新方法，因为新方法允许我们
&gt;&gt; Douglas Crockford: We added a lot of new methods because new methods allow us

3
00:00:06.945 --> 00:00:10.051
在没有新语法的情况下提供新功能，因此
to provide new functionality without new syntax, and so

4
00:00:10.051 --> 00:00:13.390
那是大部分注意力都去了的地方。
that's where most of the attention went.

5
00:00:13.390 --> 00:00:15.547
&gt；&gt；Douglas Crockford：我们增加了function.bind，
&gt;&gt; Douglas Crockford: We added function.bind,

6
00:00:15.547 --> 00:00:20.986
这是jQuery一直在推广的东西，它允许您
which was something that jQuery has been promoting that allows you to

7
00:00:20.986 --> 00:00:26.074
将方法转换为函数，以便可以将其用作回调。
turn a method into a function so that you can use it as a callback.

8
00:00:26.074 --> 00:00:31.001
我们添加了string.trim，所以现在我们有了一个方法，它将删除
We added string.trim, so we now have a method which will remove

9
00:00:31.001 --> 00:00:34.710
字符串中的多余空格。
the extraneous whitespace from a string.

10
00:00:34.710 --> 00:00:37.679
这应该从第一天起就出现在语言中，对吗？
This should have been in the language from day one, right?

11
00:00:37.679 --> 00:00:40.130
只是，它不应该花这么长时间才得到它。
And it's just, it shouldn't have taken this long to get that.

12
00:00:41.530 --> 00:00:44.140
我们有-&gt；&gt；扬声器2：两边都要修剪吗？
We've got- &gt;&gt; Speaker 2: Does it trim on both sides?

13
00:00:44.140 --> 00:00:45.304
&gt；&gt；Douglas Crockford：它会修剪两边。
&gt;&gt; Douglas Crockford: It trims both sides.

14
00:00:45.304 --> 00:00:46.607
&gt；&gt；扬声器2：好的。&gt；&gt；Douglas Crockford：我们没有打架
&gt;&gt; Speaker 2: Okay. &gt;&gt; Douglas Crockford: We didn't fight

15
00:00:46.607 --> 00:00:49.457
有足够的需求去做个人，左派和
enough demands to do the individuals, the left and

16
00:00:49.457 --> 00:00:53.182
正确的版本，我还没有听到任何人抱怨它。
right versions, and I haven't heard anybody complain about it.

17
00:00:53.182 --> 00:00:58.926
如果有人知道，也许我们可以进入他的。
If anybody does, maybe we could get into his.

18
00:00:58.926 --> 00:01:01.829
&gt；&gt；扬声器3：那么，你调整修剪，现在，它是这样做的吗，
&gt;&gt; Speaker 3: So, you adjust the trim, and, now, is that what it's doing,

19
00:01:01.829 --> 00:01:07.799
或者它实际上只是更多的JS，或者它是在较低的级别中编写的？
or it's actually just more JS, or is it written in a lower level?

20
00:01:07.799 --> 00:01:10.414
&gt；&gt；Douglas Crockford：这取决于实现，
&gt;&gt; Douglas Crockford: It depends on the implementation,

21
00:01:10.414 --> 00:01:13.121
它可以写在更低的层次上。
it could be written in a lower level.

22
00:01:13.121 --> 00:01:15.888
所以，这被称为聚脂填充物，也被称为猴子补丁。
So, this is called poly filling, it's also been called monkey patching.

23
00:01:15.888 --> 00:01:21.563
它允许你在系统中插入代码，所以当Brendan最初
It allows you to insert code into the system, so when Brendan originally

24
00:01:21.563 --> 00:01:26.879
设计语言的时候，他只有10天的时间来做这个原型。
designed the language, he only had 10 days to do this prototype.

25
00:01:26.879 --> 00:01:32.150
他被告知，或者他期望如果他的演示不起作用
He was told that, or he expected that if his demo didn't work

26
00:01:32.150 --> 00:01:34.640
网景会做一些更愚蠢的事情。
that Netscape would have done something much stupider.

27
00:01:35.870 --> 00:01:38.650
我不知道那会是什么，我无法想象那会是什么
I don't know what it would have been, I can't imagine what that would have been

28
00:01:38.650 --> 00:01:42.280
但那是他的[INAUDIBLE]所以他只有10天。
but that was his [INAUDIBLE] so he only had 10 days.

29
00:01:42.280 --> 00:01:47.170
他很有信心他不会在十天内把所有的事情都做好，
And he was pretty confident that he wasn't going to get everything right in ten days,

30
00:01:47.170 --> 00:01:50.280
但他们可能需要在现场做些调整。
but they're probably gonna need to be some tweaks in the field.

31
00:01:50.280 --> 00:01:54.859
所以，他把几乎所有的东西都暴露在地块上。
So, he left almost everything exposed on lot.

32
00:01:56.229 --> 00:02:00.819
所以，用正确设计的语言的东西会被锁定或者
So, things which in a properly designed language would be locked down or

33
00:02:00.819 --> 00:02:01.829
完全开放。
completely open.

34
00:02:01.829 --> 00:02:04.609
因此，您可以将内容添加到object.prototype，用于
So, you can add things to object.prototype, for

35
00:02:04.609 --> 00:02:06.769
例如，用真正的语言。
example, in a real language.

36
00:02:06.769 --> 00:02:09.289
你甚至看不到物体原型，
You shouldn't even be able to see object.prototype,

37
00:02:09.289 --> 00:02:12.159
你知道所有的东西都应该密封。
you know all that stuff should be sealed.

38
00:02:12.159 --> 00:02:15.639
他这样做，可能是正确的，因为他认为
And he did that, probably correctly, because he figured

39
00:02:15.639 --> 00:02:18.579
他没有把每件事都做好，总有一天人们会需要修补
he didn't get everything right and someday people were going to need to patch

40
00:02:18.579 --> 00:02:24.259
实时系统，以便使其工作，这正是发生了什么。
the system in real time in order to make it Work which is exactly what happened.

41
00:02:24.259 --> 00:02:29.780
所以在暴露的语言中有所有这些东西，包括这个。
So there's all this stuff in the language which is exposed including this.

42
00:02:31.139 --> 00:02:36.680
如果您获取此代码并在IE 6浏览器或IE 7或IE 8浏览器上运行它。
If you take this code and run it on an IE 6 browser or IE 7 or IE 8 browser.

43
00:02:36.680 --> 00:02:42.150
然后，他们将以与IE 10相同的方式工作，尊重修剪。
Then they will work the same way as IE ten with respect as trim.trim.

44
00:02:42.150 --> 00:02:45.079
现在IE 10可能有它自己的实现它可能是
Now IE ten might have its own implementation of this it might be

45
00:02:45.079 --> 00:02:47.969
本机实现，因此它可能运行得更快。
a native implementation so it might run faster.

46
00:02:47.969 --> 00:02:50.479
所以这个版本IE慢了六个月。
So this version IE six months slower.

47
00:02:50.479 --> 00:02:52.530
我认为这很好，这就是它应该是什么样子
I think that's great that's exactly how it should be

48
00:02:56.710 --> 00:03:01.180
我们添加了一组大的新的or数组方法和
We added a large new set of or array methods and

49
00:03:01.180 --> 00:03:04.280
我真的很喜欢这些设计方法并不完美，但在那里。
I really like these methods of design wasn't perfect but there.

50
00:03:04.280 --> 00:03:10.800
它们足够好，我们可以使用它们，所以大多数这些都是以相同的方式工作的
They're good enough that we can use these so most of these work the same way in that

51
00:03:10.800 --> 00:03:15.819
您将在数组上传递调用一个方法，并传入一个函数和
you'll pass Call a method on an array and pass in a function and

52
00:03:15.819 --> 00:03:20.659
将为数组的每个元素调用该函数，并且
that function will get called for each element of the array and

53
00:03:20.659 --> 00:03:25.289
事情会根据你提供的方法发生。
things will happen based on what method you provide.

54
00:03:25.289 --> 00:03:30.259
因此each方法将继续执行该行为，直到一个函数
So the every method will keep doing that behavior until a function

55
00:03:30.259 --> 00:03:34.500
返回FALSE，当函数返回FALSE时，它会停止这样做。
returns false and when a function returns false then it stops doing that.

56
00:03:34.500 --> 00:03:38.560
这样就可以循环
So that allows you to loop for

57
00:03:38.560 --> 00:03:43.009
一个时间，然后跳出类似于break可能在for循环中所做的事情。
a time and then bail out similar to what break might be doing in a for loop.

58
00:03:45.870 --> 00:03:49.189
筛选器将接受所有返回值。
Filter will take all of the return values.

59
00:03:49.189 --> 00:03:50.829
如果返回值为真，
If the return value is true,

60
00:03:50.829 --> 00:03:55.020
然后将数组的原始元素复制到新数组中。
then the original element of the array will be copied into a new array.

61
00:03:55.020 --> 00:03:56.810
因此，它允许您采用更大的阵列
So it allows you to take a bigger array and

62
00:03:56.810 --> 00:04:00.050
根据每个元素的情况生成一个较小的数组。
produce a smaller array based on what happens for each element.

63
00:04:01.710 --> 00:04:03.729
for each是取代for的东西
For each is the thing that replaces a for

64
00:04:03.729 --> 00:04:07.379
循环它只是去访问每一个我喜欢的元素。
loop it just goes and visits every element I like for each.

65
00:04:08.419 --> 00:04:12.349
IndexOf将执行搜索，因此您可以在类似于以下内容的数组中进行搜索
IndexOf will do a search, so you can do a search in an array similar to

66
00:04:12.349 --> 00:04:18.300
您可以对字符串执行的搜索Last of Searches，即来自后端的数组。
the searching you can do on strings Last of searches, the array from the back end.

67
00:04:19.980 --> 00:04:21.790
地图可能是其中最强大的
Map is maybe the most powerful of them,

68
00:04:21.790 --> 00:04:27.240
它将从该函数获取每个返回值，并将其存储到一个新数组中。
it will take every return value from that function and store it into a new array.

69
00:04:27.240 --> 00:04:29.240
所以你可以做转换和
So you can do transformations and

70
00:04:29.240 --> 00:04:32.449
你可以用地图做选择和很多新的东西。
you can do selections and lots of new things using map.

71
00:04:34.889 --> 00:04:40.040
Reduce将接受一个数组并将其减少到单个值，并且
Reduce will take in an array and reduce it down to a single value, and

72
00:04:40.040 --> 00:04:45.310
它会这样做，你向它传递一个函数，该函数被调用
it'll do that by, you pass it a function that function gets called for

73
00:04:45.310 --> 00:04:48.240
数组中的值对。
pairs of values from the array.

74
00:04:48.240 --> 00:04:53.540
例如，如果您将add函数传递给reduce，您将得到一个总计函数。
For example if you pass the add function to reduce, you'll get a total function.

75
00:04:53.540 --> 00:04:57.490
如果你传递一个乘法函数来归约，你会得到一个乘积函数
If you pass a multiply function to reduce you'll get a product function

76
00:04:59.290 --> 00:05:02.170
然后是从另一个减少的还原权
then there is reduce right which reduces from the other

77
00:05:02.170 --> 00:05:05.170
在数组的末尾，我没有找到任何原因。
end of the array I've not found any reason for that.

78
00:05:05.170 --> 00:05:08.449
我不知道我们为什么这么做，但它就在里面。
I don't know why we did that, but it's in there.

79
00:05:10.110 --> 00:05:16.237
除使用相反的布尔值外，一些与EVER相似。
Some is similar to every except it uses the opposite boolean value.

80
00:05:16.237 --> 00:05:20.370
我们添加了日期现在。
We added Date.now.

81
00:05:20.370 --> 00:05:21.850
以前也是，
So it used to be,

82
00:05:21.850 --> 00:05:24.889
如果你想得到实时时钟，你就必须这样做。
if you wanted to get the real time clock you'd have to do what this is doing.

83
00:05:24.889 --> 00:05:28.730
您将使用默认配置创建一个新的Date对象，并且
You would make a new Date object with the default configuration and

84
00:05:28.730 --> 00:05:30.680
然后提取它的时间。
then extract its time.

85
00:05:30.680 --> 00:05:34.970
所以通常当你得到时间的时候，是因为你想要测量一些东西
So usually when you're getting the time it's because you want to measure something

86
00:05:34.970 --> 00:05:39.779
但是这个获取时间的过程增加了很多延迟和
But this process of getting access to the time adds a lot of latency and

87
00:05:39.779 --> 00:05:43.769
所以你现在可以直接打电话给Date
so you can now call date now directly and

88
00:05:43.769 --> 00:05:46.240
它会给你实时时钟的当前值。
it'll give you the current value of the real time clock.

89
00:05:46.240 --> 00:05:50.120
现在浏览器仍然增加了很多延迟和
Now browsers still add a lot of latency and

90
00:05:50.120 --> 00:05:52.220
操作系统也会增加很多延迟。
operating systems also add a lot of latency.

91
00:05:52.220 --> 00:05:56.560
所以这并不能证明这确实做得更好，但是
So it's not proven that this actually does a better job but But

92
00:05:56.560 --> 00:05:58.629
这并不是JavaScript的错。
it's not so much JavaScript's fault.

93
00:05:58.629 --> 00:06:01.000
现在情况变得更好了
now so that's gotten better

94
00:06:03.300 --> 00:06:08.100
当第一个标准问世时，Netscape和微软不能
when the first standard was made Netscape and Microsoft could not

95
00:06:08.100 --> 00:06:13.439
就描述数据解析工作方式的标准中的语言达成一致。
agree on the language in the standard for describing how date parsing works.

96
00:06:13.439 --> 00:06:16.009
有一个日期构造函数可以接受字符串并
There's a date constructor that can take a string And

97
00:06:16.009 --> 00:06:20.029
然后它可以尝试将该字符串转换为Date、Object。
it can then attempt to turn that string into a date, object.

98
00:06:20.029 --> 00:06:22.740
但他们无法就如何工作的细节达成一致。
But they couldn't agree on the details for how that worked.

99
00:06:22.740 --> 00:06:25.350
所以不是正确的，
So instead incorrectly,

100
00:06:25.350 --> 00:06:29.850
他们同意不同意，完全没有具体说明。
they agreed to disagree by leaving it completely unspecified.

101
00:06:29.850 --> 00:06:33.560
所以没有标准的语言可以向你保证
So there is no language of the standard that gives you a guarantee that

102
00:06:33.560 --> 00:06:36.409
如果您在此表单上传递，则它将解析。
if you pass at this form then it will parse.

103
00:06:36.409 --> 00:06:38.279
这是一种不好的。
Which is kind of bad.

104
00:06:38.279 --> 00:06:42.670
从那时起，ISO提出了一种国际日期格式，
Now since then, ISO has come up with an international date format,

105
00:06:42.670 --> 00:06:43.500
这是相当不错的。
which is pretty nice.

106
00:06:43.500 --> 00:06:46.939
有时称为ISO文本、ISO日期或ISO字符串。
Sometimes called ISO texts,ISO dates or ISO strings.

107
00:06:48.300 --> 00:06:51.840
你有一年，然后是破折号，然后是一个月和一个破折号，以此类推。
Which you have a year then a dash, then a month and a dash and so on.

108
00:06:51.840 --> 00:06:55.790
因此，Date对象现在将生成该形式的字符串。
So the date object will now produce strings in that form.

109
00:06:57.120 --> 00:07:02.730
并且现在保证日期解析器接受该格式。
And the date parsers are now guaranteed to accept that form.

110
00:07:02.730 --> 00:07:06.910
因此，我们现在至少有一种保证可以接受的日期格式。
So we now have at least one date format which is guaranteed to be acceptable.

111
00:07:07.959 --> 00:07:09.949
所以这是我们要尝试的第一个。
So this is the first one we'll try.

112
00:07:09.949 --> 00:07:14.560
如果那个失败了，那么他们将退回到未明确说明的专有产品上。
If that one fails, then they'll fall back on the under-specified proprietary ones.

113
00:07:14.560 --> 00:07:17.490
但至少有一个可以保证奏效。
But at least there's one that's guaranteed to work.

114
00:07:17.490 --> 00:07:18.569
&gt；&gt；演讲者2：关于这两个人的问题。
&gt;&gt; Speaker 2: Question about those two.

115
00:07:18.569 --> 00:07:19.089
&gt；&gt；Douglas Crockford：是的。
&gt;&gt; Douglas Crockford: Yeah.

116
00:07:19.089 --> 00:07:22.160
&gt；&gt；扬声器2：所以在此之前的ISO格式幻灯片。
&gt;&gt; Speaker 2: So the ISO format slide before this.

117
00:07:22.160 --> 00:07:28.040
所有东西都是UTC时间，而在此之前只有一次，
Everything was getting UTC times whereas just one before so,

118
00:07:28.040 --> 00:07:29.139
如果你做两个ISO字符串。
if you do two ISO string.

119
00:07:29.139 --> 00:07:32.060
你会得到所有基于UTC时间的东西。
You're gonna get everything based on the UTC time.

120
00:07:32.060 --> 00:07:35.533
如果你是datetime.now，你会得到服务器时间吗？
If you datetime.now, are you gonna get server time?

121
00:07:37.483 --> 00:07:42.840
&gt；&gt；Speaker 2：或运行代码的机器认为它是的时间。
&gt;&gt; Speaker 2: Or the time that the machine that the code is running on thinks it is.

122
00:07:45.829 --> 00:07:48.110
&gt；&gt；Speaker 3：您得到一个数据对象，它是UTC。
&gt;&gt; Speaker 3: You get a data object which is UTC.

123
00:07:48.110 --> 00:07:51.870
&gt；&gt；Douglas Crockford：是的，在数据对象上，有一些基本的时间。
&gt;&gt; Douglas Crockford: Yeah at the data object have some fundamental time.

124
00:07:51.870 --> 00:07:52.769
&gt；&gt；扬声器2：好的。&gt；&gt；Douglas Crockford：那是独立的
&gt;&gt; Speaker 2: Okay. &gt;&gt; Douglas Crockford: That's independent

125
00:07:52.769 --> 00:07:55.250
当前时区的位置都是正确的。
of the current time zone are situated right.

126
00:07:55.250 --> 00:07:56.137
&gt；&gt；扬声器2：好的。&gt；&gt；Douglas Crockford：所以你得到了
&gt;&gt; Speaker 2: Okay. &gt;&gt; Douglas Crockford: So you're getting

127
00:07:56.137 --> 00:07:56.870
核心价值。
that that core value.

128
00:07:56.870 --> 00:07:57.380
&gt；&gt；扬声器2：好的。谢谢你。
&gt;&gt; Speaker 2: Okay. Thank you.

129
00:08:00.100 --> 00:08:03.480
&gt；&gt；Douglas Crockford：我们将array.isArray添加到我们尝试使用的语言中
&gt;&gt; Douglas Crockford: We added array.isArray to the language we tried to

130
00:08:03.480 --> 00:08:08.668
固定类型的，不能有太多的在网络上是依赖的
fix type of and couldn't that there was too much on the web that was dependent on

131
00:08:08.668 --> 00:08:13.935
SO的破碎行为类型相反，我们添加了这个可怕的丑陋的东西，但是
the broken behavior type of so instead we added this horrendously ugly thing but

132
00:08:13.935 --> 00:08:18.338
至少我们学到了这种语言，布兰登实际上已经计算过了
at least we got into that language And Brendan had actually counted

133
00:08:18.338 --> 00:08:22.310
击键，这比表单的类型小。
the keystrokes and this is smaller than the type of form.

134
00:08:22.310 --> 00:08:24.839
所以即使我看起来更糟，它实际上也小了一点。
So even I looks a lot worse, it's actually a little bit smaller.

135
00:08:26.470 --> 00:08:30.990
我设法添加了对象点键，这将给你一个枚举
I managed to add object dot keys which will give you an enumeration of

136
00:08:30.990 --> 00:08:34.549
对象的所有OwnProperty。
all of the Ownproperties of an object.

137
00:08:34.549 --> 00:08:37.340
因此您不会获得继承的方法名称。
So you don't get the inherited method names.

138
00:08:37.340 --> 00:08:41.440
你只得到你可能是的数据成员
You only get the data members which are the thing that you're probably

139
00:08:41.440 --> 00:08:42.769
最关心的是。
most concerned with.

140
00:08:42.769 --> 00:08:45.690
它以数组的形式返回它，这意味着您可以执行
And it returns it in the form of an array which means you can then do for

141
00:08:45.690 --> 00:08:47.940
每一个都在上面，所以这是相当不错的。
each on it and so that's pretty nice.

142
00:08:49.509 --> 00:08:50.679
&gt；&gt；发言人4：这是你提出的吗？
&gt;&gt; Speaker 4: You proposed that?

143
00:08:50.679 --> 00:08:52.730
&gt；&gt；Douglas Crockford：是的，我提出的。
&gt;&gt; Douglas Crockford: Yeah I proposed that.

144
00:08:52.730 --> 00:08:54.090
&gt；&gt；扬声器4：酷，我一直在用它
&gt;&gt; Speaker 4: Cool, I use that all the time and

145
00:08:54.090 --> 00:08:56.860
那么我确实喜欢.length，只是为了看看这个对象有多大。
then I do like .length just to see how big this object is.

146
00:08:56.860 --> 00:08:59.220
诸如此类的东西。
And stuff like that.

147
00:08:59.220 --> 00:08:59.870
&GT；&GT；道格拉斯·克罗克福德：不客气。&gt；&gt；类：[笑声]
&gt;&gt; Douglas Crockford: You're welcome. &gt;&gt; Class: [LAUGH]

148
00:08:59.870 --> 00:09:00.600
&gt；&gt；扬声器4：是的，很好。
&gt;&gt; Speaker 4: Yeah, sweet.

149
00:09:00.600 --> 00:09:04.990
&GT；&GT；演讲者3：你之前说过，一些，是一些吗？
&gt;&gt; Speaker 3: You were talking about earlier there, some, was it some?

150
00:09:04.990 --> 00:09:07.580
&gt；&gt；Douglas Crockford：是的。&gt；&gt；演讲者3：这有什么不同
&gt;&gt; Douglas Crockford: Yep. &gt;&gt; Speaker 3: How is that different

151
00:09:07.580 --> 00:09:08.509
而不是钥匙？
than keys?

152
00:09:08.509 --> 00:09:10.259
键是一个数组。
Keys is an array.

153
00:09:10.259 --> 00:09:12.120
&gt；&gt；Douglas Crockford：有些用于在数组上循环。
&gt;&gt; Douglas Crockford: Some is for looping on an array.

154
00:09:12.120 --> 00:09:13.350
这是每件事的反面。
It's the opposite of every.

155
00:09:14.529 --> 00:09:16.700
&gt；&gt；演讲者3：每个都给你所有的值，有些只给你一个。
&gt;&gt; Speaker 3: Every gives you all the values, some gives you only one.

156
00:09:16.700 --> 00:09:17.370
&gt；&gt；Douglas Crockford：每个都给你
&gt;&gt; Douglas Crockford: Every gives you

157
00:09:17.370 --> 00:09:19.519
只要函数返回true，一切都会发生。
everything as long as the functions are returning true.

158
00:09:21.429 --> 00:09:26.570
还有一些继续工作，只要一切都是假的。
And some keeps working as long as everything is returning false.

159
00:09:26.570 --> 00:09:28.299
&gt；&gt；扬声器3：它对值而不是键进行操作。
&gt;&gt; Speaker 3: It's operating on the values not the keys.

160
00:09:28.299 --> 00:09:31.690
&gt；&gt；Douglas Crockford：关于基于函数的返回值
&gt;&gt; Douglas Crockford: On the return values that are based on the function

161
00:09:31.690 --> 00:09:33.909
也就是处理密钥。
that is processing the keys.

162
00:09:33.909 --> 00:09:35.450
是啊。&GT；&GT；演讲者6：回到那里的日期，
Yes. &gt;&gt; Speaker 6: Back on the dates there,

163
00:09:35.450 --> 00:09:36.190
有一个问题。
there is a question.

164
00:09:36.190 --> 00:09:39.149
是否有针对可变日期对象的计划？
Are there any plans for mutable date objects?

165
00:09:39.149 --> 00:09:40.279
&gt；&gt；Douglas Crockford：不可变的日期对象？
&gt;&gt; Douglas Crockford: Immutable date objects?

166
00:09:40.279 --> 00:09:41.620
&GT；&GT；演讲者6：是的，我不知道他的意思是什么。
&gt;&gt; Speaker 6: Yeah I don't know what he means by that.

167
00:09:41.620 --> 00:09:45.429
&gt；&gt；Douglas Crockford：我们将要冻结你可以冻结任何日期对象
&gt;&gt; Douglas Crockford: We're going to get to freeze you can freeze any date object

168
00:09:45.429 --> 00:09:48.659
这是他想要的吗？
is that what he wants?

169
00:09:48.659 --> 00:09:49.159
&gt；&gt；扬声器6：我等着呢。
&gt;&gt; Speaker 6: I'm waiting.

170
00:09:50.179 --> 00:09:53.320
我只是想要求澄清请继续。
I'm just going to ask for clarification just go on.

171
00:09:53.320 --> 00:09:58.100
&gt；&gt；Douglas Crockford：我还设法获得object dot create Object.create
&gt;&gt; Douglas Crockford: I also managed to get object dot create Object.create

172
00:09:58.100 --> 00:10:02.399
是使新对象继承自另一个对象的基元。
is the primitive which makes a new object that inherits from another object.

173
00:10:02.399 --> 00:10:06.129
在原型语言中，这应该从第一天起就在语言中。
In a prototypal language, this should have been in the language from day one.

174
00:10:06.129 --> 00:10:11.039
所以我们用新的和.原型的奇怪的东西，
So instead we had the weird thing with new and .prototype.,

175
00:10:11.039 --> 00:10:15.590
所以这给我们提供了一种直接的方式来进行原型继承，这是很好的。
so this gives us a direct way of doing prototype inheritance, which is good.
