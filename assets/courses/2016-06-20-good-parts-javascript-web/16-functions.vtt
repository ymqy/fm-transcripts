WEBVTT

1
00:00:00.000 --> 00:00:04.030
[音乐]
[MUSIC]

2
00:00:04.030 --> 00:00:07.219
&gt；&gt；道格拉斯：所以第三幕，功能终极。
&gt;&gt; Douglas: So Act III, function the ultimate.

3
00:00:07.219 --> 00:00:09.650
你一直在想我们什么时候才能说到好的部分，对吧？
You've been wondering when are we gonna get to the good parts, right?

4
00:00:09.650 --> 00:00:12.660
因为到目前为止一切都很可怕，对吧？
Because everything's been pretty horrible up until now, right?

5
00:00:12.660 --> 00:00:14.050
这不是有点悲剧吗？
Hasn't this been kind of tragic?

6
00:00:15.480 --> 00:00:17.609
所以我们会找到一些好的部分
So we're gonna get to some good parts and

7
00:00:17.609 --> 00:00:20.839
JavaScript中好的部分都围绕着函数。
the good parts in JavaScript all wrap around the function.

8
00:00:22.329 --> 00:00:25.829
函数真的是一些功能强大的东西。
Functions are really powerful bits of stuff.

9
00:00:25.829 --> 00:00:30.129
在其他语言中，您将拥有方法、类、构造函数和模块。
In other languages, you'll have methods, classes, constructors, modules.

10
00:00:30.129 --> 00:00:31.949
在JavaScript中，您所需要的就是函数。
In JavaScript all you need is functions.

11
00:00:31.949 --> 00:00:33.820
功能太强大了。
Functions are so powerful.

12
00:00:33.820 --> 00:00:36.060
他们可以做所有这些事情的工作，甚至更多。
They can do the work of all of those things and more.

13
00:00:36.060 --> 00:00:41.049
他们只是在为建造东西提供一种通用的东西。
They're just serving a universal stuff for building things.

14
00:00:42.170 --> 00:00:46.770
我们使用函数表达式或函数文字来构造函数。
We make functions using the function expression or function literal.

15
00:00:46.770 --> 00:00:49.960
它将返回一个新的Function对象，然后可以调用该对象。
It would return a new function object, which could then be invoked.

16
00:00:49.960 --> 00:00:54.750
函数表达式以单词function开头。
A function expression starts with the word function.

17
00:00:54.750 --> 00:00:56.450
然后它可以采用一个可选的名称，
It can then take an optional name,

18
00:00:56.450 --> 00:01:00.719
这允许您递归调用函数。
which allows you to call the function recursively.

19
00:01:00.719 --> 00:01:06.890
它还允许记录代码和堆栈跟踪等内容。
It also allows for documenting things like a code and stack traces.

20
00:01:06.890 --> 00:01:08.030
你给它传递参数，
You pass it parameters,

21
00:01:08.030 --> 00:01:12.980
这是一组用逗号分隔的名称，用括号括起来。
which are a set of names separated by commas wrapped in parens.

22
00:01:12.980 --> 00:01:17.939
它需要一个身体，这是一块用大括号包着的木块。
And it takes a body, which is a block wrapped in curly braces.

23
00:01:20.760 --> 00:01:23.840
函数表达式生成函数对象的实例。
A function expression produces an instance of a function object.

24
00:01:23.840 --> 00:01:26.900
每次对表达式求值时
And every time that expression gets evaluated

25
00:01:26.900 --> 00:01:29.000
您将获得一个新的函数对象。
you'll get a new function object.

26
00:01:29.000 --> 00:01:30.710
函数对象是第一类，
Function objects are first class,

27
00:01:30.710 --> 00:01:33.700
这意味着它们可以作为参数传递给函数。
which means they can be passed as arguments to functions.

28
00:01:33.700 --> 00:01:37.329
它们可以从函数返回，可以为它们赋值一个变量，并且
They can be returned from functions, they may be assigned a variables, and

29
00:01:37.329 --> 00:01:39.379
它们可以存储在对象和数组中。
they may be stored in objects and arrays.

30
00:01:39.379 --> 00:01:43.930
这与语言中的函数有很大的不同
This is very different than in languages where functions are sort of

31
00:01:43.930 --> 00:01:48.500
静态的东西，只是在程序开始之前就存在了。
the static things, which just kind of exist before the program starts.

32
00:01:48.500 --> 00:01:49.069
在JavaScript中，
In JavaScript,

33
00:01:49.069 --> 00:01:54.189
函数运行并在编译时向环境中添加内容。
the functions run and add things to the environment as they're compiled.

34
00:01:54.189 --> 00:01:57.319
而且因为函数是对象，所以它们是从函数而不是原型继承的。
And because functions are objects they inherit from function not prototype.

35
00:02:00.060 --> 00:02:04.650
我们使用var语句声明和初始化函数中的变量。
We use the var statement to declare and initialize variables within functions.

36
00:02:04.650 --> 00:02:07.390
没有在var语句中指定类型。
You don't specify a type in the var statement.

37
00:02:07.390 --> 00:02:08.710
它可以接受任何类型。
It can accept any type.

38
00:02:09.900 --> 00:02:13.800
函数中任何地方声明的变量都是可见的
And variables declared anywhere within a function are visible

39
00:02:13.800 --> 00:02:15.810
函数中的任何地方。
everywhere within the function.

40
00:02:15.810 --> 00:02:21.123
所以我们没有var语句的块作用域，我们只有函数作用域。
So we don't have block scope with the var statement we only have function scope.

41
00:02:21.123 --> 00:02:26.682
因此，var语句做了一件非常奇怪的事情，它被分成两部分。
So, the var statement is does a really weird thing, it gets split into two parts.

42
00:02:26.682 --> 00:02:31.567
声明部分被提升到函数的顶部，其中变量
The declaration part gets hoisted to the top of the function where the variable

43
00:02:31.567 --> 00:02:33.789
使用undefined初始化。
gets initialized with undefined.

44
00:02:34.960 --> 00:02:39.490
初始化部分变成普通赋值语句。
And the initialization part turns into an ordinary assignment statement.

45
00:02:39.490 --> 00:02:44.655
这里我们得到var myVar=0，var myVar=
So here we've got var myVar = 0, var myVar =

46
00:02:44.655 --> 00:02:51.060
Undefined被提升到函数的顶部。
undefined gets hoisted to the top of the function.

47
00:02:51.060 --> 00:02:52.735
在看到最初的陈述时，
And at the sight of the original statement,

48
00:02:52.735 --> 00:02:55.510
我们得到一个普通的赋值语句，它进行初始化。
we get an ordinary assignment statement, which does initialization.

49
00:02:57.986 --> 00:02:59.930
&gt；&gt；Douglas：为了让事情更复杂，
&gt;&gt; Douglas: To make things more complicated,

50
00:02:59.930 --> 00:03:03.990
JavaScript具有函数语句或函数声明。
JavaScript has a function statement or a function declaration.

51
00:03:03.990 --> 00:03:07.169
不幸的是，它看起来与函数表达式完全相同。
Which unfortunately looks exactly like the function expression.

52
00:03:08.300 --> 00:03:11.870
它以单词function开头，在这种情况下，名称是必需的。
It starts with the word function in this case the name is mandatory.

53
00:03:11.870 --> 00:03:12.710
你不能忽略它。
You can't leave it out.

54
00:03:13.949 --> 00:03:16.759
它采用相同的参数和相同的身体。
It takes the same parameters and takes the same body.

55
00:03:16.759 --> 00:03:18.235
所以看起来和另一个一模一样。
So it looks exactly like the other one.

56
00:03:20.780 --> 00:03:25.990
function语句是具有函数值的var语句的简写。
The function statement is a shorthand for a var statement with a function value.

57
00:03:25.990 --> 00:03:30.710
所以函数foo展开为var foo=函数foo。
So function foo expands into var foo = function foo.

58
00:03:31.960 --> 00:03:37.882
并且由于提升到var foo=undefined和
And that further expands because of hoisting into var foo = undefined and

59
00:03:37.882 --> 00:03:39.620
foo=函数foo。
foo = function foo.

60
00:03:39.620 --> 00:03:41.640
这两个函数现在都被提升到函数的顶部。
Both of these now get hoisted to the top of the function.

61
00:03:43.352 --> 00:03:47.519
&gt；&gt；Douglas：正是因为这个第二次提升，语言才会这样做
&gt;&gt; Douglas: It's because of this second hoisting that the language does

62
00:03:47.519 --> 00:03:51.039
不允许您在if内声明函数。
not allow you to declare a function inside of an if.

63
00:03:52.329 --> 00:03:57.050
因为函数变量的赋值将被拉出
Because the assignment of the function variable is going to be pulled

64
00:03:57.050 --> 00:04:00.229
从f移到了顶端，所以这是非法的。
out of the f and moved to the top, so that's illegal.

65
00:04:01.460 --> 00:04:06.189
现在看来，大多数JavaScript引擎都允许您这样做。
Now it turns out most of the JavaScript engines allow you to do it anyway.

66
00:04:06.189 --> 00:04:08.460
但因为标准说你不能
But because the standard says you can't,

67
00:04:08.460 --> 00:04:11.685
他们对它的实际含义都有不同的看法。
they all have different opinions on what it actually means.

68
00:04:11.685 --> 00:04:13.507
我不建议这样做。
I don't recommend doing that.

69
00:04:16.305 --> 00:04:19.673
&gt；&gt；Douglas：所以既有函数表达式又有函数表达式真的很混乱
&gt;&gt; Douglas: So it's really confusing having both function expressions and

70
00:04:19.673 --> 00:04:23.610
函数语句，两者看起来完全相同。
function statements, which both look exactly the same.

71
00:04:23.610 --> 00:04:25.069
那你怎么区分它们？
So how do you tell them apart?

72
00:04:26.089 --> 00:04:27.980
这取决于你在哪里。
And it depends on where you are.

73
00:04:27.980 --> 00:04:33.180
如果语句的第一个标记是Function，则它是Function语句。
If the first token of a statement is function, then it is a function statement.

74
00:04:33.180 --> 00:04:36.584
如果function这个词出现在其他任何地方，它就是一个函数声明。
If the word function occurs anyplace else, it's a function declaration.

75
00:04:39.992 --> 00:04:42.822
&gt；&gt；Douglas：我们今天早上谈到了范围，
&gt;&gt; Douglas: So we talked this morning about scope,

76
00:04:42.822 --> 00:04:46.579
关于块作用域和函数作用域。
about block scope versus function scope.

77
00:04:46.579 --> 00:04:51.048
块作用域是一个非常常见的东西，函数作用域是一个非常不寻常的东西，
And block scope is a very common thing, function scope is a very unusual thing,

78
00:04:51.048 --> 00:04:53.863
这是JavaScript的var语句所特有的。
which is unique to JavaScript's var statement.

79
00:04:57.071 --> 00:05:01.016
&gt；&gt；Douglas：因此，函数范围是足够的，
&gt;&gt; Douglas: So and function scope is sufficient,

80
00:05:01.016 --> 00:05:05.810
但是函数作用域看起来像块作用域。
but function scope looks like block scope.

81
00:05:05.810 --> 00:05:08.870
或者至少语法与块范围语言相同，因此
Or at least the syntax is the same as block scope languages and so

82
00:05:08.870 --> 00:05:10.560
你会感到困惑。
you get confusion.

83
00:05:10.560 --> 00:05:15.740
所以在一些有块作用域的语言中，你可以做这样的蠢事。
So In some languages that have block scope, you can do stupid things like this.

84
00:05:15.740 --> 00:05:20.620
其中可以有两个使用相同变量名的循环
Where you can have two loops both using the same variable name

85
00:05:20.620 --> 00:05:22.470
作为他们的诱导变量。
as their induction variable.

86
00:05:22.470 --> 00:05:26.290
它起作用是因为在这些语言中，每一种语言都将是不同的
And it works because in those languages, each of these will be in a different

87
00:05:26.290 --> 00:05:29.310
范围，因此它们不会相互干扰。
scope, and so they won't interfere with each other.

88
00:05:29.310 --> 00:05:31.759
这是极其不明智的，但却是合法的。
It's extremely unwise but legal.

89
00:05:31.759 --> 00:05:33.759
在JavaScript中它也是非法的，但是
In JavaScript it is also illegal, but

90
00:05:33.759 --> 00:05:39.360
这比不明智还糟糕，因为这里只创建了一个i变量。
it's worse than unwise because there's only one i variable created here.

91
00:05:39.360 --> 00:05:42.000
两个循环将使用相同的i变量。
Both loops will be using the same i variable.

92
00:05:43.029 --> 00:05:46.042
所以他们会互相干扰得很厉害
And so they will interfere with each other really badly and

93
00:05:46.042 --> 00:05:48.202
此循环永远不会正确执行。
this loop will never correctly perform.

94
00:05:48.202 --> 00:05:51.829
&gt；&gt；扬声器2：那是因为所有东西都被提升到顶部。
&gt;&gt; Speaker 2: That's because everything gets hoisted into the top.

95
00:05:51.829 --> 00:05:55.295
&gt；&gt；Douglas：这是因为var声明都被提升到顶部，并且
&gt;&gt; Douglas: It's because both var declarations gets hoisted to the top and

96
00:05:55.295 --> 00:05:58.050
没有检查变量是否已经声明。
there's no check to see if a variable has already been declared.

97
00:05:59.120 --> 00:06:03.084
因此，如果有第二个var声明
So if there is a second var declaration for

98
00:06:03.084 --> 00:06:07.180
同名好，这就是双好。
the same name good, that's double good.

99
00:06:07.180 --> 00:06:08.459
这应该是个错误，但是
It should be an error, but

100
00:06:08.459 --> 00:06:11.899
它不是，因为它不是一个错误会陷入麻烦。
it's not, because it's not an error can get into trouble.

101
00:06:11.899 --> 00:06:16.779
因此，由于所有这些奇怪之处，我建议您清除所有变量
So because of all of this weirdness I recommend to clear all of your variables

102
00:06:16.779 --> 00:06:18.000
在函数的顶部。
at the top of the function.

103
00:06:18.000 --> 00:06:21.269
因为那就是他们实际被宣布的地方
Because that's where they're actually being declared and

104
00:06:21.269 --> 00:06:24.490
在调用所有函数之前还要声明它们。
also declare all of your functions before you call them.

105
00:06:24.490 --> 00:06:27.810
所有这些吊装废话都是专门制造出来的
All of this hoisting nonsense was created specifically so

106
00:06:27.810 --> 00:06:32.290
你不需要这样做，你可以在函数被声明之前调用它。
that you don't have to do that, that you can call a function before it's declared.

107
00:06:33.509 --> 00:06:36.579
但这就要求所有这些吊装的怪异
But that requires that all this hoisting weirdness be going on and

108
00:06:36.579 --> 00:06:39.610
你知道主机在做什么。
that you understand what the hosting is doing.

109
00:06:39.610 --> 00:06:43.449
我认为这对阅读你的节目的人期望太高了。
And I think that's too much to expect of the people reading your program.

110
00:06:43.449 --> 00:06:48.540
因此，相反，我认为在调用函数之前声明函数要好得多。
So instead I think it's much better to say declare the function before you call it.

111
00:06:48.540 --> 00:06:51.259
这是一件容易理解的事情。
That's a much easier thing to understand.

112
00:06:51.259 --> 00:06:57.620
&gt；&gt；演讲者2：但是Call，你使用的是Call这个词，我会称之为定义。
&gt;&gt; Speaker 2: But call, you're using the word call where I would call it defining.

113
00:06:57.620 --> 00:06:59.939
&gt；&gt；Douglas：在JavaScript中，
&gt;&gt; Douglas: In JavaScript,

114
00:06:59.939 --> 00:07:04.740
在清除一个函数之前，您可以通过词法调用它。
you can lexically call a function before you can clear it.

115
00:07:04.740 --> 00:07:06.060
我可以说&gt；&gt；扬声器2：我明白你的意思了。
I can say &gt;&gt; Speaker 2: I see what you mean.

116
00:07:06.060 --> 00:07:09.959
&gt；&gt；Douglas：我可以说foo parent，然后在下面我可以说function foo。
&gt;&gt; Douglas: I can say foo parent, and then below that I can say function foo.

117
00:07:09.959 --> 00:07:13.670
&gt；&gt；Speaker 2：你的意思不是说var，一些函数名，和
&gt;&gt; Speaker 2: You don't mean to say var, some function name, and

118
00:07:13.670 --> 00:07:15.560
然后在以后找到一个函数。
then later on to find a function.

119
00:07:15.560 --> 00:07:18.600
我明白了，没关系。
I see, nevermind.

120
00:07:18.600 --> 00:07:19.665
这两种说法，
These two statements,

121
00:07:19.665 --> 00:07:23.298
我正在寻找的这两个语句之间没有相似之处。
there's not this parallel between these two statements that I'm looking for.

122
00:07:26.706 --> 00:07:30.129
&gt；&gt；扬声器2：所以函数不是变量。
&gt;&gt; Speaker 2: So functions aren't variables.

123
00:07:30.129 --> 00:07:33.305
&gt；&gt；Douglas：不，函数是可以存储在变量中的值。
&gt;&gt; Douglas: No, functions are values that can be stored in variables.

124
00:07:33.305 --> 00:07:35.259
&gt；&gt；扬声器2：好的，如果他们有名字的话。
&gt;&gt; Speaker 2: Okay, if they have a name.

125
00:07:35.259 --> 00:07:39.230
&gt；&gt；Douglas：甚至匿名函数也可以存储在变量中。
&gt;&gt; Douglas: Even anonymous functions can be stored in variables.

126
00:07:39.230 --> 00:07:39.730
&gt；&gt；扬声器2：好的。
&gt;&gt; Speaker 2: Okay.
