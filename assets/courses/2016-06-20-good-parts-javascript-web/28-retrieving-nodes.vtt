WEBVTT

1
00:00:00.000 --> 00:00:03.900
[音乐]
[MUSIC]

2
00:00:03.900 --> 00:00:06.349
&gt；&gt；Douglas Crockford：您可以通过检索获得一个节点。
&gt;&gt; Douglas Crockford: You can get a node by retrieving.

3
00:00:07.440 --> 00:00:12.132
我更喜欢的方式是get document.getElementById。
The way I prefer to do it is get document.getElementById.

4
00:00:12.132 --> 00:00:15.130
您还可以通过名称、标记名称来获取内容。
You can also get things by name, by tag name.

5
00:00:15.130 --> 00:00:18.449
你可以做CSS查询和类似的事情。
You can do CSS queries and things like that.

6
00:00:18.449 --> 00:00:21.010
现在有很多方法可以访问节点。
There's quite a lot of ways of getting access to a node now.

7
00:00:23.480 --> 00:00:26.510
一旦您拥有对节点的访问权限，就可以对其进行操作。
Once you have access to a node, you can manipulate it.

8
00:00:26.510 --> 00:00:30.635
这些是图像标签的标准属性。
So these are the standard properties of an image tag.

9
00:00:30.635 --> 00:00:35.250
如果您有权访问图像标签，则可以更改这些属性中的任何一个。
And if you have access to an image tag, you can change any of these properties.

10
00:00:35.250 --> 00:00:39.588
要更改的最有趣的是源代码，如果您将源代码替换为
The most interesting one to change is the source if you replace the source with

11
00:00:39.588 --> 00:00:40.600
不同的URL。
a different URL.

12
00:00:40.600 --> 00:00:42.350
然后突然会出现一张不同的图片。
Then suddenly a different picture will show up.

13
00:00:44.829 --> 00:00:50.250
JavaScript提供了一种非常方便的方法。
And JavaScript provides a very convenient way of doing that.

14
00:00:50.250 --> 00:00:54.170
您只需说node.property name等于您希望它具有的任何值，并且
You just say node.property name equals whatever value you want it to have and

15
00:00:54.170 --> 00:00:54.780
它起作用了。
it works.

16
00:00:55.960 --> 00:00:58.829
这些是图像标记的标准属性。
These are the standard properties of an image tag.

17
00:00:58.829 --> 00:01:01.899
每个浏览器都将具有独特的附加属性
Every browser will have additional properties that are unique

18
00:01:01.899 --> 00:01:02.640
到那个浏览器。
to that browser.

19
00:01:02.640 --> 00:01:06.293
我建议你远离那些东西，因为这是个陷阱。
I recommend stay away from that stuff because it's a trap.

20
00:01:06.293 --> 00:01:12.555
如果你想留在共同的部分，所以你会在任何地方工作。
If you wanna stay to the common part, so you'll work everywhere.

21
00:01:12.555 --> 00:01:15.091
W3C对JavaScript不满意，
W3C was not happy about JavaScript,

22
00:01:15.091 --> 00:01:18.409
在他们拒绝后在网络上生存。
surviving in the web after they'd rejected it.

23
00:01:18.409 --> 00:01:20.870
他们以为这就是结局，但事实并非如此
They thought that was gonna be the end of it but it didn't and

24
00:01:21.989 --> 00:01:25.310
在W3C中，对Java的同情比对JavaScript的同情要多得多。
there was a lot more sympathy for Java at W3C than for JavaScript.

25
00:01:25.310 --> 00:01:27.870
所以多年来他们一直在努力
And so over the years they've been trying to

26
00:01:27.870 --> 00:01:31.659
将API替换为对Java更友好的东西
replace the API with something that would be more friendly for Java than for

27
00:01:31.659 --> 00:01:36.170
JavaScript，尽管Java从未以这种方式存在于浏览器中。
JavaScript even though Java has never lived in browsers in this way.

28
00:01:36.170 --> 00:01:38.590
所以他们不喜欢老式的做事方式。
So they didn't like the old school way of doing things.

29
00:01:38.590 --> 00:01:43.662
所以他们增加了这个，我们可以调用获取贡品并设置贡品。
So they added this one, we can call get tribute and set tribute.

30
00:01:43.662 --> 00:01:47.026
这种形式有明显的优势，那就是更多的打字和
This form having the obvious advantage, that's a lot more typing and

31
00:01:47.026 --> 00:01:47.942
像那样的人。
people like that.

32
00:01:52.658 --> 00:01:55.539
&gt；&gt；Douglas Crockford：获得节点后可以做的另一件事是
&gt;&gt; Douglas Crockford: Another thing you can do when you've got hold of a node is

33
00:01:55.539 --> 00:01:57.009
设计它。
style it.

34
00:01:57.009 --> 00:01:59.030
所以你有很多造型选择。
So you've got lots of options for styling.

35
00:01:59.030 --> 00:02:02.140
一个是你可以得到它的类名，这是一个命名错误的东西。
One is you can get at its class name, which is a misnamed thing.

36
00:02:02.140 --> 00:02:05.170
它应该是.class，但它不是，
it should be .class but it's not,

37
00:02:05.170 --> 00:02:09.270
它被称为类名，即使它可以是几个类名。
it's called class name even though it can be several class names.

38
00:02:09.270 --> 00:02:11.650
它仍然是班名。
It's still class name.

39
00:02:11.650 --> 00:02:16.199
更有趣的是，您可以获得样式对象并更改样式的属性。
More interesting as you can get at style object and change attributes of the style.

40
00:02:17.729 --> 00:02:20.509
微软增加了一个非常好的东西，叫做currentStyle，但是
Microsoft added a really nice thing called currentStyle but

41
00:02:20.509 --> 00:02:24.319
有时，您想知道某项内容的当前属性是什么。
sometimes you want to know what is the current attribute for something.

42
00:02:24.319 --> 00:02:28.379
我想知道某样东西有多大，或者它在哪里，或者它现在是什么颜色。
I want to know how big something is or where it is or what color it is currently.

43
00:02:28.379 --> 00:02:29.719
差不多吧。
Something like that.

44
00:02:29.719 --> 00:02:33.775
微软提供了一种很好的方法来找出这一点。
And Microsoft provides a very nice way of finding that out.

45
00:02:33.775 --> 00:02:37.120
但是W3C说，不，这不是我们想要的方式。
But W3C said, no that's not the way we wanna go.

46
00:02:37.120 --> 00:02:41.840
相反，我们更希望您编写document.defaultview.getComputed样式
Instead we'd rather have you write document.defaultview.getcomputed style

47
00:02:41.840 --> 00:02:44.629
节点获取属性值样式名称，对。
node get property values style name, right.

48
00:02:46.250 --> 00:02:48.900
这显然是一个Java API，对吧。
This is obviously a Java API, right.

49
00:02:48.900 --> 00:02:52.280
我的意思是知道JavaScript的人都不会写这个。
I mean nobody who knows JavaScript would write that.

50
00:02:52.280 --> 00:02:56.780
这显然是由一个对JavaScript一无所知的人设计的。
This is clearly designed by somebody who did not know anything about JavaScript.

51
00:02:56.780 --> 00:03:01.199
我不知道Java世界里他们想写的人会发生什么
And I don't know what happens with people in the Java world that they wanna write

52
00:03:01.199 --> 00:03:06.669
像这样的东西，但事情就是这样发生的。
stuff like this but that's kind of the way things happen.

53
00:03:06.669 --> 00:03:08.201
所以我需要咆哮一会儿。
So I need to rant for a moment.

54
00:03:08.201 --> 00:03:13.819
因此CSS和DOM几乎都是在同一时间设计的。
So the CSS and the DOM were both designed about the same time.

55
00:03:15.110 --> 00:03:18.889
每个项目都意识到了另一个。
And each project was aware of the other.

56
00:03:18.889 --> 00:03:23.322
设计CSS的人知道有一天编程语言会
The guy who designed CSS was aware that some day programming languages were going

57
00:03:23.322 --> 00:03:26.400
操纵样式表，这不是必然的。
to manipulate style sheets, not that was a certainty.

58
00:03:27.490 --> 00:03:31.949
但他选择使用减号作为连字符，
And yet he chose to use the minus sign as a hyphen,

59
00:03:33.379 --> 00:03:37.259
知道我们的大多数编程语言都想用它做减法
knowing that most of our programming languages want to do subtraction with it

60
00:03:37.259 --> 00:03:41.090
这给你们所有人造成了句法上的困难。
and that this creates a syntactic difficulty for all of you.

61
00:03:42.159 --> 00:03:42.849
不管怎么说，是他做的。
He did that, anyway.

62
00:03:43.990 --> 00:03:46.590
同时，在Netscape，他们正在研究DOM和
Meanwhile, at Netscape they're working on the DOM and

63
00:03:46.590 --> 00:03:49.819
他们看到CSS刚刚发生了什么，他们就走了。
they see what just happened to CSS and they go.

64
00:03:49.819 --> 00:03:51.819
好吧，那我们该怎么办？
Okay, what are we gonna do about that?

65
00:03:51.819 --> 00:03:54.750
他们可能会说，嗯，这很烦人，但是
What they could have said was, well, that's annoying but

66
00:03:54.750 --> 00:04:00.949
我们只是说你拿着括号，然后把绳子放进去，就这样，所以。
we'll just say you take the brackets and you put the string in, that's that, so.

67
00:04:00.949 --> 00:04:04.498
你必须键入额外的字符，但它是完全兼容的。
You have to type for extra characters but it was completely compatible.

68
00:04:05.599 --> 00:04:09.969
或者他们可能会说，减号是个问题，所以
Or they could have said, well minus signs are a problem, so

69
00:04:09.969 --> 00:04:11.900
我们只是把它们换成酒吧。
we'll just change them to under bars.

70
00:04:11.900 --> 00:04:15.259
所以最小的改变，搜索和替换配置，没有。
So minimal change, search and replace config, no.

71
00:04:15.259 --> 00:04:18.122
他们用最不相容的方式写这些名字。
They went with the least compatible way of writing these names.

72
00:04:19.860 --> 00:04:21.045
&GT；&GT；Douglas Crockford：这很重要，
&gt;&gt; Douglas Crockford: And it matters,

73
00:04:21.045 --> 00:04:25.100
因为你需要知道我现在哪个空间？
cuz you need to be aware of which space am I in right now?

74
00:04:25.100 --> 00:04:28.959
我是在CSS空间，还是在DOM空间？
Am I in CSS space, or am I in DOM space?

75
00:04:28.959 --> 00:04:31.720
这真的很容易让人感到困惑，你在哪里，
And it's really easy to get confused about where you are and

76
00:04:31.720 --> 00:04:33.879
如果你选择了错误的表格，那就完全失败了。
if you pick the wrong form, it's total failure.

77
00:04:35.800 --> 00:04:38.547
他们本可以使这项工作成为一个系统。
They could have made this work like a system.

78
00:04:38.547 --> 00:04:41.872
他们本可以为你做好这件事，但他们选择不这样做
They could have made this work well for you and they chose not to and

79
00:04:41.872 --> 00:04:44.490
它还在那里，永远也修不好了。
it's still there and it's never gonna get fixed.

80
00:04:46.389 --> 00:04:52.759
无论如何，你可以用节点做的另一件事是你可以做节点。
Anyway, so another thing you can do with nodes is you can make nodes.

81
00:04:52.759 --> 00:04:54.509
您可以创建全新的节点。
You can make brand new nodes.

82
00:04:54.509 --> 00:04:58.090
所以你可以调用document.createElement，传入一个标记名，比如DIV或
So you can call document.createElement, pass in a tag name like a DIV or

83
00:04:58.090 --> 00:05:00.740
一些东西，你就会得到一个新的元素。
something and you get a new element.

84
00:05:00.740 --> 00:05:03.230
这个新元素还看不见，而且
That new element is not visible yet and

85
00:05:03.230 --> 00:05:06.060
它将不可见，直到您将其粘贴到树中。
it won't be visible until you paste it into the tree.

86
00:05:06.060 --> 00:05:07.689
我们下一步就这么做。
We'll do that next.

87
00:05:07.689 --> 00:05:09.189
您可以相同的方式创建文本节点。
You can make text nodes the same way.

88
00:05:09.189 --> 00:05:12.939
您传递一个字符串来创建文本节点，它将使您成为一个文本节点。
You pass a string to create text node and it will make you a text node.

89
00:05:12.939 --> 00:05:15.000
然后您可以将其附加到其他节点。
Which you can then attach to some other node.

90
00:05:16.240 --> 00:05:19.949
另一种创建节点的方法是通过克隆已有的节点。
Another way you can make nodes is by cloning nodes that you already have.

91
00:05:19.949 --> 00:05:21.889
克隆人并不是完美的副本。
A clone is not a perfect copy.

92
00:05:21.889 --> 00:05:25.310
例如，节点上可能有事件处理程序，但是
For example a node might have event handlers on it, but

93
00:05:25.310 --> 00:05:26.870
克隆节点不会。
a cloned node will not.

94
00:05:28.069 --> 00:05:30.029
但在其他方面都很相似。
But otherwise it's pretty similar.

95
00:05:30.029 --> 00:05:31.841
如果将true传递给cloneNode，
And if you pass true to cloneNode,

96
00:05:31.841 --> 00:05:35.790
然后，如果节点有子节点，您也将获得子节点的克隆。
then if the node has children, you'll get clones of the children as well.

97
00:05:38.050 --> 00:05:39.387
&gt；&gt；Douglas Crockford：所以如果你想让它可见，
&gt;&gt; Douglas Crockford: So if you wanna make it visible,

98
00:05:39.387 --> 00:05:41.199
你必须把它插在树上。
you have to stick it into the tree.

99
00:05:41.199 --> 00:05:47.649
因此，您可以调用一个节点并说appendChild，即新节点。
So you can call a node and say appendChild, the new node.

100
00:05:47.649 --> 00:05:51.659
因此新节点成为该节点的新的最后一个子节点。
And so the new node becomes the new last child of that node.

101
00:05:52.699 --> 00:05:54.759
你也可以在前面插入东西
And you can also insert things before and

102
00:05:54.759 --> 00:05:57.840
可以用不同的节点替换节点。
you can replace a node with a different node.

103
00:05:59.329 --> 00:06:01.839
同样，这是一个Java API。
And again, this is a Java API.

104
00:06:01.839 --> 00:06:04.459
因为你必须说两遍老的。
Because you have to say old twice.

105
00:06:04.459 --> 00:06:08.959
就像我可以说的，节点，用这个代替你自己。
Like I could just say, node, replace yourself with this.

106
00:06:08.959 --> 00:06:12.829
不，您必须告诉节点父节点替换该子节点
No, you have to tell the nodes parent replace that child

107
00:06:12.829 --> 00:06:16.860
有了这个方法，找到父节点就是节点本身。
with that one in the way find the parent is with the node itself.

108
00:06:16.860 --> 00:06:18.970
你为什么要写两遍旧的？
Why do you have to write old twice?

109
00:06:18.970 --> 00:06:20.220
为什么Java人要这样做？
Why did Java people do that?

110
00:06:20.220 --> 00:06:26.747
无论如何，你必须移除孩子。
Anyway, you have to remove children.

111
00:06:26.747 --> 00:06:31.209
因此可以调用node.removeChild，但同样不会告诉节点删除
And so you can call node.removeChild but again you don't tell the node to remove

112
00:06:31.209 --> 00:06:36.019
它本身，你必须告诉父母移动它，所以你必须做两次。
itself, you have to tell the parents to move it, so you have to do it twice.

113
00:06:36.019 --> 00:06:37.810
这里有一个特别的危险
There's a particular hazard here for

114
00:06:37.810 --> 00:06:41.139
垃圾收集，如果您使用的是较旧的IE浏览器之一。
garbage collection, if you're on one of the older IE browsers.

115
00:06:41.139 --> 00:06:47.471
那么，有人支持IE6，7，8吗？
So, anybody supporting IE6, 7, 8?

116
00:06:47.471 --> 00:06:49.084
你伤透了我的心。
You're breaking my heart.

117
00:06:49.084 --> 00:06:50.204
真的吗？
Really?

118
00:06:50.204 --> 00:06:52.699
&gt；&gt；扬声器2：遗产，是的。
&gt;&gt; Speaker 2: Legacy, and it's, yeah.

119
00:06:52.699 --> 00:06:53.346
&gt；&gt；Douglas Crockford：好的，那么
&gt;&gt; Douglas Crockford: Okay, so

120
00:06:53.346 --> 00:06:57.449
我本来希望我不用再说这些了，但我真的说了。
I was hoping I wouldn't have to say this anymore but I do.

121
00:06:57.449 --> 00:07:01.839
因此IE中存在设计错误。
So there is a design error in IE.

122
00:07:01.839 --> 00:07:05.334
如果您将事件处理程序附加到节点，
That if you attach a event handler to a node,

123
00:07:05.334 --> 00:07:08.740
该节点不会被垃圾收集。
that node will not get garbage collected.

124
00:07:08.740 --> 00:07:13.024
并且事件处理程序和它所持有的所有内容都不会得到垃圾
And the event handler and everything that it's holding onto will not get garbage

125
00:07:13.024 --> 00:07:15.867
即使从树中删除该节点也会收集。
collected even if you remove that node from the tree.

126
00:07:15.867 --> 00:07:19.973
因此，要求您必须删除中的所有事件处理程序
So, the requirement is that you have to remove all of the event handlers from

127
00:07:19.973 --> 00:07:23.569
从树中删除节点之前的节点。
the node before you remove the node from the tree.

128
00:07:23.569 --> 00:07:29.839
这对任何人来说都太过分了，但这就是你必须要做的。
Which is too much to ask of anybody but that's what you have to do.

129
00:07:29.839 --> 00:07:33.529
它在IE6中被识别，它应该在IE7中被修复，但它没有。
It was identified in IE6, it was supposed to be fixed in IE7, and it wasn't.

130
00:07:33.529 --> 00:07:35.990
它本来应该在IE8中修复的，但它没有。
It was supposed to be fixed in IE8 and it wasn't.

131
00:07:35.990 --> 00:07:37.899
我相信它最终在IE9中得到了修复。
I believe it finally did get fixed in IE9.

132
00:07:41.612 --> 00:07:45.290
&gt；&gt；Douglas Crockford：所以有时候你想要做的就是获取一个HTML片段
&gt;&gt; Douglas Crockford: So sometimes what you want to do is take a fragment of HTML

133
00:07:45.290 --> 00:07:48.903
文本并以某种方式将其合并到文档中。
text and incorporate that into the document somehow.

134
00:07:48.903 --> 00:07:53.430
和W3C在他们的API中没有提供很好的方法来做到这一点。
And W3C in their API provided no good way to do that.

135
00:07:53.430 --> 00:07:58.180
他们的模型是，您将用JavaScript编写XML解析器。
Their model was, you would write an XML parser in JavaScript.

136
00:07:58.180 --> 00:08:01.920
并让它解析文本，然后您将
And have it parse the text, and then you would

137
00:08:01.920 --> 00:08:05.810
调用我刚才展示的所有方法，并让它构建结构。
call all the methods that I just showed you and have it build the structure.

138
00:08:07.269 --> 00:08:11.100
微软说，不，那是太多的工作了，所以他们想出了一个属性
Microsoft said, no that's way too much work, so they came up with a property

139
00:08:11.100 --> 00:08:14.209
一个名为innerHTML的节点的名称，这是一个可怕的名称。
of a node called innerHTML, which is a terrible name.

140
00:08:15.639 --> 00:08:16.569
但它起作用了。
But it works.

141
00:08:16.569 --> 00:08:22.069
因此，您要做的就是为其分配一个HTML文本片段，然后它将对其进行解析
So, what you do is your assign an HTML text fragment to that and it will parse it

142
00:08:22.069 --> 00:08:28.370
然后把它变成一棵树并把它粘贴到文档中，做所有这些，非常好。
and turn it into a tree and stick it into the document, do all of that, very nice.

143
00:08:29.779 --> 00:08:31.555
不幸的是，这是一个安全隐患。
Unfortunately, it's a security hazard.

144
00:08:31.555 --> 00:08:36.582
任何时候您都可以对HTML文本进行任何操作，特别是通过连接，但是
Any time you have any manipulation of HTML text, particularly by concatenation but

145
00:08:36.582 --> 00:08:42.059
同样，通过模板，攻击者很有可能利用这一点。
also by templating, there is a good chance that an attacker can exploit that.

146
00:08:42.059 --> 00:08:44.659
所以你需要非常谨慎地对待这些东西。
So you need to be really, really cautious with this stuff.

147
00:08:47.970 --> 00:08:49.350
那么哪种方式更好呢？
So which way is better?

148
00:08:49.350 --> 00:08:53.519
构建或克隆元素并将其附加到文档中是更好的做法还是
Is it better to build or clone elements and append them to the document or

149
00:08:53.519 --> 00:08:57.009
用HTML文本编译并使用HTML实现更好吗？
is it better to compile in HTML text and using HTML to realize it.

150
00:08:58.110 --> 00:09:02.049
一般来说，我想回答的这些问题就是，
Generally, these sorts of questions I want to answer in terms of,

151
00:09:02.049 --> 00:09:04.330
是什么让你的代码更干净，维护更好？
what gives you a cleaner code and better maintenance?

152
00:09:04.330 --> 00:09:08.679
现在，什么最符合你制作应用程序的方式
Now, what best matches the way you make the application

153
00:09:08.679 --> 00:09:12.360
你应该只在真正重要的情况下才倾向于表现？
that you should only favor performance in cases where it really matters?

154
00:09:12.360 --> 00:09:16.269
在真正重要的情况下，您希望在我们的HTML中使用。
In the cases where it really matters, you wanna use in our HTML.

155
00:09:16.269 --> 00:09:20.100
浏览器真正擅长的几件事之一就是解析HTML。
It's one of the few things that browsers are really good at is parsing HTML.

156
00:09:20.100 --> 00:09:22.490
而且他们可以很快地做到这一点
And they can do that really quickly and

157
00:09:22.490 --> 00:09:26.000
他们可以在一次交易中完成整个事情。
they can get the whole thing done in one transaction.

158
00:09:26.000 --> 00:09:27.200
而摆弄DOM，
Whereas messing with the DOM,

159
00:09:27.200 --> 00:09:30.299
每次你碰DOM你都要付一大笔罚金。
every time you touch the DOM you're gonna pay a big time penalty.
