WEBVTT

1
00:00:00.000 --> 00:00:03.712
[音乐]
[MUSIC]

2
00:00:03.712 --> 00:00:05.841
&gt；&gt；演讲者1：还有一个攻击，并且
&gt;&gt; Speaker 1: There's still one attack left, and

3
00:00:05.841 --> 00:00:07.839
这是一次无序的攻击。
this one is an out of order attack.

4
00:00:09.169 --> 00:00:11.119
攻击者可能导致的
That the attacker can cause

5
00:00:12.599 --> 00:00:17.410
要在另一条消息之前传递的消息，至少要传递给某些订阅者。
a message to be delivered before another message, at least to some subscribers.

6
00:00:17.410 --> 00:00:20.539
通过这样做，他可以在市场上制造混乱。
By doing so, he can create confusion in the marketplace.

7
00:00:21.660 --> 00:00:26.530
你怎么做到的？
How do you do that?

8
00:00:26.530 --> 00:00:27.719
&GT；&GT；扬声器2：你在学校做过，
&gt;&gt; Speaker 2: You did this in school,

9
00:00:27.719 --> 00:00:30.260
它应该在你的消息中才能成为订阅者。
should it in your messages in the order to be subscribers.

10
00:00:31.260 --> 00:00:33.549
&gt；&gt；扬声器1：每个订阅者都应该按照以下顺序获得它们
&gt;&gt; Speaker 1: Each of the subscribers should get them in the order that

11
00:00:33.549 --> 00:00:36.189
订阅，他们也应该每个人
subscribed, and they should also each of them

12
00:00:36.189 --> 00:00:38.369
应该按照消息发送的顺序获取消息。
should get the messages in the order that they are sent.

13
00:00:38.369 --> 00:00:45.570
&gt；&gt；扬声器3：有些订阅者是用这个号码订阅的吗？
&gt;&gt; Speaker 3: And some subscribers subscribe with the number?

14
00:00:45.570 --> 00:00:47.570
&gt；&gt；Speaker 2：不，这会导致抛出异常，并且
&gt;&gt; Speaker 2: No, that would cause an exception to get thrown, and

15
00:00:47.570 --> 00:00:51.799
我们已经忽略了这些。
we already ignored those.

16
00:00:51.799 --> 00:00:55.009
&gt；&gt；演讲者3：所以我们现在假设我们正在进行foreach
&gt;&gt; Speaker 3: So we're assuming at this point that we're working on the foreach

17
00:00:55.009 --> 00:01:02.090
循环而不是以前的任一种，但不关注这一种。
loop rather than the previous either one, but not to focus on this one.

18
00:01:02.090 --> 00:01:07.549
&gt；&gt；演讲者1：你喜欢，因为我们可以看到
&gt;&gt; Speaker 1: You like, since we can see that the corrections that

19
00:01:07.549 --> 00:01:15.897
到目前为止，我们已经修复了这个新的，如此多的推动。
we have made up to this point have fixed this new And so much of the push push on.

20
00:01:15.897 --> 00:01:19.900
&gt；&gt；扬声器3：很容易推动他们的功能
&gt;&gt; Speaker 3: It's very easy pushing their function

21
00:01:21.230 --> 00:01:27.480
方法还是螺丝钉的顺序呢，颠倒了吗？
methods or screw with the order of it, reverse it?

22
00:01:27.480 --> 00:01:30.260
&gt；&gt；演讲者1：不，你说的是我们做的第一个问题？
&gt;&gt; Speaker 1: No, you're talking about the first problem we did?

23
00:01:30.260 --> 00:01:30.879
&gt；&gt；扬声器3：是的。
&gt;&gt; Speaker 3: Yeah.

24
00:01:30.879 --> 00:01:35.120
&gt；&gt；演讲者1：是的，那个人使用了store，因为我们可以说出
&gt;&gt; Speaker 1: Yeah, and that one was using store, because we could name

25
00:01:36.140 --> 00:01:40.439
它要去哪里，那就是我们没有提供这样做的API。
where it was going to go, and that's when we haven't provided an API for doing that.

26
00:01:40.439 --> 00:01:41.069
&gt；&gt；扬声器3：明白。
&gt;&gt; Speaker 3: Gotcha.

27
00:01:41.069 --> 00:01:44.750
&gt；&gt；扬声器1：这个结构的好处是
&gt;&gt; Speaker 1: And the good thing about this construction is that

28
00:01:44.750 --> 00:01:49.049
这是不可能的，因为他们，嗯，这是我们修复的东西，
that's impossible because they, well, it's something that we fix the thing,

29
00:01:49.049 --> 00:01:52.219
在那里他们可以访问订阅者或通过这个访问。
where they can get access to the subscribers or a through this.

30
00:01:52.219 --> 00:01:55.697
他们无法向订阅者添加属性，除非通过
There is no way that they can add a property to subscribers except through

31
00:01:55.697 --> 00:01:56.954
订阅功能。
the subscribe function.

32
00:02:06.003 --> 00:02:08.802
&gt；&gt；扬声器2：不再可以访问这个，访问-
&gt;&gt; Speaker 2: Doesn't have access to this anymore, to the-

33
00:02:08.802 --> 00:02:09.742
&gt；&gt；扬声器1：正确。
&gt;&gt; Speaker 1: That's correct.

34
00:02:25.962 --> 00:02:28.018
&gt；&gt；演讲者4：我们是想把消息弄乱还是
&gt;&gt; Speaker 4: Are we trying to get the messages out of order or

35
00:02:28.018 --> 00:02:30.069
订阅者出了问题？
the subscribers out of order?

36
00:02:30.069 --> 00:02:31.094
&gt；&gt；扬声器1：留言顺序错误。
&gt;&gt; Speaker 1: The message is out of order.

37
00:02:31.094 --> 00:02:35.236
&gt；&gt；扬声器3：设置超时。
&gt;&gt; Speaker 3: Set time out.

38
00:02:35.236 --> 00:02:39.817
是这样的，
Is and that would make,

39
00:02:39.817 --> 00:02:45.271
它会改变你的想法。
it would change where yours comes in.

40
00:02:45.271 --> 00:02:49.449
&gt；&gt；扬声器1：是的，settimeout可能是解决方案的一部分，但
&gt;&gt; Speaker 1: Yeah, settimeout might be part of the solution but

41
00:02:49.449 --> 00:02:52.969
这不是问题的一部分。
it's not part of the problem.

42
00:02:52.969 --> 00:02:53.960
&GT；&GT；演讲者2：你知道我们可能会等。
&gt;&gt; Speaker 2: You know we might wait.

43
00:02:53.960 --> 00:02:56.430
&gt；&gt；演讲者1：我们不必在网站上等待。
&gt;&gt; Speaker 1: We don't have to wait on the site.

44
00:02:57.770 --> 00:03:00.729
&gt；&gt；扬声器2：你知道，那是因为它无论如何都是同步的，如果我们
&gt;&gt; Speaker 2: You know and that's because it's synchronous anyways if it works if we

45
00:03:00.729 --> 00:03:08.639
只是把所有的东西都叫成实际的样子就行了。
just call everything just exactly as in effect.

46
00:03:09.889 --> 00:03:12.419
&gt；&gt；扬声器1：因为它停止一切准备。
&gt;&gt; Speaker 1: because it is it stops everything ready.

47
00:03:12.419 --> 00:03:15.310
所以，是的，所以这不是这个的一部分
So yeah so that that's not part of this

48
00:03:21.360 --> 00:03:24.990
您知道，每次您单击时，每当有人调用PUBLISH时
you know every time you click every time somebody calls publish

49
00:03:24.990 --> 00:03:30.310
出版物就是这样的信息，对吗？
a publication is that's the message right?

50
00:03:31.920 --> 00:03:35.409
&gt；&gt；扬声器2：将通读订阅者和
&gt;&gt; Speaker 2: Is gonna read through the subscribers and

51
00:03:35.409 --> 00:03:38.289
打给它，然后你说的是
call it and then what you're saying is

52
00:03:41.090 --> 00:03:45.629
我叫它然后你在我之后叫它你是坏人
I call it and then you call it after me you're that you're in the bad guy

53
00:03:45.629 --> 00:03:49.323
你用我的名字来称呼它，因为不知何故或者你的跳线在我的前面。
you call it after me because somehow or yours jumper wire infront of mine.

54
00:03:49.323 --> 00:03:49.823
&gt；&gt；扬声器1：是的。
&gt;&gt; Speaker 1: Yeah.

55
00:03:52.973 --> 00:03:53.786
&gt；&gt；扬声器1：这就是我们要找的。
&gt;&gt; Speaker 1: That's what we're looking for.

56
00:03:53.786 --> 00:03:58.800
但你不能叫它，直到它和我的结束，因为它是，
But you can't call it until it's finished with mine because it's,

57
00:03:58.800 --> 00:04:00.366
这个过程是漫长的。
the process is long.

58
00:04:00.366 --> 00:04:03.949
但那是错的。
But that wrong.

59
00:04:03.949 --> 00:04:04.599
&gt；&gt；扬声器2：好的。
&gt;&gt; Speaker 2: Right.

60
00:04:04.599 --> 00:04:10.340
&gt；&gt；Speaker 3：我可以将pubsub对象传递给我的函数吗？
&gt;&gt; Speaker 3: Can I pass in the pubsub object to my function?

61
00:04:10.340 --> 00:04:14.509
然后在通话中重新订阅我自己。
and then resubscribe myself in the midst of a call.

62
00:04:14.509 --> 00:04:15.449
&gt；&gt；扬声器1：你很接近了。
&gt;&gt; Speaker 1: You're close.

63
00:04:16.649 --> 00:04:19.089
不是那样的，但就是这样。
It's not quite like that but it's that kind of this.

64
00:04:19.089 --> 00:04:25.019
&gt；&gt；Speaker 2：这是巨大的漏洞吗？不是因为这些
&gt;&gt; Speaker 2: Is this a vulnerability in for huge not because these

65
00:04:25.019 --> 00:04:29.889
只是一些传教士说的对。
are just some preachy Right.

66
00:04:29.889 --> 00:04:33.490
&gt；&gt；Speaker 3：那么我们本质上是在创建一个无限循环吗
&gt;&gt; Speaker 3: So are we essentially creating an infinite loop

67
00:04:33.490 --> 00:04:34.399
根据他说的话。
based on what he said.

68
00:04:35.819 --> 00:04:37.439
&gt；&gt；扬声器1：我们不是在寻找
&gt;&gt; Speaker 1: We are not looking for

69
00:04:37.439 --> 00:04:40.879
无限循环，因为无限循环将是拒绝服务攻击。
an infinite loop because an infinite loop would be a denial of service attack.

70
00:04:42.029 --> 00:04:43.689
&gt；&gt；扬声器3：好的。&gt；&gt；扬声器1：有人可以做
&gt;&gt; Speaker 3: Okay. &gt;&gt; Speaker 1: And someone can do

71
00:04:43.689 --> 00:04:45.879
一个无限循环而不调用我们的代码。
an infinite loop without calling our code.

72
00:04:45.879 --> 00:04:48.555
他们可以把自己的代码放在无限循环中，所以
They can just sit in their own code into an infinite loop so

73
00:04:48.555 --> 00:04:51.302
这不是这个代码可以防御的东西。
that that's not something this code can defend against.

74
00:04:56.242 --> 00:05:00.389
&gt；&gt；Speaker 2：在forEach内部，可以更改s的值吗？
&gt;&gt; Speaker 2: And inside of forEach, can you change the value of s?

75
00:05:02.379 --> 00:05:03.339
&gt；&gt；扬声器1：是的。
&gt;&gt; Speaker 1: Yes.

76
00:05:03.339 --> 00:05:08.050
&gt；&gt；扬声器2：所以如果我发布一个对象，并且
&gt;&gt; Speaker 2: So if I publish one object, and

77
00:05:08.050 --> 00:05:11.329
然后稍后发布另一个对象并
then later on, publish another object And

78
00:05:11.329 --> 00:05:17.399
该分离对象在其中具有将Aspect设置为第一个对象的功能。
that separate object has a function in it that sets aspect to the first object.

79
00:05:18.649 --> 00:05:21.009
这是一件肮脏的事吗。
Is that a nasty thing to do.

80
00:05:21.009 --> 00:05:24.189
&gt；&gt；扬声器1：嗯，这不太可能发生，因为无论你是什么功能
&gt;&gt; Speaker 1: Well that's not likely to happen because whatever function you're

81
00:05:24.189 --> 00:05:28.279
将要做的事情，将在范围之外创建，并且
going to be doing, that will be created outside of the scope and

82
00:05:28.279 --> 00:05:29.120
所以看不到。
so will not see at.

83
00:05:33.620 --> 00:05:37.610
是的，只有这个范围内的函数才能看到我们。
yeah only functions in this scope can see us.

84
00:05:37.610 --> 00:05:39.790
&gt；&gt；扬声器3：所以如果我通过了。
&gt;&gt; Speaker 3: So if I pass it.

85
00:05:39.790 --> 00:05:44.509
弹出到我的订阅者功能
The pops up to my subscribers function

86
00:05:44.509 --> 00:05:48.639
当调用我的函数时，我再次调用public。
when my function is called I call public Again.

87
00:05:48.639 --> 00:05:49.409
&gt；&gt；扬声器1：是的。&gt；&gt；扬声器3：和
&gt;&gt; Speaker 1: Yes. &gt;&gt; Speaker 3: And

88
00:05:49.409 --> 00:05:52.810
我们重新开始循环。
we restart to loop in the beginning again.

89
00:05:52.810 --> 00:05:55.439
&gt；&gt；扬声器1：没错。&gt；&gt；演讲者3：我们继续做
&gt;&gt; Speaker 1: Exactly. &gt;&gt; Speaker 3: And we keep on doing

90
00:05:55.439 --> 00:05:56.769
我们永远也得不到。
that we'll never get it.

91
00:05:56.769 --> 00:05:57.269
&gt；&gt；扬声器1：好的。
&gt;&gt; Speaker 1: Right.

92
00:05:59.620 --> 00:06:01.500
所以，这是一个俗气刚刚描述。
So, this is a tacky just describe.

93
00:06:01.500 --> 00:06:08.519
因此，他订阅了一个函数，该函数将发布和
So, he subscribes a function Which will publish and

94
00:06:08.519 --> 00:06:15.899
这个函数在发布循环中被调用，所以他可以剪切它。
this function gets called in the publication loop so he can cut it.

95
00:06:15.899 --> 00:06:19.680
然后，他可以使他自己的消息发表，并
He can then cause his own message to get published and

96
00:06:19.680 --> 00:06:24.369
发送给订阅者名单中的每个人
delivered to everybody who is after himself in the subscriber list

97
00:06:25.639 --> 00:06:28.529
而在这样做的过程中，他会导致事情变得乱七八糟。
And in doing that, he causes things to go out of order.

98
00:06:28.529 --> 00:06:32.360
&gt；&gt；扬声器4：莱昂纳多在聊天室再次击败我们。\
&gt;&gt; Speaker 4: Leonardo in the chat room beat us again.\

99
00:06:32.360 --> 00:06:33.235
&gt；&gt；演讲者1：莱昂纳多，干得好。
&gt;&gt; Speaker 1: Way to go Leonardo.

100
00:06:33.235 --> 00:06:36.730
&gt；&gt；[笑]&gt；&gt；扬声器4：好吧，文森特是第一个，
&gt;&gt; [LAUGH] &gt;&gt; Speaker 4: Well Vincent was the first,

101
00:06:36.730 --> 00:06:39.480
是的文森特上次打败了我们。
yeah Vincent beat us last time.

102
00:06:39.480 --> 00:06:40.590
这次是列奥纳多。
This time it was Leonardo.

103
00:06:40.590 --> 00:06:42.579
&gt；&gt；演讲者1：你必须告诉我们这一点。
&gt;&gt; Speaker 1: You need to be telling us that.

104
00:06:42.579 --> 00:06:44.500
之前-&gt；&gt；扬声器4：我知道。
Before- &gt;&gt; Speaker 4: I know.

105
00:06:44.500 --> 00:06:45.069
&gt；&gt；扬声器1：是的。
&gt;&gt; Speaker 1: Yeah.

106
00:06:45.069 --> 00:06:46.659
&gt；&gt；扬声器4：我不知道它就像-&gt；&gt；扬声器2：他
&gt;&gt; Speaker 4: I didn't know it's like- &gt;&gt; Speaker 2: He's

107
00:06:46.659 --> 00:06:48.350
A&GT；&GT；扬声器4：是的。
a &gt;&gt; Speaker 4: Yeah.

108
00:06:49.829 --> 00:06:50.750
&gt；&gt；扬声器1：好的，那么
&gt;&gt; Speaker 1: Okay, so

109
00:06:50.750 --> 00:06:54.509
我使用我们昨天写的极限函数的原因。
the reason I used the limit function that we wrote yesterday.

110
00:06:54.509 --> 00:06:59.050
因为如果我不这样做，那么我就是在制造拒绝服务攻击，对吧。
Because if I don't then I'm just creating a denial of service attack, right.

111
00:06:59.050 --> 00:07:02.379
我们将一遍又一遍地递归地调用它。
We'll keep calling it over and over again recursively.

112
00:07:02.379 --> 00:07:04.949
拒绝服务攻击并不能完成
And a denial of service attack doesn't accomplish

113
00:07:04.949 --> 00:07:08.970
我们试图利用的安全漏洞，只是损害了一个系统。
the security exploit that we're trying to do, it just impairs a system.

114
00:07:08.970 --> 00:07:10.529
&gt；&gt；扬声器2：限制是我们昨天写的。
&gt;&gt; Speaker 2: A limit's what we wrote yesterday.

115
00:07:10.529 --> 00:07:11.939
&gt；&gt；扬声器1：是的，我们昨天写了Limit，所以
&gt;&gt; Speaker 1: Yeah we wrote limit yesterday, so

116
00:07:11.939 --> 00:07:17.199
这意味着当我接到电话时，我将发送一条消息。
that means when I get called I am going to send one message.

117
00:07:19.610 --> 00:07:21.848
而且这个消息会比其他人先传递。
And that message will get delivered before everybody else.

118
00:07:28.779 --> 00:07:31.290
那你怎么解决这个问题？
So how would you fix that?

119
00:07:31.290 --> 00:07:33.990
&gt；&gt；扬声器2：每次有人发布消息时。
&gt;&gt; Speaker 2: every time somebody publishes a message.

120
00:07:33.990 --> 00:07:36.769
我的信息将会流传出去，它只会发生一次。
My message will go out it would only ever happen once.

121
00:07:36.769 --> 00:07:39.699
&gt；&gt；演讲者1：嗯，但我可以控制它，你知道这是最简单的
&gt;&gt; Speaker 1: Well but I can control it you know this is the simplest

122
00:07:39.699 --> 00:07:44.523
防止它变得被滥用的方法，但显然我们可以放一个更聪明的
way to keep it from getting Getting abusive but obviously we can put a smarter

123
00:07:44.523 --> 00:07:48.091
函数，它可以在每次调用时更改其行为。
function in there that could change its behavior every time it's called.

124
00:07:48.091 --> 00:07:53.127
&gt；&gt；扬声器3：您可以取下订阅者，然后
&gt;&gt; Speaker 3: You could take off the subscriber and

125
00:07:53.127 --> 00:07:58.653
确保它不是一个物体，对吗？
make sure it's not an object right?

126
00:07:58.653 --> 00:08:00.569
在您推送之前，请先查看订阅者。
The subscriber before you push.

127
00:08:00.569 --> 00:08:04.379
&gt；&gt；演讲者1：不，订阅者实际上必须是，
&gt;&gt; Speaker 1: No, the subscribers have to be In fact,

128
00:08:04.379 --> 00:08:08.098
这就是tri catch的用途，以保证它们是函数。
that's what the tri catch was for, to guarantee that they are functions.

129
00:08:08.098 --> 00:08:09.968
&gt；&gt；扬声器3：好的。
&gt;&gt; Speaker 3: Okay.

130
00:08:09.968 --> 00:08:14.689
你能-&gt；&gt；演讲者2：你能暂时
Can you- &gt;&gt; Speaker 2: Would you just temporarily

131
00:08:14.689 --> 00:08:19.170
将发布的值更改为其他值，但它被冻结了。
changed the value of publish to something else, but it's frozen.

132
00:08:20.279 --> 00:08:21.589
&gt；&gt；演讲者1：对我们，是的，我们解决了这个问题。
&gt;&gt; Speaker 1: Right we, yeah we fixed that one.

133
00:08:23.089 --> 00:08:26.240
&gt；&gt；扬声器2：我只是在想一种禁用发布的方法
&gt;&gt; Speaker 2: I was just trying to think of a way to disable publish

134
00:08:26.240 --> 00:08:28.410
在这个循环里面。
inside of this loop.

135
00:08:28.410 --> 00:08:31.540
所以如果你刚开始，你可以，是的，
So if you just set, you could, yeah,

136
00:08:31.540 --> 00:08:35.009
你在上面放了一个var，上面写着“发布关闭”(Publish Off)。
you put a var at the top of this that says publish off.

137
00:08:35.009 --> 00:08:38.210
&gt；&gt；扬声器1：是的，我们可以在顶部放一个布尔值，表示，我们在
&gt;&gt; Speaker 1: Yeah, we could put a boolean up at the top which says, we're in

138
00:08:38.210 --> 00:08:44.100
发布模式，因此当我们循环时，SUBSCRIBE或PUBLISH是关闭的。
the publication mode, so subscribe or publish is turned off while we're looping.

139
00:08:44.100 --> 00:08:46.509
那肯定行得通。
That would certainly work.

140
00:08:46.509 --> 00:08:48.980
我接近它的方式是，
The way I would approach it is,

141
00:08:48.980 --> 00:08:53.389
我会做一个异步解决方案，因为我喜欢同步。
I would do an asynchronous solution because I like a synchrony.

142
00:08:53.389 --> 00:09:00.409
所以浏览器、Java和节点中都有称为setTimeout的东西。
So there's something that's in browsers and in Java and in node called setTimeout.

143
00:09:00.409 --> 00:09:03.129
setTimeout接收一个函数并
And setTimeout receives a function and

144
00:09:03.129 --> 00:09:06.360
导致该函数在将来执行。
causes that function to get executed in the future.

145
00:09:06.360 --> 00:09:11.220
你可以给它一个时间，表示从现在起不早于零毫秒
And you can give it a time which says no sooner than zero milliseconds from now

146
00:09:11.220 --> 00:09:12.539
调用此函数。
call this function.

147
00:09:12.539 --> 00:09:15.090
但这个功能发生在不同的转折中。
But this function happens in a different turn.

148
00:09:15.090 --> 00:09:17.559
所以它会在当前所有的时间之后被安排好
So it'll get scheduled after all of the current

149
00:09:17.559 --> 00:09:19.830
当前回合的工作已完成。
work in the current turn is finished.

150
00:09:19.830 --> 00:09:22.450
所以这会导致。
So this would cause.

151
00:09:22.450 --> 00:09:26.270
所有的东西都在计时器队列中排好队
Everything to get lined up in the timer queue and

152
00:09:26.270 --> 00:09:30.951
那么如果有人想在发布期间订阅，
then if someone wants to subscribe during a publication,

153
00:09:30.951 --> 00:09:35.168
他们的内容稍后将被添加到计时器队列中。
their stuff will get added later in the timer queue.

154
00:09:35.168 --> 00:09:39.986
所以一切都保持有序，我们使用计时器队列对消息进行排序。
So everything stays in order, we're using the timer queue to sort the messages.

155
00:09:43.567 --> 00:09:45.286
&gt；&gt；扬声器1：现在，我们可以这样做。
&gt;&gt; Speaker 1: Now, so we could do that.

156
00:09:45.286 --> 00:09:48.658
&gt；&gt；Speaker 3：所以您将出版物移到一个单独的队列中
&gt;&gt; Speaker 3: So you move the publication off into a separate queue the one that

157
00:09:48.658 --> 00:09:51.665
如果这里发生了什么就能独立处理吗？
gets processed independently if whatever goes on here?

158
00:09:51.665 --> 00:09:56.278
&gt；&gt；扬声器1：对，这也意味着我现在不需要在这里尝试接球，因为
&gt;&gt; Speaker 1: Right and it also means I don't need to try catch here now because

159
00:09:57.389 --> 00:10:00.269
如果它失败了，那么在那个转弯中它就会失败。
If it fails it'll fail in that turn.

160
00:10:00.269 --> 00:10:04.129
但是然后系统说，好吧，那就转到终点，然后继续下一个。
But then the system says, well that turns finish and will go on to the next one.

161
00:10:04.129 --> 00:10:09.059
所以一切都在继续。
And so everything keeps going.

162
00:10:09.059 --> 00:10:12.610
现在看来，这里面有一个危险，因为设计错误
Now it turns out there's one hazard in this because of the design error in

163
00:10:12.610 --> 00:10:18.230
这种超时的工作方式当您暂停这样的超时，它会返回一个数字并
the way such a timeout works when you pause such timeout it returns a number And

164
00:10:18.230 --> 00:10:23.000
你可以传递这个数字来清除超时，这样就可以防止事情发生。
you can pass that number to clear timeout and that'll prevent things from happening.

165
00:10:23.000 --> 00:10:25.429
不幸的是，这是一个很容易猜测的数字。
Unfortunately, it is an easily guessable number.

166
00:10:25.429 --> 00:10:29.460
这意味着如果攻击者能猜到下一步
And that means if the attacker can guess what the next

167
00:10:29.460 --> 00:10:31.220
清除超时编号将是。
clear timeout number is going to be.

168
00:10:31.220 --> 00:10:33.440
他可以阻止传递消息。
He can prevent messages from being delivered.

169
00:10:33.440 --> 00:10:35.509
通过取消队列中的那些消息。
By cancelling those messages that are in the queue.

170
00:10:36.679 --> 00:10:40.169
所以我们必须解决这个问题，但我们改天再解决这个问题。
So we would have to fix that but we'll fix that one another day.
