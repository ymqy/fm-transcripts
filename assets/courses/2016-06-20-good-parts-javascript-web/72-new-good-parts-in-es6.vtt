WEBVTT

1
00:00:00.000 --> 00:00:03.911
[音乐]
[MUSIC]

2
00:00:03.911 --> 00:00:07.496
&gt；&gt；Speaker 1：我们获得了新版本的JavaScript，该版本已获得批准
&gt;&gt; Speaker 1: We've got a new version of JavaScript that was approved by

3
00:00:07.496 --> 00:00:09.909
六个月前的大会
the general assembly six months ago and

4
00:00:09.909 --> 00:00:13.830
它的许多功能现在已经在浏览器中了。
many of the features of it are already in browsers now.

5
00:00:13.830 --> 00:00:17.809
他们中的一些人会晚些时候来，所以这是一个很好的时间
And some of them will be coming in later and so this is a good time to

6
00:00:17.809 --> 00:00:22.042
看看新语言里有什么，我们在里面有什么好东西吗？
look at what's in the new language, did we get any good stuff in it?

7
00:00:22.042 --> 00:00:25.882
答案是肯定的，我们确实有很多好东西在里面。
And the answer is yes we've got actually lot of good stuff in it.

8
00:00:25.882 --> 00:00:30.062
因此，我最喜欢的语言新功能中最合适的尾部调用。
So my number one most favorite new feature of the language proper tail calls.

9
00:00:30.062 --> 00:00:35.371
因此编译器会将其转换为跳转而不是调用返回，
So compiler will turn that into a jump instead of a call return,

10
00:00:35.371 --> 00:00:37.881
所以它会跑得更快一点。
so it'll go a little faster.

11
00:00:37.881 --> 00:00:40.192
在到达那里时占用较少的内存，
Take less memory in getting there,

12
00:00:40.192 --> 00:00:46.119
它支持其他编程模式中的延续传递风格，这很棒。
it enables continuation passing style in other modes of programming, it's great.

13
00:00:46.119 --> 00:00:50.100
这是我最喜欢的JavaScript特性
So that's my most favorite feature with this JavaScript finally

14
00:00:50.100 --> 00:00:53.000
成为一种真正的函数式编程语言，这很棒。
becomes a real functional programming language, which is great.

15
00:00:54.090 --> 00:00:57.649
我第二个最喜欢的新特性，省略号运算符，我们已经
My second most favorite new feature, the ellipsis operator which we've

16
00:00:57.649 --> 00:01:02.590
昨天又谈了相当多，是咖喱函数的两个版本。
talk about quite a bit yesterday again is two versions of the curry function.

17
00:01:02.590 --> 00:01:05.909
有一个和那个，他们都做同样的事情。
There is that one and that one, they both do the same thing.

18
00:01:05.909 --> 00:01:07.439
这一次是不可原谅的
This one's inexcusable,

19
00:01:07.439 --> 00:01:10.680
这个实际上非常好，所以它将是一件好事。
this one's actually pretty nice so that it's going to be a good thing.

20
00:01:12.230 --> 00:01:15.980
我们现在有了语言中的模块，不幸的是，我们得到的模块系统是
We've got modules in the language now unfortunately the module system we got is

21
00:01:15.980 --> 00:01:17.599
太复杂了。
way too complex.

22
00:01:17.599 --> 00:01:21.319
但是它是有效的，所以有一个模块系统的子集是足够的。
But it works, so there's a subset of the module system which is adequate.

23
00:01:21.319 --> 00:01:25.159
如果你只是想说这里有一些东西，我要出口这个东西。
Which if you just wanna say here's some stuff, I'm gonna export this thing.

24
00:01:25.159 --> 00:01:30.060
这就是你如何使用它，这就是它所需要的，它可以做到这一点。
That's how you use it and that's all it needs to be, and it can do that.

25
00:01:30.060 --> 00:01:33.400
所以这很好，比要求的要好得多，或者
So that's good, that's much better than requires, or

26
00:01:33.400 --> 00:01:34.598
任何其他模块加载器。
any of the other module loaders.

27
00:01:36.640 --> 00:01:41.329
我们已经让康斯特进来了，这本身并不是什么大不了的事。
We've got let in const, which by themselves are not that big a deal.

28
00:01:41.329 --> 00:01:44.930
除了它们对Java程序员来说不那么令人困惑之外。
Except they are less confusing to Java programmers.

29
00:01:44.930 --> 00:01:48.960
所以最好不要让Java程序员感到困惑，所以我喜欢这样。
So it's good not to confuse the Java programmers, so I like that.

30
00:01:48.960 --> 00:01:53.950
我对此感到困惑的一件事是我看到了很多
One thing I find confusing about this is that I've seen a lot

31
00:01:53.950 --> 00:01:57.430
对于常量和冻结之间的区别感到困惑的开发人员。
of developers who are confused about the difference between const and freezing.

32
00:01:58.590 --> 00:02:02.459
所以他们很惊讶你可以把一个可变的对象放在一个常量和
And so they're surprised that you can put a mutable object in a const and

33
00:02:02.459 --> 00:02:04.310
仍然使对象发生变异。
still mutate that object.

34
00:02:04.310 --> 00:02:07.400
所以变量的常量，冻结是
So constants for variables, freezing is for

35
00:02:07.400 --> 00:02:12.389
价值观，只要记住这一点，这是相当容易的。
values, just remember that, it's pretty easy.

36
00:02:12.389 --> 00:02:16.530
我们有解构，解构是你可以做的事情
We have Destructuring, destructuring is something you can do and

37
00:02:16.530 --> 00:02:20.259
let和can语句，以及赋值语句中的语句。
let and can't statements, and also in assignment statements.

38
00:02:20.259 --> 00:02:24.610
在那里我们可以创建新的变量和
Where we can create new variables and

39
00:02:24.610 --> 00:02:27.509
同时从某个对象初始化它们。
initialize them from some object at the same time.

40
00:02:27.509 --> 00:02:32.099
所以同样不是一个大的改变，不会让我们做我们以前做不到的事情，但是
So again not a big change, doesn't let us do anything we couldn't do before but

41
00:02:32.099 --> 00:02:33.639
这是一种方便，是的。
it is a convenience, yeah.

42
00:02:33.639 --> 00:02:36.770
&gt；&gt；演讲者2：我想你说过冻结是为了价值观，你的意思是冻结是为了
&gt;&gt; Speaker 2: I think you said freezing is for values, did you mean freezing is for

43
00:02:36.770 --> 00:02:38.020
物品？
objects?

44
00:02:38.020 --> 00:02:39.240
&gt；&gt；Speaker 1：对象是值。
&gt;&gt; Speaker 1: Objects are values.

45
00:02:39.240 --> 00:02:40.280
&gt；&gt；扬声器2：好的，是的。
&gt;&gt; Speaker 2: Okay, yeah.

46
00:02:40.280 --> 00:02:41.879
&gt；&gt；扬声器1：理论上你可以冻结号码，
&gt;&gt; Speaker 1: In theory you could freeze numbers,

47
00:02:41.879 --> 00:02:44.879
只是它们已经被冻结了，而且字符串已经被冻结了。
except they're already frozen, and strings are already frozen.

48
00:02:44.879 --> 00:02:45.858
所以你不需要冷冻它们。
So you don't need to freeze those.

49
00:02:45.858 --> 00:02:49.659
&gt；&gt；Speaker 2：一次跟进，除了嵌套对象之外，还有什么？
&gt;&gt; Speaker 2: One follow up, what apart about nested objects?

50
00:02:50.719 --> 00:02:52.590
&gt；&gt；扬声器1：它只冻结外部的，
&gt;&gt; Speaker 1: It only freezes the outer one,

51
00:02:52.590 --> 00:02:54.128
语言中没有深深的冻结。
there is no deep freeze in the language.

52
00:02:55.360 --> 00:02:57.734
&gt；&gt；扬声器2：所以你必须进行递归冻结。
&gt;&gt; Speaker 2: So you have to do a recursive freeze.

53
00:02:57.734 --> 00:02:59.841
&gt；&gt；演讲者1：如果你关心这一点，你必须下降到语言和
&gt;&gt; Speaker 1: If you care about that, you have to descend into the language and

54
00:02:59.841 --> 00:03:00.514
冻结每个级别。
freeze each level.

55
00:03:05.375 --> 00:03:09.724
&gt；&gt；扬声器1：然后我们有WeakMap，WeakMap是一个非常好的东西。
&gt;&gt; Speaker 1: Then we have WeakMap, WeakMap is a really nice thing.

56
00:03:09.724 --> 00:03:12.939
WeakMap的工作方式与对象的工作方式相同。
WeakMap works the way objects should work.

57
00:03:12.939 --> 00:03:18.870
使用WeakMap，您可以获取任何JavaScript值并将其用作键，然后
With a WeakMap you can take any JavaScript value and use it as a key and then

58
00:03:18.870 --> 00:03:23.680
将任何其他值与其关联，这是对象应该工作的方式。
associate any other value with it which is the way object should have worked.

59
00:03:23.680 --> 00:03:27.729
而且它还有一个很好的属性，它不会为其路由密钥
And it also has a nice property that it does not route the keys for

60
00:03:27.729 --> 00:03:29.439
垃圾收集的目的。
the purpose of garbage collecting.

61
00:03:29.439 --> 00:03:35.509
因此，如果对象仍然存在的唯一位置是作为
So if the only place where an object still exists is as the key of a property in

62
00:03:35.509 --> 00:03:40.219
一个WeakMap，它会被自动垃圾收集，这是辉煌的。
a WeakMap, it will get garbage collected automatically, which is brilliant.

63
00:03:40.219 --> 00:03:43.900
这意味着我们可以编写一类应用程序
So that means there is a class of applications which we can write in

64
00:03:43.900 --> 00:03:48.229
JavaScript现在使用了我们以前无法用这种语言编写的WeakMap，
JavaScript now using WeakMap that we could not write in the language before,

65
00:03:48.229 --> 00:03:49.689
这真的很好。
which is really nice.

66
00:03:49.689 --> 00:03:54.210
WeakMap最大的问题是它可能是有史以来在要素上使用的最糟糕的名称
The biggest problem with WeakMap is it has maybe the worst name ever put on a feature

67
00:03:54.210 --> 00:03:55.840
编程语言的。
of a programming language.

68
00:03:55.840 --> 00:03:58.810
因为谁想使用一个叫做WeakMap的东西，对吧？
Because who wants to use something called a WeakMap, right?

69
00:04:00.039 --> 00:04:02.389
但实际上这真的是一件好事。
But it's actually a really good thing.

70
00:04:02.389 --> 00:04:07.860
这只是一个非常糟糕的名字，我们有Megastring文字。
It's just a really bad name and we have Megastring literals.

71
00:04:07.860 --> 00:04:14.495
我们有反勾号，我们现在可以用它来制作可以散布很多行的字面值，
We have the back tick which we can now use to make literals that can spam many lines,

72
00:04:14.495 --> 00:04:18.646
这里有一个正则表达式的例子。
so here's are an example of a regular expression.

73
00:04:20.406 --> 00:04:23.934
&gt；&gt；Speaker 1：这个特定的正则表达式匹配所有数字
&gt;&gt; Speaker 1: This particular regular expression matches all of the number

74
00:04:23.934 --> 00:04:25.500
是ES6的字面值。
literals that are an ES6.

75
00:04:27.120 --> 00:04:30.410
你可以看到我为什么不喜欢正则表达式，因为
And you can see why I don't like regular expressions because

76
00:04:30.410 --> 00:04:32.180
你不能从这个权利中得到任何意义。
you can't make any sense out of this right.

77
00:04:32.180 --> 00:04:37.730
只是看看，这只是噪音，真的很难理解它是关于什么的。
Just looking at that, it's just noise it's really hard to understand what it's about.

78
00:04:37.730 --> 00:04:42.389
所以我现在可以让事情变得更简单，我这里有一个函数，我们将
So I can make things all easier now, I've got a function here which we'll

79
00:04:42.389 --> 00:04:46.850
调用正则表达式构造函数，以字符串形式传递它
call the regular expression constructor passing it in a string

80
00:04:48.629 --> 00:04:51.750
但首先，它将删除该字符串中的所有空格。
but first it will remove all of the spaces from that string.

81
00:04:54.199 --> 00:04:57.509
所以现在，我可以使用这些巨型文字之一
And so now, I can use one of these mega literals

82
00:04:57.509 --> 00:05:00.182
写出包含所有空格的内容。
to write it out with all the whitespace in it.

83
00:05:00.182 --> 00:05:02.439
其中有空格，
And with whitespace in it,

84
00:05:02.439 --> 00:05:06.610
正则表达式并没有那么糟糕，我们得到了空格。
regular expressions aren't quite that bad, we get spaces between.

85
00:05:07.620 --> 00:05:10.009
每个元素和我可以将它们排列起来
Each of the elements and I can line them up and

86
00:05:10.009 --> 00:05:13.610
你可以看到发生了什么，所以我们现在有了二进制文字。
you can kind of see what's going on, so we now have binary literals.

87
00:05:13.610 --> 00:05:16.620
您可以使用零B，后跟零和一，然后
You can have zero B followed by zeros and ones and

88
00:05:16.620 --> 00:05:20.819
我们有一个字面上的，我仍然不确定这些。
we've got aka literal which I'm still not sure about those.

89
00:05:20.819 --> 00:05:25.449
你得到一个0代表零，然后是八进制数字
You've got an 0 for a zero and then octal digits and

90
00:05:25.449 --> 00:05:28.470
我们一直都有黑客和浮点数。
we've always had the hacks and the floating point.

91
00:05:29.910 --> 00:05:33.649
所以这非常简洁，这是一种更好的读取正则表达式的方法。
So that's pretty neat, this is a much nicer way of reading regular expressions.

92
00:05:33.649 --> 00:05:37.000
仍然有关于巨型文字的事情，我不喜欢。
There are still things about the mega literals and I don't like.

93
00:05:37.000 --> 00:05:42.550
反勾号是我们得到的最小的运算符
That back tick is the smallest operator we've got and

94
00:05:42.550 --> 00:05:46.340
它是用来支撑我们曾经拥有过的最大的建筑。
it's used to bracket the biggest structures we've ever had.

95
00:05:46.340 --> 00:05:49.649
所以这里有可能会误读，所以
So there is potential for misreading here so

96
00:05:49.649 --> 00:05:52.740
我们必须对此保持谨慎，但我认为这可能是一件好事。
we're gonna have to be cautious with this but I think this is probably a good thing.

97
00:05:54.970 --> 00:05:58.220
同样正则表达式，如果您正在编写正则表达式
And again regulex, if you're writing regular expressions

98
00:05:58.220 --> 00:06:00.399
即使有了空格，你还是想起诉Regulex。
even with the whitespace you still wanna be suing regulex.

99
00:06:03.050 --> 00:06:10.189
所以我们有肥大的箭头功能，或者简称为放屁。
So we've got fat arrow functions or fart for short.

100
00:06:10.189 --> 00:06:14.399
所以这里的动机，有人抱怨说
So the motivation here, there are people who are complaining that

101
00:06:14.399 --> 00:06:17.170
使用函数时，您必须键入八个字母。
with function you have to type eight letters.

102
00:06:17.170 --> 00:06:23.959
你必须F you N，我说这太多了，不能打字，我说好的
You have to F you N, and I said that's too much to type and I said well there

103
00:06:23.959 --> 00:06:28.480
这些新东西现在叫做键盘后排，读起来太多了。
are these new things now called keyboard back rows, it's too much to read.

104
00:06:30.120 --> 00:06:31.819
好的，所以我们添加了它们。
Okay, so we added them.

105
00:06:31.819 --> 00:06:36.759
所以它是编写返回值的函数的缩写形式。
So it's a short form for writing a function that will return a value.

106
00:06:36.759 --> 00:06:40.560
所以我们得到了参数列表，我们得到了名字，然后我们得到了放屁和
So we got the parameter list, we got name and then we got the fart and

107
00:06:40.560 --> 00:06:45.019
然后我们得到它之后的返回值。
then we've got the return value after it.

108
00:06:45.019 --> 00:06:46.459
因此，您不必编写函数和
So, you don't have to write function and

109
00:06:46.459 --> 00:06:49.810
你不需要写回执，除非这会失败。
you don't have to write return except this will fail.

110
00:06:50.879 --> 00:06:54.279
这看起来像是一个小的迷你构造函数，它将返回一个新的
This looks like it's a little mini constructor that's gonna return a new

111
00:06:54.279 --> 00:06:54.973
反对吧？
object, right?

112
00:06:54.973 --> 00:06:58.730
它将返回一个新的东西，其中的id是我们传递的名字，
It's gonna return a new thing where the id is whatever the name is that we passed,

113
00:06:58.730 --> 00:06:59.579
这会失败的。
this is going to fail.

114
00:07:01.509 --> 00:07:06.560
相反，它会给你一个返回undefined的函数，这是不好的。
Instead it's going to give you a function that returns undefined, which is not good.

115
00:07:06.560 --> 00:07:11.089
这是因为语言中的句法歧义，
And it's because of a syntactic ambiguity in the language,

116
00:07:11.089 --> 00:07:13.509
委员会在做这件事的时候意识到了这一点，
the committee was aware of this when they did it,

117
00:07:15.040 --> 00:07:19.110
我们只是不断地添加新的坏部分，我们无法停止这样做。
we just keep adding new bad parts we can't stop doing it.

118
00:07:19.110 --> 00:07:22.069
因此，正因为如此，我并不是一个很喜欢这些东西的人。
So because of that I'm not a big fan of these.

119
00:07:22.069 --> 00:07:23.870
&gt；&gt；扬声器3：所以它会编译，但不会运行。
&gt;&gt; Speaker 3: So it will compile but it won't run.

120
00:07:23.870 --> 00:07:24.990
&gt；&gt；扬声器1：它将编译，
&gt;&gt; Speaker 1: It will compile,

121
00:07:24.990 --> 00:07:28.730
它将运行，当您调用它时，它将返回undefined。
it will run, it will return undefined when you call it.

122
00:07:28.730 --> 00:07:30.738
您将不会获得您试图构造的新对象。
You will not get the new object that you're trying to construct.

123
00:07:32.100 --> 00:07:33.930
我们一直这样对自己
We keep doing this to ourselves,

124
00:07:33.930 --> 00:07:36.939
继续这样对你，它实际上是如何工作的。
keep doing this to you, how that actually works.

125
00:07:36.939 --> 00:07:38.790
&gt；&gt；演讲者2：因为括号不明确？
&gt;&gt; Speaker 2: Because the brackets are ambiguous?

126
00:07:38.790 --> 00:07:40.403
&gt；&gt；演讲者1：是的，因为括号是模棱两可的。
&gt;&gt; Speaker 1: Yeah, because the brackets are ambiguous.

127
00:07:40.403 --> 00:07:46.180
他们有很多方法可以消除它的歧义，
There are number of ways they could have disambiguated it,

128
00:07:46.180 --> 00:07:47.769
但他们却决定制造它们。
but they decide instead to make them.

129
00:07:48.920 --> 00:07:51.779
&gt；&gt；扬声器3：几个快速[笑]，因为那不是你放进去的
&gt;&gt; Speaker 3: A couple quick [LAUGH] because that's not what you put inside

130
00:07:51.779 --> 00:07:55.079
括号实际上不是函数的内容。
the brackets isn't really the contents of a function.

131
00:07:55.079 --> 00:07:57.370
通常，函数将返回。
Typically, a function would return.

132
00:07:58.829 --> 00:08:00.500
我很困惑，我把这个搞糊涂了。
I'm confused about, I'm confusing this.

133
00:08:00.500 --> 00:08:03.329
我只是用另一种语言放屁。
I just fart with what we're using in another language.

134
00:08:03.329 --> 00:08:07.879
在打字稿中，我认为，他们在打字稿中加入了var。
In TypeScript, I think, they put var in TypeScript.

135
00:08:07.879 --> 00:08:13.029
我一直在用它，我用它来调用一个函数来做一些事情
I've been using it, I'm using it to call a function to do something

136
00:08:13.029 --> 00:08:13.860
&gt；&gt；扬声器1：所以这将适用于
&gt;&gt; Speaker 1: So this will work for

137
00:08:13.860 --> 00:08:17.069
很多其他目的，它失败的地方，
lots of other purposes, the place where it fails,

138
00:08:17.069 --> 00:08:21.629
就好像你试图返回一个新的对象文字一样。
as if you're trying to return a new object literal.

139
00:08:21.629 --> 00:08:25.620
&gt；&gt；扬声器3：在这个X var X等于的另一边。
&gt;&gt; Speaker 3: You would have on the other side of this X var X equals.

140
00:08:26.779 --> 00:08:30.358
&gt；&gt；扬声器1：是的，或者你传递这个更有可能将这个作为参数传递给另一个
&gt;&gt; Speaker 1: Yeah, or you pass this more likely pass this as an argument to another

141
00:08:30.358 --> 00:08:33.267
函数，这是这些函数最常见的用法之一。
function That's one of the most common uses for these.

142
00:08:36.408 --> 00:08:40.759
&gt；&gt；演讲者1：所以不管怎样，继续，还有很多其他不好的部分
&gt;&gt; Speaker 1: So anyway moving on, and there are lots of other bad parts in

143
00:08:40.759 --> 00:08:45.113
该语言也类似于产出率运算符的生成器，
the language too like generators with the yield operator,

144
00:08:45.113 --> 00:08:47.830
我想那可能是个错误。
I think that was probably a mistake.

145
00:08:47.830 --> 00:08:51.820
它增加了很多复杂性，但没有多少价值和某种程度上锁定了人们
It adds a lot of complexity and not much value and kind of locks people into

146
00:08:51.820 --> 00:08:55.399
我认为我们应该从模式中进化出来
patterns which I think are things that we should be evolving away from and

147
00:08:55.399 --> 00:08:56.960
不会被困在里面。
not getting trapped in.

148
00:08:56.960 --> 00:08:59.700
还有很多我们还没有足够经验的其他新功能
A lot of the other new features we haven't had enough experience with

149
00:08:59.700 --> 00:09:00.269
他们还不知道。
them yet to know.

150
00:09:00.269 --> 00:09:03.590
如果他们是好的部分或坏的部分，但有一个部分
If they're going to be good parts or bad parts but there is one part

151
00:09:03.590 --> 00:09:08.009
我相信这将是一个非常糟糕的部分，这就是课堂。
that I'm confident is going to be a very, very bad part and that is class.

152
00:09:09.700 --> 00:09:16.039
这是ES6中请求最多的新功能，主要是由
This was the most requested new feature for ES6, it was mostly requested by

153
00:09:16.039 --> 00:09:20.139
不得不转向JavaScript并对此感到不满的Java程序员。
Java programmers who were having to move into JavaScript and were unhappy about it.

154
00:09:20.139 --> 00:09:22.779
然后说“请”你能把JavaScript转换成Java吗
And saying please can you turn JavaScript into Java so

155
00:09:22.779 --> 00:09:26.649
我们不需要学习这种蹩脚的语言，所以我们就这么做了。
we don't have to learn this crappy language and so we did that.

156
00:09:26.649 --> 00:09:29.340
只是我们实际上并没有添加我们所做的类
Except we didn't actually add class what we did

157
00:09:29.340 --> 00:09:34.039
我们在已经存在的东西的原型之上添加了语法糖。
was we added syntactic sugar on top of the prototype of stuff that's already there.

158
00:09:34.039 --> 00:09:36.409
所以当你进入边缘时，
So when you get down into the edges,

159
00:09:36.409 --> 00:09:39.159
它不会像你期望的那样工作。
it's not going to work the way you expect it will.

160
00:09:39.159 --> 00:09:44.049
但更糟糕的是，它让你陷入了古典的心态
But worse than that is it keeps you trapped in the mindset of the classical

161
00:09:44.049 --> 00:09:48.370
模型，这意味着您永远不会学习使用功能模型。
model, which means you will never learn to use the functional model.

162
00:09:49.639 --> 00:09:52.389
而且你也没有强大的类型系统
And also you don't have the strong type system

163
00:09:52.389 --> 00:09:54.730
你需要它来处理课程。
that you need in order to deal with classes.

164
00:09:54.730 --> 00:09:57.080
所以我很有信心
And so I'm pretty confident

165
00:09:57.080 --> 00:10:01.370
那些将要使用课程的人会觉得自己是清白的。
that the people who are gonna be using classes are gonna feel vindicated.

166
00:10:01.370 --> 00:10:03.600
它在标准中，我有权使用它。
It's in the standard, I have a right to use it.

167
00:10:03.600 --> 00:10:04.859
这些都是好东西。
It's all that good stuff.

168
00:10:04.859 --> 00:10:09.090
但他们永远学不会有效地使用这种语言。
But they will never learn to use the language effectively.

169
00:10:09.090 --> 00:10:12.620
他们会回到自己的坟墓，永远不会知道自己有多悲惨。
They will go to their graves never knowing how miserable they were.
