WEBVTT

1
00:00:00.000 --> 00:00:03.815
[音乐]
[MUSIC]

2
00:00:03.815 --> 00:00:07.751
&gt；&gt；Douglas Crockford：我们有一个日期函数，它的灵感来自于Java的日期
&gt;&gt; Douglas Crockford: We have a date function which was inspired by Java's Date

3
00:00:07.751 --> 00:00:12.509
类，它在1995年引入时还没有准备好Y2K。
class, which was not Y2K ready when it was introduced in 1995.

4
00:00:12.509 --> 00:00:15.500
我不知道他们是不是认为语言会围绕这一点
I don't know if they didn't think the language was going to be around that

5
00:00:15.500 --> 00:00:18.260
如果他们没有预见到它的到来或者交易是什么。
long or if they didn't see it coming or what the deal was.

6
00:00:18.260 --> 00:00:19.600
但我们挺过来了。
But we survived it.

7
00:00:19.600 --> 00:00:22.410
万岁，而且它已经被修复了，所以我们得到了它。
Hooray, and it's been fixed, so we got that.

8
00:00:24.089 --> 00:00:28.670
我们得到了从Perl4借用的正则表达式。
We got regular expressions which were borrowed from Perl 4.

9
00:00:28.670 --> 00:00:33.030
这是一个与正则表达式文字匹配的正则表达式文字。
This is a regular expression literal that matches regular expression literals.

10
00:00:34.560 --> 00:00:39.740
这就是我所说的，我讨厌这个大会的地方是
That's what I claim, the thing that I hate about this convention is that

11
00:00:39.740 --> 00:00:43.140
如果有一个长度超过一英寸或两英寸的正则表达式，它是
if you have a regular expression that's longer than an inch or two, it's

12
00:00:43.140 --> 00:00:47.982
真的很难有任何信心它包含你认为它包含的东西，
really hard to have any confidence that it contains what you think it contains,

13
00:00:47.982 --> 00:00:50.950
以便它匹配或拒绝您认为它将匹配和拒绝的内容。
so that it matches or rejects what you think it will match and reject.

14
00:00:52.500 --> 00:00:56.259
我承认我写了几英尺长的正则表达式文字
And I will confess I've written regular expression literals that are several feet

15
00:00:56.259 --> 00:00:57.719
很久了，我并不以此为荣。
long and I am not proud of that.

16
00:00:59.079 --> 00:01:02.079
但是语言并没有让它变得容易，因为
But the language doesn't make it easy to do because

17
00:01:02.079 --> 00:01:03.990
它们都必须被卷在一起。
they all have to be scrunched together.

18
00:01:03.990 --> 00:01:07.750
你甚至不能在它们中使用空格来分隔元素
You can't even use whitespace in them to kind of separate the elements so

19
00:01:07.750 --> 00:01:09.599
你可以看到它在做什么。
you can see what it's doing.

20
00:01:09.599 --> 00:01:11.989
和所有的粉碎在一起，这几乎是不可能的
And all smushed together, it's virtually impossible for

21
00:01:11.989 --> 00:01:13.810
人类来破译那是什么。
human to decipher what that is.

22
00:01:13.810 --> 00:01:16.030
幸运的是，网络上有一种叫做Regulex的东西。
Fortunately, there is something on the web called Regulex.

23
00:01:17.280 --> 00:01:20.579
然后给Regulex一个正则表达式文字，然后
And you give a regular expression literal to Regulex and

24
00:01:20.579 --> 00:01:24.689
它将为您提供正则表达式的铁路图。
it will give you a railroad diagram of what that regular expression does.

25
00:01:24.689 --> 00:01:26.620
所以你可以看到它的作用
So you can see what it does and

26
00:01:26.620 --> 00:01:30.400
你可以很好地理解它的行为。
you can have a good understanding of how it will behave.

27
00:01:30.400 --> 00:01:32.911
我不会在不运行它的情况下编写另一个正则表达式
I will not write another regular expression without running it

28
00:01:32.911 --> 00:01:33.676
通过Regulex
through Regulex.

29
00:01:33.676 --> 00:01:35.227
强烈推荐。
Highly, highly recommended.

30
00:01:35.227 --> 00:01:36.210
是吗？&gt；&gt；扬声器2：查找
Yeah? &gt;&gt; Speaker 2: Find

31
00:01:36.210 --> 00:01:39.014
你自己写的正则表达式太长了，
yourself writing a regular expression that's too many inches long,

32
00:01:39.014 --> 00:01:46.250
你能拿一根小一点的绳子吗？&gt；&gt；Douglas Crockford：可以，
can you just get a smaller string? &gt;&gt; Douglas Crockford: Yeah,

33
00:01:46.250 --> 00:01:49.222
谢谢你。&gt；&gt；观众：[笑]
thank you for that. &gt;&gt; Audience: [LAUGH]

34
00:01:49.222 --> 00:01:51.293
&GT；&GT；道格拉斯·克罗克福德：我必须这样做，对不起。
&gt;&gt; Douglas Crockford: I had to, sorry.

35
00:01:51.293 --> 00:01:52.182
&gt；&gt；扬声器2：不，你不必这样做。
&gt;&gt; Speaker 2: No you didn't have to.

36
00:01:52.182 --> 00:01:54.358
&gt；&gt；观众：[笑]
&gt;&gt; Audience: [LAUGH]

37
00:01:54.358 --> 00:01:55.192
&gt；&gt；Douglas Crockford：所以你可能
&gt;&gt; Douglas Crockford: So you're probably

38
00:01:55.192 --> 00:01:56.865
想知道好的部分什么时候开始。
wondering when do the good parts start.

39
00:01:56.865 --> 00:01:59.370
我还没有听到任何好的部分。
I haven't heard any good parts yet.

40
00:01:59.370 --> 00:02:02.750
函数，函数是最好的部分，我们将在下个小时讨论这些。
Functions, functions are the good part and we'll talk about those in the next hour.

41
00:02:05.129 --> 00:02:10.210
所以在JavaScript中，除了null和undefined之外，所有的值都是对象。
So in JavaScript all values are objects except null and undefined.

42
00:02:10.210 --> 00:02:13.289
这些就是有时所说的最低值。
These are what are sometimes called bottom values.

43
00:02:13.289 --> 00:02:17.110
对于一种语言是否应该有任何底值，存在一些争论。
And there's some debate as to whether a language should have any bottom values?

44
00:02:17.110 --> 00:02:20.503
在这个问题上没有争论，一种语言应该有两个底值吗？
There's no debate on the question, should a language have two bottom values?

45
00:02:20.503 --> 00:02:23.490
答案是绝对没有，这没有任何意义。
The answer is absolutely not, that doesn't make any sense.

46
00:02:23.490 --> 00:02:24.479
但我们有两个。
But we have two.

47
00:02:26.280 --> 00:02:30.530
他们的行为很相似，但他们的行为并不完全相同，所以
And they act a lot alike but they don't act exactly alike, so

48
00:02:30.530 --> 00:02:31.468
它们不能互换。
they're not interchangeable.

49
00:02:32.530 --> 00:02:35.670
但有些人可以互换使用，这是一种混乱，
But some people use them interchangeably which is a confusion,

50
00:02:35.670 --> 00:02:38.340
混乱会导致错误，我不喜欢这样。
confusion causes bugs, I don't like that.

51
00:02:38.340 --> 00:02:42.960
所以我建议只使用其中的一个，我选择使用的那个
So I recommend using only one of them and the one I choose to use

52
00:02:42.960 --> 00:02:47.689
是未定义的，因为它是语言本身使用的，但是
is undefined because that's the one that the language itself uses, but

53
00:02:47.689 --> 00:02:51.479
它们都用于表示不是对象的值。
both of them are used to represent values that are not objects.

54
00:02:51.479 --> 00:02:53.900
这些是语言中唯一不是对象的值。
These are the only values in the language that are not objects.

55
00:02:55.439 --> 00:02:59.680
所以如果你试图从其中一个中检索一个值，你将不会得到任何东西。
So if you try to retrieve a value from one of these, you're not gonna get anything.

56
00:02:59.680 --> 00:03:02.939
如果您尝试将它们作为函数执行，它们将抛出异常。
If you try to execute them as functions, they'll throw exceptions.

57
00:03:04.259 --> 00:03:07.379
它们只是用来表示某事的缺席或结束。
They're just used to indicate the absence or the end of something.

58
00:03:09.300 --> 00:03:12.060
所以我建议使用undefined。
So I recommend using undefined.

59
00:03:13.099 --> 00:03:16.699
选择Undefined，因为它是语言本身使用的语言。
Choose undefined because it is the one that the language itself uses.

60
00:03:16.699 --> 00:03:20.900
所以如果我只用一种语言，那就把语言作为一种语言来使用。
So if I'm only gonna use one, let's use the language as one.

61
00:03:20.900 --> 00:03:23.566
所以它是变量和参数的默认值。
So it's the default value for variables and parameters.

62
00:03:23.566 --> 00:03:29.759
因此，如果您创建了一个变量，但没有对其进行初始化，
So if you create a variable but you don't initialize it,

63
00:03:29.759 --> 00:03:32.889
它实际上是用未定义的值为您初始化的。
it actually gets initialized for you with the undefined value.

64
00:03:34.159 --> 00:03:39.538
如果您有一个函数，但没有传递足够的参数，
And if you have a function and you don't pass enough arguments in,

65
00:03:39.538 --> 00:03:43.199
缺少的参数将绑定到undefined。
the missing parameters will get bound to undefined.

66
00:03:44.439 --> 00:03:47.759
它是缺少对象和数组成员的值。
It's a value of missing members of objects and arrays.

67
00:03:47.759 --> 00:03:51.829
因此，他试图检索一个属性或元素，但它不在那里。
So he tried to retrieve a property or an element and it isn't there.

68
00:03:51.829 --> 00:03:54.409
您不会得到运行时警告，也不会得到编译时警告。
You don't get a runtime warning, you don't get a compile time warning.

69
00:03:54.409 --> 00:03:58.115
相反，您得到的是未定义的值，这实际上是一件非常好的事情。
Instead, you get the undefined value which is actually a very nice thing.

70
00:03:58.115 --> 00:04:01.219
因为它可以让你毫不费力地思考物体，
Because it allows you to reflect on objects without any effort,

71
00:04:01.219 --> 00:04:04.909
你刚刚问了，你得到了其中一个，如果你得到一个值
you just asked, you got one of those and if you get a value back and

72
00:04:04.909 --> 00:04:06.639
你得到了什么，或者如果你没有，那么你没有。
you got something or if you didn't, then you didn't.

73
00:04:08.599 --> 00:04:14.139
但需要注意的一件事是，您可以将未定义的存储到对象中，并且
One thing to watch out for though is that you can store undefined into an object and

74
00:04:14.139 --> 00:04:16.129
然后你可以读回未定义的内容，但是
then you can read that undefined back but

75
00:04:16.129 --> 00:04:21.040
你不能很容易地说，我得到了一个未定义的，存储在对象中或者
you can't easily tell, I'm I getting an undefined that was stored in the object or

76
00:04:21.040 --> 00:04:24.050
我得到一个未定义的，因为它没有存储在对象中？
I'm getting an undefined because it wasn't stored in the object?

77
00:04:24.050 --> 00:04:25.459
他们看起来都一样。
They both look the same.

78
00:04:25.459 --> 00:04:27.540
这是一种混淆，我不喜欢混淆。
That's a confusion, I don't like confusion.

79
00:04:29.579 --> 00:04:33.329
JavaScript中有一种类型的运算符，它将返回一个字符串
There's a type of operator in JavaScript which will return a string

80
00:04:33.329 --> 00:04:35.139
识别某物的类型。
identifying what the type of something is.

81
00:04:36.420 --> 00:04:40.879
例如，如果您向它传递一个对象，它将返回一个String对象，这很棒。
For example, if you pass it an object, it returns a string object which is great.

82
00:04:40.879 --> 00:04:44.159
你给它传递一个函数，它会返回一个很好的单词function。
You pass it a function, it returns the word function which is great.

83
00:04:44.159 --> 00:04:49.819
如果向它传递一个数组，它将返回不是
If you pass it an array, it returns object which is not

84
00:04:49.819 --> 00:04:53.480
技术上是错误的，因为所有东西都是对象，但肯定没有用处。
technically wrong because everything is an object but it's certainly not useful.

85
00:04:53.480 --> 00:04:56.550
您希望它返回数组，因为它就是这样。
You'd like it to return array because that's what it is.

86
00:04:56.550 --> 00:05:01.149
所以，但是如果你传递它否，它返回对象是错误的。
So, but if you pass it no, it returns object which is just wrong.

87
00:05:02.199 --> 00:05:03.970
这是没有借口的。
There's no excuse for that.

88
00:05:03.970 --> 00:05:06.769
它并不会使检测某物是否为空变得困难
It doesn't make it hard to detect if something is null

89
00:05:06.769 --> 00:05:10.910
因为只有一个NULL值，所以你可以问，你是三倍等于NULL吗？
because there's only one null value, so you can ask, are you triple equal to null?

90
00:05:10.910 --> 00:05:12.459
非常有效。
That's very effective.

91
00:05:12.459 --> 00:05:15.259
问题是，你试图弄明白，你是一个物体吗？
The problem is, you're trying to figure out, are you an object?

92
00:05:15.259 --> 00:05:19.279
因为如果你不是一个物体，我下一步就不想尝试某些东西。
Because if you're not an object there are certain things I don't want to try next.

93
00:05:19.279 --> 00:05:24.295
这个测试失败了，这真的，真的很糟糕。
And this test fails for that, which is really, really bad.

94
00:05:24.295 --> 00:05:27.959
所以我们现在有Array.isArray，
So we have Array.isArray now,

95
00:05:27.959 --> 00:05:32.172
它是在ES5中添加到语言中的。
it was added to the language in ES5.

96
00:05:32.172 --> 00:05:36.691
虽然它看起来非常丑陋，但它最终还是允许
While it's extremely ugly looking it does finally allow

97
00:05:36.691 --> 00:05:41.408
我们来检测某个值是否是数组，这是很好的。
us to detect if some value is an array or not, which is good.

98
00:05:41.408 --> 00:05:44.180
这就是它在旧浏览器上的实现方式。
And this is how it is implemented on older browsers.

99
00:05:46.980 --> 00:05:52.779
JavaScript是一种boolish语言，因为每个值都是真的或假的。
JavaScript is a boolish language in that every value is truthy or falsy.

100
00:05:52.779 --> 00:05:55.670
错误的值是false，null，undefined，
The falsy values are false, null, undefined,

101
00:05:55.670 --> 00:05:58.860
空字符串、数字0和NaN。
the empty string, the number 0, and NaN.

102
00:05:58.860 --> 00:06:01.300
所有其他价值都是真实的。
All other values are truthy.

103
00:06:01.300 --> 00:06:05.600
包括字符串0，字符串false，所有对象，
Including the string 0, the string false, all objects,

104
00:06:05.600 --> 00:06:08.259
所有数组，即使它们是空的，所有这些都是真实的。
all arrays even if they're empty, all those are truthy.

105
00:06:09.980 --> 00:06:11.459
我认为这是一个巨大的错误。
I think this was a huge mistake.

106
00:06:12.810 --> 00:06:17.360
这样做的目的是允许if语句起作用
The purpose of this was to allow if statements to work

107
00:06:17.360 --> 00:06:20.490
在某种程度上类似于C的工作方式。
in a way that's similar to the way C works.

108
00:06:20.490 --> 00:06:24.019
C不是强类型语言。
C is not a strongly typed language.

109
00:06:24.019 --> 00:06:29.129
所以它用0来代表数字0，而FALSE，
And so it uses 0 to represent the number 0, and false,

110
00:06:29.129 --> 00:06:33.920
和NULL以及其他一些东西，
and null and a few other things,

111
00:06:33.920 --> 00:06:39.680
字符串的结尾，我相信还有很多其他的。
end of strings, I'm sure there are lots of others.

112
00:06:39.680 --> 00:06:44.340
因此，C中IF语句的条件是0或不是0，并且
So the condition of an if statement in C is 0 or not 0, and

113
00:06:44.340 --> 00:06:49.898
JavaScript想要看起来像这样，但结果却是一个糟糕的主意。
JavaScript wanted to look like that but it turns out to be a bad idea.

114
00:06:49.898 --> 00:06:56.161
我们明天会看到一些例子。&gt；&gt；Douglas Crockford：JavaScript
We'll see some examples of that tomorrow. &gt;&gt; Douglas Crockford: JavaScript

115
00:06:56.161 --> 00:07:00.769
是一种松散类型的语言，因为这些类型中的任何一种都可以存储在任何变量中
is a loosely typed language in that any of these types can be stored in any variable

116
00:07:00.769 --> 00:07:03.740
或者作为参数传递给任何函数。
or passed as a parameter to any function.

117
00:07:03.740 --> 00:07:08.339
语言不是无类型的，因为正如我们所看到的，我们有很多非常具体的
The language is not untyped because as we had seen we've got a lot of very specific

118
00:07:08.339 --> 00:07:11.149
类型，但它是松散类型的。
types but it's loosely typed.

119
00:07:11.149 --> 00:07:15.480
我认为这是一个很好的部分，尽管这句话非常
And I contend this is a good part and although that statement is very

120
00:07:15.480 --> 00:07:20.620
有争议的是世界上流行的风格呼唤
controversial the prevailing style in the world is calling for

121
00:07:20.620 --> 00:07:24.000
强类型和强类型有很好的论据。
strong typing and there are really good arguments for strong typing.

122
00:07:24.000 --> 00:07:29.910
其论点是，强类型允许编译器及早发现错误。
The argument is that strong typing allows the compiler to find errors very early.

123
00:07:29.910 --> 00:07:35.430
我们越早发现错误，就越有价值。
And the earlier we can find errors, the more valuable that is and that is true.

124
00:07:35.430 --> 00:07:38.329
所以当我第一次开始使用JavaScript时，我非常，
And so when I first start working with JavaScript, I was very,

125
00:07:38.329 --> 00:07:41.480
非常紧张，因为这是一种松散类型的语言，
very nervous because this is a loosely typed language,

126
00:07:41.480 --> 00:07:45.519
任何类型都可以作为任何参数传入或存储在任何属性中。
any kind of type can be passed in as any parameter or be stored in any property.

127
00:07:45.519 --> 00:07:50.062
你怎么能有信心任何事情都会成功，
How could you have any confidence that anything's ever gonna work,

128
00:07:50.062 --> 00:07:53.831
因为在任何时候都要为任何事情做好准备是很疯狂的。
cuz gotta be prepared for anything at any time was crazy.

129
00:07:53.831 --> 00:07:59.427
但我在使用这种语言的过程中发现，令我惊讶的是，
But what I found in working with the language was that to my surprise,

130
00:07:59.427 --> 00:08:03.009
我的测试负担没有增加，好吗？
my testing burden did not go up, all right?

131
00:08:03.009 --> 00:08:06.401
我以为我要看着所有这些东西
I thought I was gonna have to be watching for all of these things and

132
00:08:06.401 --> 00:08:10.550
放入我自己的显式类型检查，我很少这样做。
putting in explicit type checks of my own, and I very rarely ever had to do that.

133
00:08:12.060 --> 00:08:16.160
事实上，我发现的是
And in fact, what I found was that the sorts of bugs that

134
00:08:16.160 --> 00:08:21.310
类型检查器可以找到，如果您正在做的话，您可以立即找到
a type checker can find, you find instantly anyway if you're doing

135
00:08:21.310 --> 00:08:24.680
即使是最微不足道的测试，这些东西也会马上出现。
even the most trivial level of testing, those things show up right away.

136
00:08:26.389 --> 00:08:29.300
这种类型的系统在以下方面没有提供帮助
That type systems provide no help in

137
00:08:29.300 --> 00:08:31.389
找到让你夜不能寐的虫子。
finding the bugs that keep you up at night.

138
00:08:34.049 --> 00:08:39.830
最后你做的工作会少很多，因为在一个强大的
And that you end up doing a lot less work because in a strongly

139
00:08:39.830 --> 00:08:44.779
类型化语言你最终会花费大量的时间来对抗类型系统。
typed language you end up spending a lot of time working against the type system.

140
00:08:44.779 --> 00:08:47.230
为了完成你的工作，你需要做一些事情
There are things you need to do in order to get your job done and

141
00:08:47.230 --> 00:08:49.549
类型系统不希望你做这些事情。
the type system doesn't want you doing those things.

142
00:08:49.549 --> 00:08:54.019
所以你必须想办法绕过它，这是很大的努力。
And so you have to figure out ways to get around it and that's a lot of effort.

143
00:08:54.019 --> 00:08:57.980
无论何时进行强制转换，这都意味着类型系统不能满足您的要求。
And any time you cast then that means the type system is failing you.

144
00:08:59.179 --> 00:09:01.659
结果你投的太多了。
And you end up casting way too much.

145
00:09:03.620 --> 00:09:08.029
此外，事实证明，有一大类错误是由类型引起的
Also it turns out there is a large class of errors which are caused by the type

146
00:09:08.029 --> 00:09:08.596
系统。
system.

147
00:09:08.596 --> 00:09:11.754
因为类型系统导致您绕过它，
Because the type system is causing you to circumvent it,

148
00:09:11.754 --> 00:09:15.716
你最终做了很多额外的工作，其中一些工作变成了bug。
you end up doing a lot of extra work and some of that work turns into bugs.

149
00:09:15.716 --> 00:09:18.429
而在JavaScript中，这种情况往往不会发生。
And in JavaScript that tends not to happen.

150
00:09:18.429 --> 00:09:23.649
所以我发现用JavaScript编写正确的程序并不比用Java难，
So I find in JavaScript writing correct programs is not harder than in Java,

151
00:09:23.649 --> 00:09:24.659
我觉得这实际上更容易。
I think it's actually easier.

152
00:09:26.139 --> 00:09:29.340
而且你做的工作少了很多，因为你不是一直都在管理所有的类型，
And you do a lot less work because you're not managing all the types all the time,

153
00:09:30.529 --> 00:09:31.500
这就是我的论点。
that's my argument.

154
00:09:31.500 --> 00:09:35.009
您可能不相信我，如果您正在使用JavaScript get编写，这并不重要
You might not believe me, and it doesn't matter if you're writing in JavaScript get

155
00:09:35.009 --> 00:09:36.919
习惯了因为这就是它的工作原理。
used to it because that's how it works.

156
00:09:39.649 --> 00:09:43.750
所以在JavaScript中，对象是通过引用传递的
So in JavaScript, objects are are passed by reference

157
00:09:43.750 --> 00:09:46.980
不是按值，这意味着不复制对象。
not by value which means that objects are not copied.

158
00:09:46.980 --> 00:09:51.179
事实上，在JavaScript中没有办法，也没有简单的方法来制作对象的副本
In fact, there is no way, no easy way in JavaScript to make a copy of an object

159
00:09:52.220 --> 00:09:54.879
这似乎是一个令人惊讶的遗漏，但是
which seems like a surprising omission but

160
00:09:54.879 --> 00:09:56.923
在实践中，我没有发现这是一个问题。
in practice I've not found it to be a problem.

161
00:09:56.923 --> 00:10:02.090
=运算符比较对象引用，因此
The === operator compares object references so

162
00:10:02.090 --> 00:10:06.043
只有当两个操作数是相同的对象时，它才会给出true。
it'll give you true only if both operands are the same object.

163
00:10:06.043 --> 00:10:10.549
没有简单的测试，是两个非常相似的物体，
There is no easy test for, are two objects very similar,

164
00:10:11.700 --> 00:10:15.049
包含相同的属性，具有相同的值？
containing the same properties, having the same values?

165
00:10:17.110 --> 00:10:21.320
这又一次，似乎是一个奇怪的遗漏，但我没有发现这是一个问题。
That again, seems like a strange omission, but I've not found that to be a problem.
