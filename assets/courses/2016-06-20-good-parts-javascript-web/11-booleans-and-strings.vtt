WEBVTT

1
00:00:00.000 --> 00:00:03.954
[音乐]
[MUSIC]

2
00:00:03.954 --> 00:00:07.407
&gt；&gt；Douglas：所以布尔值，在这种语言中正好有两个布尔值
&gt;&gt; Douglas: So Booleans, there are exactly two Booleans in this language and

3
00:00:07.407 --> 00:00:09.140
它们是真的，也是假的。
they are true and false.

4
00:00:09.140 --> 00:00:10.539
所以万岁，我们做对了。
So hooray, we got that right.

5
00:00:13.359 --> 00:00:14.210
我们有条件。
We have strings.

6
00:00:15.710 --> 00:00:17.809
有人知道为什么叫弦吗？
Does anybody know why they're called strings?

7
00:00:19.079 --> 00:00:21.039
任何人？&gt；&gt；扬声器2：字符的更改。
Anyone? &gt;&gt; Speaker 2: The change of characters.

8
00:00:22.750 --> 00:00:23.679
&gt；&gt；Douglas：原来没有人
&gt;&gt; Douglas: It turns out nobody

9
00:00:23.679 --> 00:00:25.579
知道。&gt；&gt；扬声器2：好的。
knows. &gt;&gt; Speaker 2: Okay.

10
00:00:25.579 --> 00:00:27.129
&gt；&gt；Douglas：我第一次去的地方
&gt;&gt; Douglas: The first place I've been able

11
00:00:27.129 --> 00:00:30.769
为了在引用特定数据类型的文献中找到，
to find in the literature that refers to a specific data type,

12
00:00:30.769 --> 00:00:33.890
这是一个字符序列，是ALGOL 60报告。
which is a sequence of characters, is the ALGOL 60 report.

13
00:00:35.179 --> 00:00:39.841
但那份报告中没有解释他们为什么选择字符串这个词。
But there's nothing in that report which explains why they chose the word string.

14
00:00:39.841 --> 00:00:42.606
当你第一次遇到它的时候，你一定会想，
The first time you encountered it you must have thought,

15
00:00:42.606 --> 00:00:46.340
这很奇怪，因为它看起来不像一根绳子。
well this is strange cuz it doesn't look like a piece of string any way.

16
00:00:46.340 --> 00:00:49.009
那是怎么回事？
So how'd that happen?

17
00:00:49.009 --> 00:00:50.890
我问了那个委员会的约翰·麦卡锡
I asked John McCarthy who was on that committee,

18
00:00:50.890 --> 00:00:54.990
他是Lisp的发明者，为什么他称它为字符串？
he was the inventor of Lisp, why did he call it strings?

19
00:00:54.990 --> 00:01:01.884
他说，好吧，Clanet是用一串符号来做这件事的。
He said, well Clanet was doing this stuff with strings of symbols.

20
00:01:01.884 --> 00:01:06.581
但这并没有真正回答问题，因为在Algol 60的时候
But that didn't really answer the question because at the time of the ALGOL 60

21
00:01:06.581 --> 00:01:11.230
报道说他们会谈论一块是一连串的声明。
report they would talk about a block was a string of statements.

22
00:01:11.230 --> 00:01:15.507
那么，它什么时候变成了具体的字符串呢？
So when did it become specifically a string of characters?

23
00:01:15.507 --> 00:01:18.591
我问了一个他不知道的问题，他真的很生气
And he was really annoyed that I was asking a question he didn't know

24
00:01:18.591 --> 00:01:19.299
答案是。
the answer to.

25
00:01:20.500 --> 00:01:24.664
所以这就是那次谈话的结束，然后他死了，
So that was the end of that conversation and then he died and

26
00:01:24.664 --> 00:01:28.405
他是Lisp委员会最后的幸存者
he was a last survivor of that of the Lisp committee so

27
00:01:28.405 --> 00:01:31.810
我们永远不会知道，也不会知道Algol委员会。
we'll never know, or of the ALGOL committee.

28
00:01:34.020 --> 00:01:37.849
所以不管怎样，我们得到了它们，我们称它们为字符串
So anyway we got them, we call them strings and

29
00:01:37.849 --> 00:01:42.829
我认为我们称它们为字符串是因为可能存在一些CPU架构
I think we call them strings because there may have been some CPU architecture

30
00:01:42.829 --> 00:01:47.640
其将字符链接在一起以形成字符的字符串序列。
which linked characters together to make string sequences of characters.

31
00:01:49.090 --> 00:01:54.224
我认为这是因为我们对弦的操作是什么？
And I think that because what's the operation we do on strings?

32
00:01:54.224 --> 00:01:57.760
它是连接，但是连接意味着形成链接，
It's concatenate, but concatenate means to form links,

33
00:01:57.760 --> 00:02:00.810
这是链条制造中的一种操作。
it's an operation in chain making.

34
00:02:00.810 --> 00:02:05.200
所以你会认为，如果是弦，它应该是领带，或者是切片，或者是风，或者
So you would think if it's strings it should be tie or maybe slice or wind or

35
00:02:05.200 --> 00:02:07.370
弦做的事情。
something that strings do.

36
00:02:07.370 --> 00:02:09.990
所以我们有一些混合的隐喻在进行。
So we've got some mixed metaphors going on.

37
00:02:09.990 --> 00:02:13.490
所以我仍然在搜索文献，试图找出字符串的来源
And so I'm still searching the literature trying to find out where strings came from

38
00:02:13.490 --> 00:02:14.282
但我还没找到。
but I haven't found it yet.

39
00:02:14.282 --> 00:02:17.969
所以不管怎样，我们有了他们，我们有了条件。
So anyway we got them, we got strings.

40
00:02:17.969 --> 00:02:22.319
字符串是0位或更多16位Unicode字符的序列。
A string is a sequence of 0 or more 16-bit Unicode characters.

41
00:02:22.319 --> 00:02:26.844
它的字符是UCS-2意义上的，而不是UTF-16意义上的
It's characters in the sense of UCS-2 not UTF-16

42
00:02:26.844 --> 00:02:31.829
因为没有代理项对的意识。
because there's no awareness of surrogate pairs.

43
00:02:31.829 --> 00:02:33.473
在JavaScript和
At the time that JavaScript and

44
00:02:33.473 --> 00:02:36.957
Java被设计成Unicode将是一个16位字符集。
Java were designed Unicode was gonna be a 16 bit character set.

45
00:02:36.957 --> 00:02:43.659
后来它增长到了21位字符集，而JavaScript并没有意识到这一点。
It later grew to a 21 bit character set and JavaScript is not aware of that.

46
00:02:43.659 --> 00:02:45.300
没有单独的字符类型。
There is no separate character type.

47
00:02:46.610 --> 00:02:49.789
字符表示为长度为1的字符串。
Characters are represented as strings with a length of one.

48
00:02:49.789 --> 00:02:51.569
字符串是不变的，这是好的。
Strings are immutable which is good.

49
00:02:51.569 --> 00:02:55.189
一旦你做了一个字符串，它就不能改变了，它一直都是固定的。
Once you make a string, it cannot be changed, it's fixed for all time.

50
00:02:55.189 --> 00:02:59.389
您可以通过将旧字符串的比特连接在一起来生成新字符串，但是
You can make new strings by concatenating together bits of old strings but

51
00:02:59.389 --> 00:03:01.919
一旦制作好字符串，您就不能更改它。
you cannot change a string once it's made.

52
00:03:01.919 --> 00:03:04.759
相似的字符串是相等的，这是伟大的。
Similar strings are equal which is great.

53
00:03:04.759 --> 00:03:09.830
Java做错了，JavaScript做对了，JavaScript万岁。
Java got that wrong, JavaScript got that right, hooray for JavaScript.

54
00:03:09.830 --> 00:03:13.870
字符串文字可以与换位一起使用单引号或双引号。
String literals can use single quotes or double quotes with escapement.

55
00:03:13.870 --> 00:03:15.900
两者的工作方式完全相同。
Both work exactly the same way.

56
00:03:15.900 --> 00:03:18.159
没有魔术引号或准引号或类似的东西。
No magic quotes or quasi quotes or anything like that.

57
00:03:19.420 --> 00:03:22.719
但是没有理由有两种方法来制作弦，但是我们做了。
But there's no reason to have two ways to make strings but we do.

58
00:03:22.719 --> 00:03:27.879
因此，我建议对外部字符串使用双引号。
So given that I recommend use double quote for external strings.

59
00:03:27.879 --> 00:03:32.770
在程序之外有意义的字符串，如URL和
Strings that make sense outside of the program like URLs and

60
00:03:32.770 --> 00:03:36.150
模板和给用户的注释，诸如此类的东西。
templates and notes to the user, that kind of stuff.

61
00:03:36.150 --> 00:03:41.349
并对内部字符串使用单引号，如属性名称和
And use single quotes for internal strings like the names of properties and

62
00:03:41.349 --> 00:03:43.420
字符常量之类的东西。
character constants and stuff like that.

63
00:03:43.420 --> 00:03:46.460
没有什么可以强制执行这一点，但我认为这是一个很好的惯例。
There's nothing that enforces that but I think it's a good convention.

64
00:03:49.090 --> 00:03:54.150
我们可以使用数字的toString方法将数字转换为字符串。
We can convert a number to a string by using its toString method.

65
00:03:54.150 --> 00:03:59.409
相反，我更喜欢使用全局字符串函数，它做同样的事情，并且
I prefer instead to use the global String function which does the same thing, and

66
00:03:59.409 --> 00:04:05.813
也会在没有toString方法的事情上更好地工作。
will also work better on things that do not have toString methods.

67
00:04:08.189 --> 00:04:12.599
我们可以使用全局数字函数或将字符串转换为数字
We can convert a string into a number by using the global Number function or

68
00:04:12.599 --> 00:04:16.310
通过使用我更喜欢的加号前缀运算符。
by using the plus prefix operator which I prefer.

69
00:04:16.310 --> 00:04:19.699
我们还有一个我不喜欢的parseInt函数。
We also have a parseInt function that I don't like.

70
00:04:19.699 --> 00:04:21.720
parseInt是从Java借用的东西。
parseInt is something that was borrowed from Java.

71
00:04:23.149 --> 00:04:25.050
它会将一个值转换成一个数字，但是
It will convert a value into a number but

72
00:04:25.050 --> 00:04:29.879
它在第一个非数字字符处停止解析。
it stops parsing at the first non-digit character.

73
00:04:29.879 --> 00:04:35.149
它不会告诉你它停在哪里，为什么停下来，或者留下了什么。
And it won't tell you where it stopped, or why it stopped, or what was left over.

74
00:04:35.149 --> 00:04:39.110
通常想知道这一点，因为这可能很重要，但是
And usually wanna know that cuz that can be important but

75
00:04:39.110 --> 00:04:40.220
它不会给你任何线索。
it doesn't give you any clue.

76
00:04:41.430 --> 00:04:45.990
存在一个很大的设计错误，因为如果要解析的字符串以
There was a big design error in that if the string you are parsing starts with

77
00:04:45.990 --> 00:04:50.374
0，它假设您的意思是将其解析为基数为8的八进制。
a 0, it assumes that you meant that to be parsed as base-8, octal.

78
00:04:52.550 --> 00:04:57.853
因此，如果您正在解析诸如日期或时间之类的内容，则可能会有一个08或
And so if you're parsing something like a date or a time which might have an 08 or

79
00:04:57.853 --> 00:05:02.923
09将被解析为0，因为它看到0，进入基数8，
an 09 that will be parsed as a 0 because it sees the 0, goes into base-8,

80
00:05:02.923 --> 00:05:07.779
它看到8，说你不是一个八进制数字，所以我在这里停下来，得到0。
it sees the 8, says you are not an octal digit so I stop here and get the 0.

81
00:05:09.639 --> 00:05:15.446
是的，正因为如此，我建议你总是包括基数论点，
Yeah, so because of that I recommend you always include the radix argument,

82
00:05:15.446 --> 00:05:17.334
上面写着基数是10。
which says base-10.

83
00:05:17.334 --> 00:05:21.197
我们在地球上，该死的，我们有10基数，
We're on planet Earth, damn it, we got base-10,

84
00:05:21.197 --> 00:05:24.776
0到9。&gt；&gt；Douglas：字符串
0 to 9. &gt;&gt; Douglas: Strings

85
00:05:24.776 --> 00:05:30.120
有一个length属性，它告诉您字符串中有多少个16位字符。
have a length property which tells you how many 16-bit characters are in the string.

86
00:05:30.120 --> 00:05:34.259
代理项对将被计为该计数中的两个字符。
Surrogate pairs will be counted as two characters in that count.

87
00:05:36.540 --> 00:05:40.269
字符串是对象，因此它们包含一大堆方法，
Strings are objects and so they contain a big mess of methods,

88
00:05:40.269 --> 00:05:42.769
让你离线查找它们，但是它们很多。
let you look them up offline, but there are a lot of them.

89
00:05:42.769 --> 00:05:44.209
他们中的许多人实际上是非常有用的。
Many of them are actually very useful.

90
00:05:46.750 --> 00:05:49.659
每个字符串都继承自string.prototype。
Every string inherits from string.prototype.

91
00:05:49.659 --> 00:05:51.779
所以如果我们想要添加新的
So if we wanted to add new

92
00:05:53.290 --> 00:05:56.860
方法到字符串，这是我们可以做到这一点的地方。
methods to strings this is the place where we could do that.

93
00:05:56.860 --> 00:06:00.490
同样，这不是应用程序可以做的事情，但是
Again, this is not something applications can do but

94
00:06:00.490 --> 00:06:02.230
这就是我们一直在发展语言的方式。
this is how we've been growing the language.
