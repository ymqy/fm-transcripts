WEBVTT

1
00:00:00.000 --> 00:00:03.876
[音乐]
[MUSIC]

2
00:00:03.876 --> 00:00:06.932
&gt；&gt；Douglas：编写一个接受二进制函数的函数两次，然后
&gt;&gt; Douglas: Write a function twice that takes a binary function and

3
00:00:06.932 --> 00:00:11.990
返回一个一元函数，该函数将其参数传递给二元函数两次。
returns a unary function that passes its argument to the binary function twice.

4
00:00:11.990 --> 00:00:13.679
所以我说的两次是这个意思。
So by twice I mean this.

5
00:00:13.679 --> 00:00:16.602
我们已经得到了Add函数，我们将把11加两次。
We've got the add function we're going to add 11 twice.

6
00:00:16.602 --> 00:00:18.978
好的，那就会产生22个。
Okay, that'll produce 22.

7
00:00:18.978 --> 00:00:20.593
所以我们要把它自动化。
So we're going to automate that.

8
00:00:20.593 --> 00:00:22.660
我们要做两次函数。
We're gonna make a twice function.

9
00:00:22.660 --> 00:00:24.789
我们可以传递Add
We can pass add to that and

10
00:00:24.789 --> 00:00:27.600
它将创建一个双精度函数，它做同样的事情。
it will create a double function which does the same thing.

11
00:00:29.170 --> 00:00:32.039
我们还可以将乘法函数传递给两次。
We could also pass the multiply function to twice.

12
00:00:32.039 --> 00:00:35.159
它将产生一个平方函数，它将事物平方。
It will produce a square function which will square things.

13
00:00:36.450 --> 00:00:39.250
现在，我故意把double这个词拼错了。
Now, I intentionally misspelled the word double.

14
00:00:39.250 --> 00:00:41.546
因为在某些实现中，DOUBLE是保留字。
Because in some implementations, double is reserved word.

15
00:00:41.546 --> 00:00:46.109
如果你拼写正确，你会得到一个不可原谅的语法错误。
And if you spell it correctly, you'll get a syntax error which is inexcusable.

16
00:00:46.109 --> 00:00:49.880
因为Double在这种语言中甚至没有使用。
Since double isn't even used in this language.

17
00:00:49.880 --> 00:00:52.314
所以，我拼错了。
But so, I misspelled it.

18
00:00:52.314 --> 00:00:54.649
我建议你也因为同样的原因拼错它。
I recommend that you misspell it too for the same reason.

19
00:00:54.649 --> 00:00:58.325
所以这里是两次。
So here is twice.

20
00:00:58.325 --> 00:01:00.219
两次取二进制函数。
Twice takes a binary function.

21
00:01:00.219 --> 00:01:02.389
返回接受参数的函数。
Returns a function that takes an argument.

22
00:01:02.389 --> 00:01:06.688
返回使用该参数调用二进制函数两次的结果。
Returns result of calling the binary function with that arguments twice.

23
00:01:06.688 --> 00:01:08.498
所以有两次？
So got twice?

24
00:01:09.579 --> 00:01:11.498
很好，如果你没收到，就写下来。
Very good, if you didn't get it, write it down.

25
00:01:11.498 --> 00:01:13.310
如果你还需要它来做另一件事的话。
If you're gonna need it for another one.

26
00:01:14.329 --> 00:01:15.629
在我们继续下一个之前还有什么问题吗？
Any questions before we go on to the next one?

27
00:01:15.629 --> 00:01:18.653
&gt；&gt；演讲者2：也许是一个愚蠢的问题。
&gt;&gt; Speaker 2: Maybe a dumb question.

28
00:01:18.653 --> 00:01:24.655
我试图弄清楚是否有一种方法可以使用[INAUDIBLE]来定义这一点。
I was trying to figure out if there was a way to define this using [INAUDIBLE].

29
00:01:24.655 --> 00:01:27.343
&GT；&GT；道格拉斯：可能有，但也许你没有这样做也是件好事。
&gt;&gt; Douglas: There probably is but it's probably just as well that you didn't.

30
00:01:27.343 --> 00:01:28.920
&gt；&gt；扬声器2：好的。所以如果我们这么做了
&gt;&gt; Speaker 2: All right. So if we did,

31
00:01:28.920 --> 00:01:32.932
我们会想要改变到那个实现吗？
would we wanna change to that implementation?

32
00:01:32.932 --> 00:01:34.168
&gt；&gt；道格拉斯：这取决于你。
&gt;&gt; Douglas: It's up to you.

33
00:01:34.168 --> 00:01:37.173
今天最重要的是它起作用了。
The most important thing today is that it works.

34
00:01:40.781 --> 00:01:42.659
&gt；&gt；道格拉斯：好了，准备好继续了吗？
&gt;&gt; Douglas: Okay, ready to move on?

35
00:01:44.319 --> 00:01:45.120
好的，这是下一个。
Okay, here's the next one.

36
00:01:47.349 --> 00:01:52.520
写反转，一个反转二进制函数参数的函数。
Write reverse, a function that reverses the arguments of a binary function.

37
00:01:52.520 --> 00:01:56.520
所以我们要通过它来反转我们今天早上写的子函数。
So we're gonna to pass to reverse the sub function that we wrote this morning.

38
00:01:56.520 --> 00:02:00.989
并且它返回向后减去的总线函数。
And it returns the bus function which is subtract backwards.

39
00:02:00.989 --> 00:02:04.629
所以如果我们把3和2传给BUS，我们会得到-1。
So if we pass 3 and 2 to bus, we'll get -1.

40
00:02:06.390 --> 00:02:07.920
好的，这里是反向的。
Okay, so here is reverse.

41
00:02:09.210 --> 00:02:11.490
REVERSE接受一个二进制函数，并且
reverse takes a binary function and

42
00:02:11.490 --> 00:02:14.770
返回采用第一个和第二个参数的函数，返回
returns a function that takes the first and second argument, returns

43
00:02:14.770 --> 00:02:18.520
使用第二个和第一个参数调用二进制函数的结果。
result to calling the binary function with the second and first argument.

44
00:02:18.520 --> 00:02:20.800
那么是谁倒转了呢？非常好。
So who got reverse? Very good.

45
00:02:20.800 --> 00:02:24.349
这就是明年的写作方式。
So this is how will write it next year.

46
00:02:24.349 --> 00:02:27.120
我们可以推翻任何数量的论点。
We'll be able to reverse any number of arguments.

47
00:02:27.120 --> 00:02:29.860
所以我们现在正在尝试进入实用的东西。
So we're trying to get into practical stuff now.

48
00:02:29.860 --> 00:02:32.033
所以你可以想象，你有两个API和
So you might imagine, you've got two APIs and

49
00:02:32.033 --> 00:02:35.790
您需要让它们一起工作，但它们不是为一起工作而设计的。
you need to make them work together but they were not designed to work together.

50
00:02:35.790 --> 00:02:38.316
所以他们的调用序列是不兼容的。
So they're calling sequences are incompatible.

51
00:02:38.316 --> 00:02:41.516
你可以重写其中一个，使之更像另一个，但是
And you could rewrite one of them to be more like the other but

52
00:02:41.516 --> 00:02:46.001
这是太多的工作，或者您可以在每个入口点周围编写一个包装函数
that's too much work or you could write a wrapper function around every entry point

53
00:02:46.001 --> 00:02:48.007
但那也是太多的工作了。
of one but that's too much work too.

54
00:02:48.007 --> 00:02:51.659
使用这种方法，我们可以让函数完成这项工作。
With this approach, we could let functions do that work.

55
00:02:51.659 --> 00:02:56.204
所以我们可以让函数编写包装器，这将允许
So we can have functions write wrappers, which will allow

56
00:02:56.204 --> 00:03:01.037
我们使用的是可操作性或互换性，好吗？
us to use the matter operability or interchangeably, okay?

57
00:03:01.037 --> 00:03:03.129
准备好下一个了吗？
So ready for the next one?

58
00:03:06.120 --> 00:03:10.159
编写一个函数复合，它接受两个一元函数并
Write a function composeu that takes two unary functions and

59
00:03:10.159 --> 00:03:12.509
返回调用它们的一元函数。
returns a unary function that calls them both.

60
00:03:13.509 --> 00:03:17.379
所以我们要在前面写的平方函数中取双精度。
So we're gonna take the double in the square function that we wrote earlier.

61
00:03:17.379 --> 00:03:20.560
我们会把它们都传给Comeu
And we're gonna pass them both to composeu.

62
00:03:20.560 --> 00:03:26.177
然后，我们将传递返回5的函数，它将返回100。
And then, we'll pass the function that returns 5 and it will return 100.

63
00:03:26.177 --> 00:03:29.978
它会用五倍的方法来做到这一点
And it'll do that by taking the five and doubling it and

64
00:03:29.978 --> 00:03:32.379
然后取下它并将其平方。
then taking that and squaring it.

65
00:03:34.939 --> 00:03:37.289
所以这里是组合。
So here is composeu.

66
00:03:37.289 --> 00:03:40.719
Composeu接受函数f和g。
Composeu takes functions f and g.

67
00:03:40.719 --> 00:03:42.590
它返回一个函数，该函数接受参数并
It returns a function that takes an argument and

68
00:03:42.590 --> 00:03:46.569
返回调用g(f(A)的结果。
returns the result of calling g(f(a)).

69
00:03:46.569 --> 00:03:47.550
那么谁来给你作曲呢？
So who got compose you?

70
00:03:48.900 --> 00:03:49.501
非常好。
Very good.

71
00:03:49.501 --> 00:03:54.043
这个问题的棘手之处在于，嵌套函数调用是编写的
The tricky thing about this one was that nested function invocations are written

72
00:03:54.043 --> 00:03:54.784
从里到外。
inside out.

73
00:03:54.784 --> 00:03:57.611
从词汇上看过去
Which lexically looks backwards and

74
00:03:57.611 --> 00:04:02.909
假设只需要在f之前得到g，即使稍后会调用它。
say just need to get the g before the f even though it's called later.

75
00:04:04.199 --> 00:04:08.751
所以这引入了一种编程方式，有点像添加Unix管道
So this introduces a way of programming which is kind of like adding Unix pipes

76
00:04:08.751 --> 00:04:10.579
除了在功能级别。
except at the function level.

77
00:04:10.579 --> 00:04:15.754
我们可以利用现有的函数并将它们串在一起。
That we can take existing functions and kinda string them together.

78
00:04:15.754 --> 00:04:17.495
并通过它们传递值
And pass values through them and

79
00:04:17.495 --> 00:04:22.019
它将通过这个函数链，直到有东西从另一端出来。
it'll go through this chain of functions until something comes out the other end.

80
00:04:23.480 --> 00:04:27.610
所以明年我们写这个函数的时候，我们会允许不是两个函数，而是
So next year when we write this function, we'll allow to take not two functions but

81
00:04:27.610 --> 00:04:32.060
任何数量的函数，你可以只编程一系列的事情。
any number of functions and you can just program a whole series of things.

82
00:04:32.060 --> 00:04:35.019
在此之前，您可以分别多次调用composeu
Until then, you could call composeu you several times each

83
00:04:35.019 --> 00:04:36.983
向列表中添加新函数的时间。
time adding a new function to the list.

84
00:04:36.983 --> 00:04:38.985
有点像加醋栗子，我想。
Sort of like currying, I guess.

85
00:04:38.985 --> 00:04:41.930
好的，有什么问题吗？
Okay, any questions about that?

86
00:04:43.279 --> 00:04:43.779
准备好再来一个了吗？
Ready for another one?

87
00:04:46.494 --> 00:04:47.805
道格拉斯：有人吗？好的。
&gt;&gt; Douglas: Anybody? Yeah, all right.

88
00:04:47.805 --> 00:04:49.310
好的，好的。
Good, good, all right.

89
00:04:50.908 --> 00:04:54.920
&gt；&gt；Douglas：因此编写一个函数composeb，它接受两个二进制函数
&gt;&gt; Douglas: So Write a function composeb that takes two binary functions and

90
00:04:54.920 --> 00:04:58.420
返回同时调用它们的函数。
returns a function that calls them both.

91
00:04:58.420 --> 00:04:59.889
所以我们将通过add和
So we're going to pass add and

92
00:04:59.889 --> 00:05:03.970
mul到composeb，它们将返回函数。
mul to composeb and they will return the function.

93
00:05:03.970 --> 00:05:07.581
如果我们通过了，2，3，7，它就会变成35。
And if we pass it, 2, 3, and 7, it'll be turned in 35.

94
00:05:07.581 --> 00:05:10.916
&gt；&gt；扬声器2：[咳嗽]&gt；&gt；道格拉斯：这里是composeb，
&gt;&gt; Speaker 2: [COUGH] &gt;&gt; Douglas: So here is composeb,

95
00:05:10.916 --> 00:05:14.564
composeb有两个函数f和g。
composeb takes two functions f and g.

96
00:05:14.564 --> 00:05:18.339
返回接受a、b和c的函数。
Returns a function that takes a, b, and c.

97
00:05:18.339 --> 00:05:22.511
并返回调用g(f(a和b)和c)的结果。
And returns result of calling g(f(a and b) and c).

98
00:05:22.511 --> 00:05:24.192
那么谁得到了Composeb？
So who got composeb?

99
00:05:24.192 --> 00:05:26.747
真的很好，你们做得很好。
Really good, you guys are doing great.

100
00:05:28.867 --> 00:05:30.459
&gt；&gt；道格拉斯：感觉好吗？是吗？
&gt;&gt; Douglas: Feeling good? Yeah?

101
00:05:30.459 --> 00:05:32.939
好的，想再做一次吗？
Okay, wanna do another one?

102
00:05:34.199 --> 00:05:37.870
我还有一个。所以我们走吧。
I've got another one. So let's go.

103
00:05:37.870 --> 00:05:41.040
编写一个限制函数，允许二进制函数
Write a limit function that allows a binary function to be

104
00:05:41.040 --> 00:05:43.490
呼叫了有限的次数。
called a limited number of times.

105
00:05:43.490 --> 00:05:46.566
因此，我们将把add函数传递给limit，并且
So, we're going to pass the add function to limit, and

106
00:05:46.566 --> 00:05:48.992
说你可以调用它，你可以使用它一次。
say you can call it, you can use it one time.

107
00:05:48.992 --> 00:05:52.740
这将产生有限的添加功能。
And that will produce a limited add function.

108
00:05:52.740 --> 00:05:56.480
然后我们可以将其交给第三方，第三方可以调用它一次，并且
We could then give that to a third party, and the third party can call it once, and

109
00:05:56.480 --> 00:05:58.680
它工作得恰到好处。
it works just right.

110
00:05:58.680 --> 00:06:01.295
但是如果他们第二次调用，它所做的就是返回未定义的。
But if they called a second time, all it does is return undefined.

111
00:06:01.295 --> 00:06:02.478
什么都不做。
Doesn't do anything else.

112
00:06:02.478 --> 00:06:07.798
好的，你可以想到，你可以传递一个愿望函数来限制和
Okay, you could think of, you could pass a wish function to limit and

113
00:06:07.798 --> 00:06:10.199
假设你只有三个愿望。
say you only get three wishes.

114
00:06:10.199 --> 00:06:13.416
愿望函数可以实现任意数量的愿望，但
The wish function can make any number of wishes but

115
00:06:13.416 --> 00:06:16.639
我们交给你的函数将会有一个限制。
the function that we hand you will have a limit on.

116
00:06:16.639 --> 00:06:20.411
您传递的函数必须是二进制函数吗？
Does the function you pass have to be a binary function?

117
00:06:24.194 --> 00:06:24.747
&gt；&gt；道格拉斯：让我们说，是的。
&gt;&gt; Douglas: Let's say, yes.

118
00:06:24.747 --> 00:06:25.262
&gt；&gt；扬声器2：好的。
&gt;&gt; Speaker 2: Okay.

119
00:06:25.262 --> 00:06:28.026
&gt；&gt；Douglas：将来，我们希望与任何东西合作，但不是为了
&gt;&gt; Douglas: In the future, we want to work with anything but for

120
00:06:28.026 --> 00:06:30.220
今天我们只说二元函数。
today we'll just say binary function.

121
00:06:33.779 --> 00:06:34.466
所以这里有限制。
So here's limit.

122
00:06:34.466 --> 00:06:38.560
limit接受一个二进制函数和一个计数。
limit takes a binary function and a count.

123
00:06:38.560 --> 00:06:41.959
它返回一个接受两个参数的函数。
And it returns a function that takes two arguments.

124
00:06:41.959 --> 00:06:47.350
如果计数大于或等于1，则记录计数并
If the count is greater than or equal to one, it documents the count and

125
00:06:47.350 --> 00:06:51.649
返回使用两个参数调用二元函数的结果。
returns the result of calling the binary function with the two arguments.

126
00:06:51.649 --> 00:06:53.980
否则，将返回undefined。
Otherwise, it will return undefined.

127
00:06:53.980 --> 00:06:54.980
所以从现在开始
So from this point on,

128
00:06:54.980 --> 00:06:57.470
函数开始变得有点复杂了。
the functions are starting to get a little bit more complicated.

129
00:06:57.470 --> 00:06:59.377
所以你不太可能和我做同样的事。
So it's unlikely that you did the same thing I did.

130
00:06:59.377 --> 00:07:02.776
所以从这一点开始，我要问谁有工作的东西？
So from this point on, I'm going to ask who got something that works?

131
00:07:02.776 --> 00:07:05.517
好的非常好。
Okay, very good.

132
00:07:05.517 --> 00:07:07.494
有人做了什么有趣的事吗？
Anyone do something interesting?

133
00:07:07.494 --> 00:07:08.954
不同的方法？
A different approach?

134
00:07:08.954 --> 00:07:14.821
&gt；&gt；Speaker 3：使用一个变量而不是我有两个变量而不是只有一个变量。
&gt;&gt; Speaker 3: Use a variable instead of I had two variables instead of just one.

135
00:07:14.821 --> 00:07:16.949
&GT；&GT；道格拉斯：好的，你把它们放在哪里了？
&gt;&gt; Douglas: Okay, and where did you put them?

136
00:07:16.949 --> 00:07:22.677
&gt；&gt；扬声器3：在返回函数之前，我说了max。
&gt;&gt; Speaker 3: Before return function, I said max.

137
00:07:22.677 --> 00:07:27.149
不，麦克斯是，我说我等于零。
No, max was, I said i equal to zero.

138
00:07:27.149 --> 00:07:29.850
我用的是最大数。
And the count I use max.

139
00:07:29.850 --> 00:07:33.269
然后每次我运行函数，它就加1。
And then each time I run function, it just incremented i one.

140
00:07:33.269 --> 00:07:33.959
&gt；&gt；道格拉斯：很好，非常好。
&gt;&gt; Douglas: Great, very good.

141
00:07:35.209 --> 00:07:36.790
还有其他人吗？
So, anybody else?

142
00:07:36.790 --> 00:07:44.523
&gt；&gt；演讲者3：嗯-是的，我有点迷惑，像如何计数或。
&gt;&gt; Speaker 3: Well- Yeah, I'm a little confused like how to count or.

143
00:07:48.377 --> 00:07:51.646
&gt；&gt；扬声器3：这是如何存储的，已经有多少时间了？
&gt;&gt; Speaker 3: How is this being stored, how the number of time has been?

144
00:07:51.646 --> 00:07:53.838
&gt；&gt；道格拉斯：嗯，我们使用的是闭包，对吗？
&gt;&gt; Douglas: Well, we're using a closure, right?

145
00:07:53.838 --> 00:07:57.221
因此，另一个函数可以访问另一个函数的参数的变量
So, the other function has access to the variables of parameters of the other

146
00:07:57.221 --> 00:07:57.749
功能。
function.

147
00:07:59.120 --> 00:08:02.735
因此，似乎正在改变[INAUDIBLE]的计数。
So it seems the count that is changing that [INAUDIBLE].

148
00:08:06.764 --> 00:08:08.779
&gt；&gt；扬声器3：您需要返回undefined吗？
&gt;&gt; Speaker 3: Do you need to return undefined there?

149
00:08:08.779 --> 00:08:10.230
&GT；&GT；道格拉斯：是的，让我们来问一个非常好的问题。
&gt;&gt; Douglas: Yeah, so let’s that a really good question.

150
00:08:10.230 --> 00:08:12.785
这就是为什么在声明下划线的原因，因为我想谈谈它。
And that's why underlined the statement because I want to talk about it.

151
00:08:12.785 --> 00:08:18.060
因此，关于这一说法有两种思想流派。
So, there are two schools of thought on that statement.

152
00:08:18.060 --> 00:08:20.120
一个是，这是完全没有必要的。
One is, this is completely unnecessary.

153
00:08:20.120 --> 00:08:25.829
因为在JavaScript中，如果函数从底部跌落，则返回undefined。
Because in JavaScript, if a function falls off the bottom it returns undefined.

154
00:08:25.829 --> 00:08:27.810
所以这只是浪费空间。
So this is just a waste of space.

155
00:08:27.810 --> 00:08:29.889
没有理由这样说。
There is no reason to say this.

156
00:08:29.889 --> 00:08:32.460
另一种思想流派是合同的一部分
The other school of thought is that part of the contract for

157
00:08:32.460 --> 00:08:38.129
这个函数是在达到限制时返回undefined。
this function is that it returns undefined when the limit is reached and so.

158
00:08:38.129 --> 00:08:42.210
通过显式返回和定义，我们提供了自我文档化代码。
By explicitly returning and defined, we're providing self documenting code.

159
00:08:45.290 --> 00:08:47.551
&gt；&gt；道格拉斯：我认为这两种观点都是正确的，
&gt;&gt; Douglas: I think both points of view are valid,

160
00:08:47.551 --> 00:08:50.529
我还没能决定哪一个更好。
I've not been able to decide which one is better.

161
00:08:50.529 --> 00:08:53.951
你看，你会看到我在这个问题上翻来覆去。
See, you'll see me flip flopping on this.

162
00:08:53.951 --> 00:08:56.863
很明显不好的事情就是说，
The thing that is clearly bad would be saying,

163
00:08:56.863 --> 00:09:01.130
只需返回分号，因为这两件事都不能完成。
just return semi colon cuz that doesn't accomplish either thing.

164
00:09:01.130 --> 00:09:04.018
这是对空间的浪费，而且没有明确说明返回的内容。
It's a waste of space and it isn't explicit about what's getting returned.

165
00:09:04.018 --> 00:09:05.706
怎么了？
Yes?

166
00:09:05.706 --> 00:09:07.852
&GT；&GT；演讲者3：你就在这里回答了我的问题。
&gt;&gt; Speaker 3: And you answered my question right there.

167
00:09:07.852 --> 00:09:09.870
&gt；&gt；道格拉斯：好的，还有其他人吗？
&gt;&gt; Douglas: Okay, anybody else?

168
00:09:09.870 --> 00:09:13.120
&GT；&GT；扬声器3：我有一些可能不那么聪明的东西。
&gt;&gt; Speaker 3: I had something maybe less clever.

169
00:09:13.120 --> 00:09:16.975
我有一个局部变量叫做，我把它初始化为零，
I had a local variable called, which I initialized to zero,

170
00:09:16.975 --> 00:09:19.253
也就是打了多少个电话。
which was the number of calls made.

171
00:09:19.253 --> 00:09:21.900
&gt；&gt；Douglas：好的，局部变量存储在-
&gt;&gt; Douglas: Okay, and the local variable was stored above-

172
00:09:21.900 --> 00:09:23.414
&gt；&gt；扬声器3：是的，就像在上面，
&gt;&gt; Speaker 3: Yeah, it's like above the,

173
00:09:23.414 --> 00:09:24.448
在回来之前。
before the return.

174
00:09:24.448 --> 00:09:26.529
&gt；&gt；道格拉斯：太棒了，好的，非常好。
&gt;&gt; Douglas: Brilliant, okay, very good.
