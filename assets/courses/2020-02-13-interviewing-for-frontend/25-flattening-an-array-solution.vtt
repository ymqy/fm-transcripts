WEBVTT

1
00:00:00.160 --> 00:00:01.800
平铺阵列。
Flattening an array.

2
00:00:01.800 --> 00:00:03.850
嗯，嗯。
Mm, yes.

3
00:00:03.850 --> 00:00:07.570
我们可以用平的平面地图之类的
We could use flat, flat map or
something like that.

4
00:00:07.570 --> 00:00:08.977
但因为这是一次面试
But because it's an interview,

5
00:00:08.977 --> 00:00:11.955
我想知道你了解减少数据结构的方式有多好。
I wanna see how well you understand
reducing data structure.

6
00:00:11.955 --> 00:00:15.637
您如何了解数组方法，了解一般数组的程度如何 ?
How well you understand array methods, how
well do you understand arrays in general?

7
00:00:15.637 --> 00:00:18.580
艾拉我希望能有个加薪的
[LAUGH] Arrays, I wish I can get a raise.

8
00:00:18.580 --> 00:00:20.725
如往常一样我们会以同样的方式开始
As usual, we'll start off the same way.

9
00:00:20.725 --> 00:00:22.059
谢谢你我有时间笑了
Thank you, I got some laughs that time.

10
00:00:22.059 --> 00:00:23.878
>> [LAUGH] >> 我们将以相同方式启动。
&gt;&gt; [LAUGH]
&gt;&gt; We'll start off the same way.

11
00:00:23.878 --> 00:00:27.957
因此，我需要创建一个函数来平铺数组。
So, I need to create a function
to flatten an array.

12
00:00:27.957 --> 00:00:34.094
所以，我需要一个功能，我们称它为扁平化，平平。
So, I need a function and
we'll call it flatten, flatter.

13
00:00:34.094 --> 00:00:35.512
我们知道它需要一个阵列。
And we know it takes an array.

14
00:00:39.335 --> 00:00:41.630
现在我们想做什么
Now, what do we wanna do?

15
00:00:41.630 --> 00:00:42.643
我们在想什么
What are we thinking?

16
00:00:44.732 --> 00:00:48.280
或者最终，我们知道我们要返回一个阵列。
Or eventually,
we know we wanna return an array.

17
00:00:48.280 --> 00:00:49.700
所以我可以从这里开始
So I could start here.

18
00:00:49.700 --> 00:00:55.875
我可以说回一个新阵列新阵列
I could say return someNewArray,
new array.

19
00:00:57.923 --> 00:01:01.070
我们也许会改变这一切但这也会起作用
We're probably gonna change this but
this will work too.

20
00:01:01.070 --> 00:01:03.728
有许多不同的方法来解决这个问题。
There are many different
ways to do this problem.

21
00:01:03.728 --> 00:01:08.486
我要用我最喜欢的功能或者我最喜欢的方法
I'm gonna use my favorite function, or
my favorite method, which is reduce.

22
00:01:08.486 --> 00:01:13.760
所以我会说 arr.l 减
So I'm gonna say arr.reduce.

23
00:01:13.760 --> 00:01:17.769
而还原剂，那么，它们有四个参数。
And reducer, well,
they take four arguments.

24
00:01:17.769 --> 00:01:21.253
但你真正关心的是蓄电池
But the ones you actually care
about are the accumulator,

25
00:01:21.253 --> 00:01:25.319
我要说的是蓄电池和实际的物品
which I'm gonna say the accumulator,
and the actual item itself.

26
00:01:25.319 --> 00:01:27.912
让我们把这个做完
And let's finish this out.

27
00:01:30.496 --> 00:01:34.399
并且减少其他的争论，这就是你想开始的事情。
And reduce takes the other argument,
which is the thing you wanna start with.

28
00:01:34.399 --> 00:01:35.481
这将成为累加人。
So this will be the accumulator.

29
00:01:35.481 --> 00:01:38.120
这将是我们的基本值，它只是一个数组。
This will be our base value,
which is just an array.

30
00:01:39.680 --> 00:01:43.516
好的冷静冷静
Okay, cool, cool.

31
00:01:43.516 --> 00:01:46.900
所以我现在正在做的是我正在研究这个阵列。
So mentally what I'm doing is
now I'm looking at the array.

32
00:01:46.900 --> 00:01:48.590
我在看数据结构。
I'm looking at the data structure.

33
00:01:48.590 --> 00:01:51.219
这个项目将会是我开始的地方
The item is gonna be one because
this is where I started,

34
00:01:51.219 --> 00:01:53.170
我只是在开始我的迭代
I'm just starting out my iteration.

35
00:01:53.170 --> 00:01:57.530
所以我想看看指数为零的项目，在这个情况下是一个，但是
So I wanna check if the item at index
zero, which would be one in this case, but

36
00:01:57.530 --> 00:02:00.629
就说我不知道我想看看是个数字还是
let's say I didn't know that,
I wanna check if it's a number or

37
00:02:00.629 --> 00:02:01.260
如果是阵列的话
if it's an array.

38
00:02:02.260 --> 00:02:05.959
执行此操作的方法是 Array.isArray。
And the way to do that is Array.isArray.

39
00:02:05.959 --> 00:02:09.722
所以我可以说如果这个项目
So I can say, if the item,

40
00:02:09.722 --> 00:02:14.342
实际上是说 Array.isArray
actually say Array.isArray,

41
00:02:14.342 --> 00:02:17.780
检查它是否为项。
check if it's an item.

42
00:02:17.780 --> 00:02:19.639
我马上就处理好了
I'll deal with that in a second.

43
00:02:19.639 --> 00:02:21.539
它会变得更复杂
It gets a little more complicated.

44
00:02:21.539 --> 00:02:24.099
但如果不是数组我想做什么
But if it's not an array,
what do I wanna do?

45
00:02:24.099 --> 00:02:26.621
我想把它归还给我的累加人
I wanna just return it to my accumulator.

46
00:02:26.621 --> 00:02:30.251
所以我会说 acc.push
So I'm gonna say acc.push.

47
00:02:30.251 --> 00:02:33.861
我要把这个项目变成我想要的累加器
And I'm gonna push the item into
the accumulator that I wanna eventually

48
00:02:33.861 --> 00:02:34.520
建立起来。
build up to.

49
00:02:35.530 --> 00:02:38.978
最后这会让我每次都在做还原剂
And then, ultimately,
this will get me every time on reducers,

50
00:02:38.978 --> 00:02:40.930
你得把累加器退回去
you have to return the accumulator.

51
00:02:40.930 --> 00:02:42.319
缺省情况下，它不会返回。
It doesn't return by default.

52
00:02:44.658 --> 00:02:47.951
所以，我们做了一个，我们有一个新的阵列，有两个，
So, we did one,
we have one in our new array, we have two,

53
00:02:47.951 --> 00:02:50.270
我们的新阵列中有两个废物
we have two in our new array, crap.

54
00:02:50.270 --> 00:02:52.430
现在我们点击一个阵列，一个不同的阵列。
Now we hit an array, a different array.

55
00:02:52.430 --> 00:02:53.562
我们现在做什么
What do we do now?

56
00:02:55.961 --> 00:02:59.879
我需要一个减少这个阵列的方法。
I need a way of reducing this array down.

57
00:02:59.879 --> 00:03:03.509
所以我们要用所谓的 " 递归"
So we're gonna use what we call recursion,

58
00:03:03.509 --> 00:03:08.129
递归是通过调用函数来减小值的概念。
recursion is the idea of reducing a value
down by calling the function over and

59
00:03:08.129 --> 00:03:11.430
再一次又一次，这个价值就会变小一点。
over again and every time,
the value gets a little bit smaller.

60
00:03:11.430 --> 00:03:12.810
你不用再用递归的方式
You don't have to use recursion for this,

61
00:03:12.810 --> 00:03:14.520
有很多不同的方法来解决这个问题，但是
there are many different
ways to solve this, but

62
00:03:14.520 --> 00:03:17.349
这一特殊问题本身就会产生递归。
this particular problem lands
itself well to recursion.

63
00:03:17.349 --> 00:03:21.126
所以在某个时候我想做的就是
So at some point,
what I wanna do is I need to concatenates,

64
00:03:21.126 --> 00:03:23.259
我得把这个减少了
I need to reduce this down.

65
00:03:23.259 --> 00:03:26.259
一旦它平坦，我就可以将它连接到另一个阵列中。
Once it's flat,
I can concatenate that into another array.

66
00:03:26.259 --> 00:03:31.421
所以我会说项目我会说
So I'll say item and I'm gonna say

67
00:03:31.421 --> 00:03:36.417
我想在这里做什么
item., what do I wanna do here?

68
00:03:36.417 --> 00:03:38.060
我想说的是
I wanna say concat.

69
00:03:39.670 --> 00:03:46.389
从本质上来说，把这个项目缩小到实际上是没有的。
Essentially, concat this
item down into- actually no.

70
00:03:46.389 --> 00:03:48.870
不我想做的就是要把它扁平
No, what I wanna do is
I wanna flatten this.

71
00:03:48.870 --> 00:03:52.045
假设我的扁平化功能最终会起作用
Assuming my flatten function
will work eventually,

72
00:03:52.045 --> 00:03:53.956
我想把这件物品放下
I wanna flatten this item down.

73
00:03:53.956 --> 00:03:56.389
现在，该项已被序列化。
So the item is now flattened.

74
00:03:56.389 --> 00:04:00.268
我想把这个分成另一个
I wanna concatenate this
down into the other thing.

75
00:04:00.268 --> 00:04:04.991
这就是我一直把我弄扁的事你搞砸了
This is what always gets me on flatten
is you get messed up with types.

76
00:04:04.991 --> 00:04:06.680
我现在有什么事了
I'm like, what do I have now?

77
00:04:06.680 --> 00:04:08.840
我有个阵列吗我有个项目吗
Do I have an array, do I have an item?

78
00:04:08.840 --> 00:04:10.419
Flatten 将返回一个阵列。
Flatten is gonna return an array.

79
00:04:10.419 --> 00:04:11.449
那么我们对阵列做什么 ?
So what do we do with arrays?

80
00:04:11.449 --> 00:04:12.901
我们把这些都连上了
We concatenate those.

81
00:04:12.901 --> 00:04:17.300
所以，我可以说，其实我要缩短这个时间。
So, I can say, actually,
I'm gonna shorten this.

82
00:04:17.300 --> 00:04:19.139
它会回来的
It's gonna return here.

83
00:04:19.139 --> 00:04:21.591
省省吧
Save me some time.

84
00:04:21.591 --> 00:04:23.562
然后我会说退让
And then I'm gonna say concacts.

85
00:04:31.625 --> 00:04:35.370
事实上是的是的
Actually, yeah, yes.

86
00:04:35.370 --> 00:04:36.005
这才是解决问题的办法
That's the solution.

87
00:04:37.968 --> 00:04:39.689
大家都跟着吗
Does everybody follow?

88
00:04:39.689 --> 00:04:41.540
有很多方法可以做到这一点，这是其中之一。
There are many ways to do this,
this is one of them.

89
00:04:43.009 --> 00:04:43.757
所以我们有一个阵列。
So we have an array.

90
00:04:43.757 --> 00:04:48.439
我们对数组进行迭代，直到我们命中数组，然后再进行并置
We iterate over the array until we
hit an array, then we concatenate by

91
00:04:48.439 --> 00:04:51.790
以递归方式调用我们自己的函数，因为我们最终知道了，
recursively calling our own function,
because we know eventually,

92
00:04:51.790 --> 00:04:54.850
这将返回或返回序列化的数组。
this will return in or
it'll return a flattened array.

93
00:04:54.850 --> 00:04:57.699
所以不管我们的嵌套方式有多深
So it doesn't matter how
deeply nested we go here,

94
00:04:57.699 --> 00:05:00.439
一旦完成返回，它将始终返回阵列。
it will always return an array
once it is done returning.

95
00:05:00.439 --> 00:05:02.197
这就是递归的力量。
And that's the power of recursion.

96
00:05:02.197 --> 00:05:05.422
一些问题让他们自我完善，有些问题则不存在。
Some problems lend themself
well to recursion, some do not.

97
00:05:05.422 --> 00:05:07.928
但一般来说，这就像是你在更深更深地潜水的地方
But generally it's something like this
where you're diving deeper and deeper and

98
00:05:07.928 --> 00:05:10.000
但最终你还是想放弃
deeper, but
eventually you wanna bubble back up.

99
00:05:10.000 --> 00:05:11.259
递归是一个很好的解决方案。
Recursion is a good solution to it.

100
00:05:14.939 --> 00:05:16.221
不错一点也不错
Not bad, not bad at all.

101
00:05:16.221 --> 00:05:18.252
其实我忘了一件事
Actually, I forgot one thing.

102
00:05:20.351 --> 00:05:26.838
我忘了累加器等于
I forgot to, Accumulator equals,

103
00:05:26.838 --> 00:05:30.850
把那个切了我要换个小一点
cut that, and
I'm gonna change that a little bit.

104
00:05:33.697 --> 00:05:37.894
就像我说的如果我在这里有点小问题
And like I said, if I'm syntactically
a little off here, that's okay,

105
00:05:37.894 --> 00:05:38.920
这个想法是有效的
the idea stands.

106
00:05:38.920 --> 00:05:42.680
如果你能得到那么多的解决方案，足够好，这就足够了
If you can get this far some solution,
good enough, this is good enough for

107
00:05:42.680 --> 00:05:44.069
白板问题。
a whiteboard problem.

108
00:05:44.069 --> 00:05:47.199
所以，别在推特上说，如果我在某个地方犯了一个小错误。
So, don't at me on Twitter,
if I've made a small mistake somewhere.

109
00:05:48.409 --> 00:05:49.920
推特很恶毒太邪恶了
Twitter's vicious, it's vicious.
