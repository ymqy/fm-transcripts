WEBVTT

1
00:00:00.000 --> 00:00:02.666
好的下一个问题
All right, next problem.

2
00:00:02.666 --> 00:00:04.660
我有重复的问题
I've got this problem
with duplicate strings.

3
00:00:04.660 --> 00:00:05.796
我有太多的绳子
I've got too many strings.

4
00:00:05.796 --> 00:00:10.590
所以我要你做的就是创造一个函数
So what I need you to do is create
a function that takes a string,

5
00:00:10.590 --> 00:00:14.128
将返回具有重复删除项的新字符串。
returns a new string
with duplicates remove.

6
00:00:14.128 --> 00:00:20.385
因此，我的测试用例是一个测试字符串。
So my test case for this is a test string.

7
00:00:20.385 --> 00:00:23.347
我希望您创建一个函数，以字符串和
And I want you to create a function
that takes in a string and

8
00:00:23.347 --> 00:00:25.106
只会除去所有重复项。
just removes all the duplicates.

9
00:00:25.106 --> 00:00:29.300
所以它应该是一个测试字符串，或者是沿着这些线的东西。
So it should return this is a test string,
or something along those lines.

10
00:00:29.300 --> 00:00:34.843
这个有点棘手，所以我要用十分钟的时间来回答这个问题。
And this one is a little trickier,
so I'll say ten minutes on this one.

11
00:00:34.843 --> 00:00:38.316
还记得我们之前使用过的那些方法，它们在这里会很有帮助。
And remember those methods we used
earlier, they'll be really helpful here.

12
00:00:38.316 --> 00:00:40.512
>> 那么问题，仅适用于
&gt;&gt; So questions, is this only for

13
00:00:40.512 --> 00:00:44.151
这句话是一样的吗
words that are the same that
are next to each other?

14
00:00:44.151 --> 00:00:47.823
或者如果有另一个是在那句里的话
Or if there was another
is in that sentence,

15
00:00:47.823 --> 00:00:51.810
就应该去掉其中的两个，就留一个吧 ?
it should remove two of them and
just leave one?

16
00:00:51.810 --> 00:00:52.529
>> 大问题。
&gt;&gt; Great question.

17
00:00:52.529 --> 00:00:55.112
是的你会问这个问题
Yes, that's a great
question you would ask.

18
00:00:55.112 --> 00:00:56.798
是啊，什么位置都不重要。
Yes, it doesn't matter
what the position is.

19
00:00:56.798 --> 00:00:58.993
它应该只具有一个唯一值。
It should only have one unique value.

20
00:00:58.993 --> 00:01:02.715
实际上，我将调用此唯一值或重复字符串。
In fact I would call this unique values or
duplicate strings.

21
00:01:02.715 --> 00:01:07.466
所以我也可以用数字做同样的事情
So I could do the same thing with numbers
if I wanted to kind of give it a way too

22
00:01:07.466 --> 00:01:08.301
很多是吗
much, yes?

23
00:01:08.301 --> 00:01:11.832
>> 大写为大写，小写为小写，
&gt;&gt; Capitalization matters like
uppercase this and lowercase this,

24
00:01:11.832 --> 00:01:14.865
它们会是同一个字符串还是它们太独特了
would they be the same string or
would they be too unique?

25
00:01:14.865 --> 00:01:17.730
>好的问题我要说他们是独一无二的
&gt;&gt; Good question,
I'm gonna say they're unique but

26
00:01:17.730 --> 00:01:20.537
在解决这个问题上我也不在乎
in terms of solving this
I wouldn't care as much.

27
00:01:20.537 --> 00:01:23.947
但我喜欢这个问题意味着你已经在思考了，对吗 ?
But I love that question that means
you're already thinking ahead, yes?

28
00:01:23.947 --> 00:01:26.873
>> 您是否可以始终除去第一次出现的重复项或
&gt;&gt; Can you always remove the first
occurrence of the duplicate or

29
00:01:26.873 --> 00:01:30.093
你会不会第一次出现然后把东西移走吗
do you leave the first occurrence and
remove the things after that?

30
00:01:30.093 --> 00:01:33.076
>> 大问题，没关系。
&gt;&gt; Great question, it doesn't matter.

31
00:01:33.076 --> 00:01:35.156
这件事更开放了 - >> 这件事我不知道。
This one is more of an open ended-
&gt;&gt; This one it doesn't matter I guess.

32
00:01:35.156 --> 00:01:38.735
> > 是，这是一个更开放的问题。
&gt;&gt; Yeah,
this is more of an open ended question.

33
00:01:38.735 --> 00:01:39.870
我会说这一点
And I'll say this,

34
00:01:39.870 --> 00:01:43.617
一般的采访者大概会给你试镜。
in general the interviewer probably
is gonna give you test cases.

35
00:01:43.617 --> 00:01:46.115
他们会说创建一个函数来执行字符串和
They'll just say create
a function that takes string and

36
00:01:46.115 --> 00:01:48.206
返回已除去重复项的新字符串。
returns a new string
with duplicates removed.

37
00:01:48.206 --> 00:01:50.223
我给你测试是因为我是个好人
I'm giving you test cases
because I'm a nice person, but

38
00:01:50.223 --> 00:01:52.789
如果你在白板上他们可能不会为你那样做
if you're on a whiteboard, they're
probably not gonna do that for you.
