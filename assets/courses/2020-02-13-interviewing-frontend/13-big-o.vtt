WEBVTT

1
00:00:00.160 --> 00:00:01.860
现在我们了解了
Now we get to some knowledge and

2
00:00:01.860 --> 00:00:05.620
我们将会有不同的知识部分
we're gonna have different
knowledge portions of this course.

3
00:00:05.620 --> 00:00:09.460
我想从 Big-O 开始，因为它有点被误解了。
I want to start with Big-O because it's
something that is a little misunderstood.

4
00:00:09.460 --> 00:00:11.990
我不知道是否应该有连字符。
I don't know if it should be hyphenated or
not.

5
00:00:13.830 --> 00:00:15.199
我相信它看起来更酷了
I believe it hyphenated
cuz it looks cooler.

6
00:00:16.429 --> 00:00:18.432
Big-O我是说什么是 Big-O
Big-O, I mean, what is Big-O?

7
00:00:18.432 --> 00:00:21.089
有人告诉我这会有很多的
Someone tell me, and
this will come up a lot.

8
00:00:21.089 --> 00:00:22.500
我要问你一些问题
Some of the questions I'm gonna ask you,

9
00:00:22.500 --> 00:00:26.329
我要说，你刚才写的这个功能的 Big-O 是什么呢 ?
I'm going to say, what's the Big-O
of this function you just wrote?

10
00:00:27.670 --> 00:00:28.879
嗯。
Yeah.

11
00:00:28.879 --> 00:00:30.725
> > 我可以尝试。
&gt;&gt; I can try.

12
00:00:30.725 --> 00:00:34.469
Big-O 表示法的类型类似于您用于确定时间长度的公式
Big-O notation is kinda of like the
formula that you use to determine how long

13
00:00:34.469 --> 00:00:37.299
就像个问题一样
something's gonna take, like a problem.

14
00:00:37.299 --> 00:00:38.880
或者其实我只是把它当作一个问题
Or actually I've only
used it as a problem,

15
00:00:38.880 --> 00:00:41.750
我从没用过这种东西我不知道你能不能
I've never used it for anything else,
I don't know if you can.

16
00:00:41.750 --> 00:00:47.840
所以， > 嗯，不过是最长的
So,
&gt;&gt; Yeah, well but it's the longest

17
00:00:47.840 --> 00:00:51.740
鉴于输入的情况最差情况，任何函数都将被执行。
amount any function is going to take,
given the worst case scenario of input.

18
00:00:53.640 --> 00:01:00.039
作为工程师，作为计算机科学家，我们应该知道 Big-O是重要的。
It's important to know as engineers, as
computer scientists, we should know Big-O.

19
00:01:00.039 --> 00:01:04.049
因为你在想我的功能
Because you're thinking, my function that,

20
00:01:05.239 --> 00:01:09.760
我不知道，我写的我的功能，它在它里是有循环的。
I don't know, my function that I wrote,
that it has for-loops in it.

21
00:01:09.760 --> 00:01:12.319
我只需要 100 个元素就可以了
I only have 100 elements to iterate over,
fine.

22
00:01:12.319 --> 00:01:15.650
但如果你写了几十亿元素的东西
But if you write things that
take billions of elements,

23
00:01:15.650 --> 00:01:17.829
然后你就知道时间是在爬爬爬来的
then you see that time creep up,
and creep up, and creep up.

24
00:01:17.829 --> 00:01:20.219
知道 Big-O 是很重要的
Knowing Big-O is really important.

25
00:01:20.219 --> 00:01:25.519
但因为它正试图主宰一切，我要你主宰所有的大人们。
But because it's trying to masters,
I want you to master all the Bigs.

26
00:01:25.519 --> 00:01:28.640
大欧米茄大公司大公司
Big Omega, Big Theta, Big O.

27
00:01:28.640 --> 00:01:30.460
你不需要知道大 Q 和大西塔
You don't have to know Big Omega and
Big Theta.

28
00:01:30.460 --> 00:01:33.439
我觉得这才叫知识，因为大多数人说大澳，
I think it's just called knowledge to
have because most people say Big O,

29
00:01:34.450 --> 00:01:35.150
我们知道这是件好事
we know it's a thing.

30
00:01:35.150 --> 00:01:36.629
但是有个大 Q
But there's Big Omega.

31
00:01:36.629 --> 00:01:39.250
大 Q 描述了最好的情况
Big Omega describes
the best case scenario,

32
00:01:39.250 --> 00:01:44.799
输入的理想情况的操作复杂性。
the operational complexity of
the ideal case of your input.

33
00:01:46.060 --> 00:01:48.500
如果一切顺利的话它会很快地运行
If all things go well,
it's gonna run really, really quickly, and

34
00:01:48.500 --> 00:01:49.840
那是最好的情况
that's the best case.

35
00:01:49.840 --> 00:01:52.289
" 大数 " 是平均个案。
Big theta is the average case.

36
00:01:54.430 --> 00:01:56.590
那么平均而言
Well, on average, or

37
00:01:56.590 --> 00:02:00.769
确切的情况，它会在这个复杂程度上运行，这次。
the precise case, it's gonna run
at this complexity, this time.

38
00:02:00.769 --> 00:02:02.840
大 O 是最坏的情况
And big O is the worst case.

39
00:02:02.840 --> 00:02:06.140
你在想为什么计算机科学家如此悲观
And you're thinking, why are computer
scientists so pessimistic,

40
00:02:06.140 --> 00:02:07.709
他们只关心大澳吗
they only care about Big O?

41
00:02:07.709 --> 00:02:10.639
是啊在大欧米茄上运行是很棒的
Yes, it's awesome when
things run on Big omega.

42
00:02:10.639 --> 00:02:12.539
但一般来说我们在乎大澳大的时间
But generally,
we care about the Big O time,

43
00:02:12.539 --> 00:02:14.240
因为我们想知道最坏的情况
because we wanna know about
the worst-case scenario.

44
00:02:14.240 --> 00:02:17.319
在此功能中可能发生的最慢的可能是什么 ?
What is the slowest possible thing
that can happen in this function?

45
00:02:19.860 --> 00:02:25.060
所以在这种情况下，这个搜索函数只对一个数组进行迭代
So in this case, this search function
which just iterates over an array, and

46
00:02:25.060 --> 00:02:27.379
如果它找到了它想要的号码
if it finds whatever
number it's looking for,

47
00:02:27.379 --> 00:02:30.920
如果找不到它就会回到真实的状态
it's gonna return true, if it doesn't
find it's gonna return false.

48
00:02:30.920 --> 00:02:34.409
所以这个搜索功能最好的原因是我有一个
So the best case with this search
function because I have one for

49
00:02:34.409 --> 00:02:38.789
循环，这意味着我要对元素进行迭代一次，但我提前返回。
loop, which means I'm iterating over
the elements one time, but I return early.

50
00:02:38.789 --> 00:02:42.090
因此，最好的情况是元素零。
So the best case is element zero.

51
00:02:42.090 --> 00:02:46.430
指数零点的元素是我要找的东西，我们会变成真实的。
Element at index zero is the thing I'm
looking for, we're going to turn true.

52
00:02:46.430 --> 00:02:51.610
所以，我们要说的是 " 大 O " 或 " 大 Q " ，它是恒定的时间。
So, we're gonna say that's Big O one or
Big omega one, which is constant time.

53
00:02:51.610 --> 00:02:53.110
它马上就要回来了
It's gonna return instantly.

54
00:02:53.110 --> 00:02:55.653
不管我们的数据里有多少元素
And it doesn't matter how many
elements are in our data set,

55
00:02:55.653 --> 00:03:01.080
不管它是十亿还是一万亿还是一万亿
it doesn't matter if it's a billion or
a trillion or a gazillion.

56
00:03:01.080 --> 00:03:05.449
我不确定刊宪是数字，但第一个元素不重要
I'm not sure if gazillion is a number, but
it doesn't matter if the first element is

57
00:03:05.449 --> 00:03:07.800
我们要找的东西马上就会回来了
the thing we're looking for, it's going to
return immediately so it's constant time.

58
00:03:09.030 --> 00:03:09.590
大 Q
Big omega.

59
00:03:11.090 --> 00:03:13.289
大 θ 是平均时间。
Big theta is the average time.

60
00:03:13.289 --> 00:03:17.469
平均而言，我们可能要迭代整个数组或
On average, we'll probably have to
iterate through the entire array or

61
00:03:17.469 --> 00:03:19.770
我们平均得用一半的时间来迭代
we'll say on average we're gonna have
to iterate through half the array.

62
00:03:21.150 --> 00:03:21.979
你跟踪吗
You follow?

63
00:03:21.979 --> 00:03:24.822
比如如果我们有一个巨大的数据，我们就得过去
Like if we had a giant data set on
average, we're gonna have to go through

64
00:03:24.822 --> 00:03:28.610
它的一半是为了找到我们在一个均匀分布的数据集合中寻找的东西
half of it to find the thing we're looking
for in an evenly distributed data set.

65
00:03:28.610 --> 00:03:33.837
这实际上是大数据在 2 个以上的数据中，我们将要处理的元素的一半
So that's actually Big data n over 2 cuz
that's half of the elements we're going

66
00:03:33.837 --> 00:03:39.860
来迭代，但我们总是舍弃这些额外的数字，所以它只是大数据 n。
to iterate over, but we always drop those
extra numbers so it's just big data n.

67
00:03:39.860 --> 00:03:43.050
而 n 当然是你穿越的元素的数量
And n is of course the number of
elements you're traversing, or

68
00:03:43.050 --> 00:03:43.969
数据集的大小。
the size of data set.

69
00:03:43.969 --> 00:03:48.310
它可能意味着很多事情，但通常是时间或元素的数量。
It can mean a lot of things, but
it's generally time or number of elements.

70
00:03:48.310 --> 00:03:52.879
所以，平均有 n 个以上的数据，我们可以称之为 n。
So big data on average n over
2 which we just could call n.

71
00:03:52.879 --> 00:03:54.960
大 O 的情况也是 n。
The Big O case is also n.

72
00:03:54.960 --> 00:03:57.789
所以说那是个回返案
So let's say that's the return false case.

73
00:03:57.789 --> 00:04:02.116
你没找到所有你要找的要素最坏的情况
You didn't find the element all of you
are looking for, at the worst case,

74
00:04:02.116 --> 00:04:06.599
我们要对整个数据集进行迭代
we're gonna have to iterate through
the entire data set, the entire array.

75
00:04:06.599 --> 00:04:09.810
就像我们找不到的东西一样酷
And it's like the thing we're looking for
isn't there, cool.

76
00:04:09.810 --> 00:04:11.490
所以在这个功能最糟糕的情况下
So in the very worst
case of this function,

77
00:04:11.490 --> 00:04:16.949
我们会说它是 Big-O n ，希望能和 Big-O 有一点帮助。
we're going to say it's Big-O n, hopefully
that helps with Big-O a little bit.

78
00:04:16.949 --> 00:04:21.199
我知道这威胁着人们的身份一棵树来登录它的登录
I know it's intimidating cuz people be
like, a tree to access its login or

79
00:04:21.199 --> 00:04:23.230
他们会把你想记住的数字扔出去
they'll just throw out numbers
that you expect to memorize.

80
00:04:23.230 --> 00:04:26.564
但不要把它保存得更能真正地接受这些
But instead of memorizing it's better
to really take these to heart.

81
00:04:26.564 --> 00:04:30.050
我给你看下戏法，我给你看看 Jem 的戏法
I'll show you the trick,
I'll show you the Jem trick at the end for

82
00:04:30.050 --> 00:04:33.840
和你说你是很有道理的人
figuring out big-O and when you
say you're like, that makes sense.

83
00:04:33.840 --> 00:04:35.110
希望我能做得好
Hopefully if I'm doing things right.

84
00:04:37.170 --> 00:04:41.192
我们在乎大 O 因为我可以说它是大澳 2n
And we care about big O because I can say,
it's big-O 2n or

85
00:04:41.192 --> 00:04:44.120
大 O n 的平方不一定意味着什么
big O n squared,
that doesn't necessarily mean anything,

86
00:04:44.120 --> 00:04:48.800
当你看一张图要跑多久，就不要想 10 或
when you look at a graph of how long
things take to run, so don't think 10 or

87
00:04:48.800 --> 00:04:52.790
100，思考十亿个元素，时间复杂度会增加。
100, think a billion elements,
that timing complexity adds up.

88
00:04:53.810 --> 00:04:58.209
因此，大 -O n factorial 是最糟糕的时间。
So big -O n factorial is
the worst possible time.

89
00:04:58.209 --> 00:05:02.310
" 组织 " 说这就是 " 砰 " 的标志
Factorial is say, so that's the bang sign,

90
00:05:02.310 --> 00:05:04.449
或者惊叹号不管你想说什么
or exclamation point,
whatever you wanna call it.

91
00:05:04.449 --> 00:05:09.189
因此，阶乘 4 是 2 乘以 1的 4 倍，这是事实。
So factorial 4 would be 4 times 3
times 2 times 1, that's factorial.

92
00:05:09.189 --> 00:05:10.740
那是最糟糕的时候了
That's the worst possible time.

93
00:05:10.740 --> 00:05:15.550
非常不寻常，如果你写点东西，就能得到大 O 的阶乘时间。
It's very unusual, if you write something,
to get big O factorial time.

94
00:05:15.550 --> 00:05:19.040
但是别这样你的功能就永远不会结束了
But just don't, your function
will pretty much never finish,

95
00:05:19.040 --> 00:05:20.584
情况会越来越糟
it'll just get worse and worse.

96
00:05:20.584 --> 00:05:23.050
2n 的平方
2n, n squared,

97
00:05:23.050 --> 00:05:25.870
这些都是你想要逃避的可怕的时刻
those are all terrible running times
you want to avoid things like that.

98
00:05:26.910 --> 00:05:31.709
我们进入了一段合理的时间，我们进入了 n 个日志。
We get to a little bit reasonable times,
we get to n log n.

99
00:05:31.709 --> 00:05:35.939
所以我和我不去做什么对数函数
So the trick and I won't go into
what logarithmic means, but

100
00:05:35.939 --> 00:05:39.810
如果你对数据集进行迭代
the trick is think if you're
iterating over a data set, and

101
00:05:39.810 --> 00:05:42.519
每次迭代时都要减少元素数量
every time you iterate,
you're reducing the number of elements

102
00:05:42.519 --> 00:05:46.629
就像在过滤需要迭代的元素数一样。
as in you're filtering the number of
elements you need to iterate over.

103
00:05:46.629 --> 00:05:48.079
这将会是每次都要记录的时间。
That's going to be log time every time.

104
00:05:49.819 --> 00:05:53.810
因此，提供了一个良好的日志时间示例。
So giving a good example of log time.

105
00:05:53.810 --> 00:05:57.759
我们会得到一些日志时间树
We'll get some examples that are log time,
trees,

106
00:05:57.759 --> 00:06:01.019
tree 元素作为树是日志时间，因为树是有序的。
funny element as a tree is log
time because trees are ordered.

107
00:06:01.019 --> 00:06:05.399
所以我看着这里，我说，让我们说一个二进制搜索树。
So I look here and I say,
on let's say a binary search tree.

108
00:06:05.399 --> 00:06:07.970
这个元素是大还是小我要走了
Is this element bigger or
smaller, I'm gonna go left.

109
00:06:07.970 --> 00:06:10.470
越大或越小，向右，向左或向右。
Bigger or smaller,
go right, go left or right.

110
00:06:10.470 --> 00:06:14.370
所以没有时间对整个树进行迭代来找到我要找的东西
So, and no time iterating over the entire
tree to find the thing I'm looking for,

111
00:06:14.370 --> 00:06:15.389
这就是为什么它的记录时间
that's why it's log time,

112
00:06:15.389 --> 00:06:19.358
因为每次我都在减少可能的比赛次数
because every time I'm reducing
the number of possible matches.

113
00:06:19.358 --> 00:06:24.339
大澳，就是基地的情况，就是说我们
Big O n, that is kind of the base case,
that means we

114
00:06:24.339 --> 00:06:28.199
迭代整个数据集以执行我们正在尝试的任何操作。
iterated through the entire data set
to do whatever we're trying to do.

115
00:06:29.459 --> 00:06:30.389
会有很多事情发生的
That's gonna happen a lot.

116
00:06:31.894 --> 00:06:35.990
通常，您将其视为整个数据集的循环重复。
Generally, you see it as a for
loop reiterating over the entire dataset.

117
00:06:35.990 --> 00:06:38.588
最坏的情况可能是最常见的情况
Worst case scenario,
that's probably the most common case.

118
00:06:39.798 --> 00:06:44.850
日志 n 是，就像我之前说过的，
Log n is, like I said before you're
reducing the number of elements that

119
00:06:44.850 --> 00:06:49.560
在日志 n 和 n 之间，我要对整个数据集进行迭代。
are between log n and n is, I'm going to
have to iterate over the entire data set.

120
00:06:49.560 --> 00:06:53.100
但当我做每一次的迭代时，我将缩小我所寻找的东西。
But as I do every single iteration, I'm
going to narrow down what I'm looking for.

121
00:06:54.560 --> 00:06:56.629
而且 log n，这不太棒。
And log n, it's not great.

122
00:06:56.629 --> 00:06:58.329
这不是可怕的足球
It's not terrible soccer.

123
00:06:58.329 --> 00:06:59.269
就在中间的某个地方
It's somewhere in the middle there.

124
00:07:00.370 --> 00:07:03.569
每当你写任何算法时你总是在努力
What you're always striving whenever
you're writing any sort of algorithm

125
00:07:03.569 --> 00:07:06.596
你想用快速的时间来记录
you want log n time cuz that's fast,

126
00:07:06.596 --> 00:07:09.920
它的时间不超过 1，这意味着它没有
that's short of constant time which is
bigger than 1, which means it doesn't

127
00:07:09.920 --> 00:07:11.769
我们所做的事情总是会回到同一时间
matter what we're doing it's always
gonna return to the same time.

128
00:07:11.769 --> 00:07:13.250
不管它们是十亿还是万亿
It doesn't matter if they're billion or
trillion,

129
00:07:13.250 --> 00:07:15.029
它会同时返回的四倍
quadrillion it's always
gonna return the same time.

130
00:07:15.029 --> 00:07:18.870
但在不断的时间里写东西很困难，所以 log n。
But it's pretty hard to write
things in constant time, so log n.

131
00:07:19.889 --> 00:07:22.264
我知道我说的很像计算机科学术语
I know I'm saying a lot of like
computer sciency terms, but

132
00:07:22.264 --> 00:07:24.507
有很多公司会问你，大澳大的时间是多少 ?
a lot of companies will ask you,
what's the big O time?

133
00:07:26.882 --> 00:07:30.569
便宜的是这个和理解之类的，好的，
The cheap is looking at something
like this and understanding, okay,

134
00:07:30.569 --> 00:07:33.379
忘了大 Q大数据他们很想知道
forget big omega, big data,
they're fun to know.

135
00:07:33.379 --> 00:07:36.560
如果你把它扔出去，我就会说，哇，这个人挺聪明的。
And if you throw that out, I'll be like,
woah, this person is pretty smart.

136
00:07:36.560 --> 00:07:37.370
他们比我聪明
They're smarter than me.

137
00:07:37.370 --> 00:07:38.870
我想听听他们要说什么
I wanna hear what they have to say.

138
00:07:40.370 --> 00:07:45.409
但我所使用的方法是用数字四环来观察循环数
But the trick I use is looking at number
four loops looking at number of loops, and

139
00:07:45.409 --> 00:07:47.500
就像作弊一样
that's like the cheating way.

140
00:07:47.500 --> 00:07:51.646
那么，如果一个循环是 big-O n，
So, if one for loop is big-O n,

141
00:07:51.646 --> 00:07:55.350
这到底是什么东西
what's the big-O of this?

142
00:07:55.350 --> 00:07:56.180
>> n 到第三个。
&gt;&gt; n to the third.

143
00:07:56.180 --> 00:07:58.649
> > 对， n 个 cubed， n 到第三个。
&gt;&gt; Yes, n cubed, n to the third.

144
00:07:58.649 --> 00:08:02.009
因为我们反复迭代然后每次迭代都要迭代
Because we're iterating over and then
every iteration we have to iterate over

145
00:08:02.009 --> 00:08:05.670
再一次重复我们迭代的每一次迭代
again, and then every one of those
iterations we iterate over again.

146
00:08:05.670 --> 00:08:10.755
那么回去吧
So going back, Yeah,

147
00:08:10.755 --> 00:08:15.127
我们在这里， n 的平方， n 到第三，就像你在 10 年一样，
we're out here, n squared, n to the third,
as you get n to the 10 whatever,

148
00:08:15.127 --> 00:08:18.639
你会来这里但你永远也不会到达这条线的
you kind of get here but
you'll never get to this line really.

149
00:08:18.639 --> 00:08:22.240
这就是诀窍这是一个简单的诡计
And that's the trick, it's a simple trick.

150
00:08:22.240 --> 00:08:26.290
因此，将其应用于那些不需要外观的循环。
So apply that to things that are loops
that don't necessarily look like it.

151
00:08:26.290 --> 00:08:27.250
这到底是什么东西
What's the big-O of this?

152
00:08:33.139 --> 00:08:34.200
> n cubed?
&gt;&gt; n cubed?

153
00:08:34.200 --> 00:08:36.207
> > 对， n 再到第三，是循环计数，
&gt;&gt; Yes, n to the third again,
it's count the loops,

154
00:08:36.207 --> 00:08:38.710
每次你迭代的循环你都在迭代
every loop you're iterating over,
you're iterating over.

155
00:08:39.789 --> 00:08:44.929
没有特别的，事实上，那是我的 Jem 提示，计算循环。
There's no special, well actually,
that's my Jem tip, count the loops.

156
00:08:44.929 --> 00:08:48.049
有时候有点棘手我让它看起来是直的
It's a little tricky sometimes and
I make it seem straight forward in these

157
00:08:48.049 --> 00:08:51.711
示例，但通常对 Big-O 时间有一些概念。
examples, but generally have
some idea of the Big-O time.
