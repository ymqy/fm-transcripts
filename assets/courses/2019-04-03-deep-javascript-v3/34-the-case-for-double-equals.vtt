WEBVTT

1
00:00:00.000 --> 00:00:05.418
>> 凯尔 - 辛普森: 让我把这个给一个我想做的案件
&gt;&gt; Kyle Simpson: So let me bring this
down to a case that I wanna make,

2
00:00:05.418 --> 00:00:09.702
这件案子比我们的案子更直接
and this is much more
of a direct case than

3
00:00:09.702 --> 00:00:14.237
我从没说过这个话题
I've never made before about this topic.

4
00:00:14.237 --> 00:00:18.789
在这之前的大部分时间里我的基本外卖
Most of the time prior to this point,
my essential takeaway or

5
00:00:18.789 --> 00:00:24.564
我给大家的基本信息是 == == = 可以在代码中共存
my essential message to people was,
== and === can coexist in your code,

6
00:00:24.564 --> 00:00:29.024
你可以做出选择你不用躲过 ==
and you can make choices,
you don't have to avoid the ==,

7
00:00:29.024 --> 00:00:32.987
我要对这一点提出更有力的论据。
I'm going to make a stronger
argument to this point.

8
00:00:32.987 --> 00:00:40.698
您应该在所有可能的位置中选择 " == " 的更强的自变量。
The stronger argument that you should
prefer == in all possible places.

9
00:00:40.698 --> 00:00:42.601
我知道这会让一些人震惊
And I know this gonna
shock a few people but

10
00:00:42.601 --> 00:00:45.659
你必须要有开放的头脑来倾听这个论点
you're gonna have to have an open
mind to listen to this argument.

11
00:00:45.659 --> 00:00:50.469
把我们讨论到的所有事情都放在一起
Taking everything in whole in totality
that we've talked about together,

12
00:00:50.469 --> 00:00:55.048
包括我声称理解类型的代码是
including the fact that it is my claim
that code that understands types is

13
00:00:55.048 --> 00:00:57.542
更好的代码不管选择如何
better code regardless of the choice.

14
00:00:57.542 --> 00:01:03.698
在此范围内，我认为可以说 == = === 。
Within that context, I think I can make
the case that == is preferable to ===.

15
00:01:05.935 --> 00:01:13.079
>> Kyle Simpson: 因此了解类型总比不了解类型好。
&gt;&gt; Kyle Simpson: So knowing the types
is always better than not knowing them.

16
00:01:13.079 --> 00:01:15.746
密码的不确定性让代码难以理解
The uncertainty of code is
what make code hard to read,

17
00:01:15.746 --> 00:01:17.489
它使代码易受虫子的影响。
it makes code susceptible to bugs.

18
00:01:17.489 --> 00:01:23.159
有些人说不知道自己的类型的问题，我要
Some people respond to that problem of not
knowing their types by saying, I need to

19
00:01:23.159 --> 00:01:28.599
更改我的编码样式以使用静态输入，如 TypeScript 和其他类型。
change my coding style to use static
typing, like TypeScript and the others.

20
00:01:28.599 --> 00:01:31.932
我们要在一段时间里讨论 TypeScript
We're gonna talk about
TypeScript in just a moment but

21
00:01:31.932 --> 00:01:35.709
我不认为这是解决这个问题的唯一对策。
I don't think that that is
the only response to this problem.

22
00:01:35.709 --> 00:01:40.234
这个问题还有一个反应， >> Kyle Simpson:
There's another response to this problem,
&gt;&gt; Kyle Simpson: So

23
00:01:40.234 --> 00:01:46.063
== 不是关于未知类型的比较，这不是它的对象，也不是
== is not about comparisons with unknown
type, that's not what it's for and that's

24
00:01:46.063 --> 00:01:51.277
而不是你应该用的，这和大多数人的说法是相反的。
not what you should use it for, that is
the opposite of what most people claim.

25
00:01:51.277 --> 00:01:55.902
大多数人声称他们在不知道类型的情况下使用 == ，然后
Most people claim that they use == when
they don't know the types, and then they

26
00:01:55.902 --> 00:02:00.078
就会掉到这些虫子里我是说别在那个场景里用它
fall into these bugs and I'm saying
don't use it in that scenario at all.

27
00:02:00.078 --> 00:02:05.390
当您不知道类型时，永远不要使用 == 。
Never use the == when you
don't know the types, ever.

28
00:02:05.390 --> 00:02:09.456
仅当了解类型时才使用 == 。
Only use the == when you know the types.

29
00:02:09.456 --> 00:02:14.283
就像我说的你应该努力了解你的
And as I said, you should strive
to know the types in your

30
00:02:14.283 --> 00:02:17.280
尽可能的比较。
comparisons as much as possible.

31
00:02:17.280 --> 00:02:21.832
它是关于与已知类型和 ( 可选) 的比较，
It's about comparisons with
known types and optionally,

32
00:02:21.832 --> 00:02:24.210
如果你想强迫他
if you like to have coercions.

33
00:02:24.210 --> 00:02:27.521
也许你的所有比较都知道这些类型和
Maybe all of your comparisons
you know the types and

34
00:02:27.521 --> 00:02:32.218
也许所有这些类型都是平等的而且你从来没有使用过胁迫
maybe all of those types are always
equal and you never use coercion, and

35
00:02:32.218 --> 00:02:35.079
仍在此场景中 == 是首选项。
still in that scenario == is preferable.

36
00:02:36.656 --> 00:02:39.280
>> 凯尔 - 辛普森: 但也许有些时候你想利用
&gt;&gt; Kyle Simpson: But maybe some of
the times you wanna take advantage

37
00:02:39.280 --> 00:02:42.451
而 == 是你唯一的选择
of coercion, and
then == is essentially your only option.

38
00:02:44.218 --> 00:02:46.766
>> 凯尔 - 辛普森: 所以让我们在这里挖掘细微的细节因为我知道你们中的一些人
&gt;&gt; Kyle Simpson: So let's dig into
the nuance here because I know some of you

39
00:02:46.766 --> 00:02:49.164
我就不会相信我了好吗
are not gonna believe me just
right off the bat, okay?

40
00:02:49.164 --> 00:02:54.086
如果你知道对比中的类型你就会发现
Let's dig into the nuance here,
if you know the types in a comparison,

41
00:02:54.086 --> 00:02:55.736
我觉得你应该
and I think you should.

42
00:02:55.736 --> 00:03:01.122
如果您知道比较中的类型，并且这两种类型都是相同的，
If you know the types in a comparison and
both of the types are the same,

43
00:03:01.122 --> 00:03:05.340
那么我们已经知道 == = ===。
then we already know that
== is identical to ===.

44
00:03:05.340 --> 00:03:09.652
我们已经知道他们的互换性，在你了解他们的情况下
We already know their interchangeable,
in the case where you know them and

45
00:03:09.652 --> 00:03:10.757
他们是一样的
they are the same.

46
00:03:10.757 --> 00:03:15.322
你是说，是的，但这并不意味着我不知道如何使用它。
So you're saying, yeah, but that doesn't
mean that I don't know how to use it.

47
00:03:15.322 --> 00:03:20.115
我的索赔是，在该方案中不需要使用 ===
My claim is, using === is
unnecessary in that scenario and

48
00:03:20.115 --> 00:03:22.984
你应该更喜欢短的 ==
you should prefer the shorter ==.

49
00:03:22.984 --> 00:03:29.926
这不仅仅是用一个更少的字符，好吗 ?
That is not just about using
one fewer character, okay?

50
00:03:29.926 --> 00:03:32.986
有些人知道 TypeScript 做了很多工作
Some of you know that
TypeScript does a lot of work,

51
00:03:32.986 --> 00:03:35.271
即使你不做任何类型的人
even if you don’t do any types at all.

52
00:03:35.271 --> 00:03:38.132
在这里我没有任何类型的注释
Here I have no types annotated once so
ever and

53
00:03:38.132 --> 00:03:41.985
还做一大堆推论，推断，好吗 ?
it still does a bunch of inference,
type inference, okay?

54
00:03:41.985 --> 00:03:48.125
在此特定情况下，错误告诉我的是我不应该使用 ===
In this particular case what the error
is telling me is I should not use a ===

55
00:03:48.125 --> 00:03:53.334
因为类型不同，这将始终为 false。
because the types are different,
and this will always be false.

56
00:03:53.334 --> 00:03:55.038
现在我不知道你的事了
Now I don't know about you, but

57
00:03:55.038 --> 00:03:57.951
我认为这是一个特别有用的错误信息。
I find that to be a particularly
useful error message.

58
00:03:57.951 --> 00:04:02.813
告诉我别做傻事总是会失败的
It is telling me don't do something
stupid that would always fail,

59
00:04:02.813 --> 00:04:06.070
百分百保证会失败好吗
100%, guaranteed to fail, all right?

60
00:04:06.070 --> 00:04:12.020
它知道它会失败，它告诉我不要无谓地这样做。
It knows that it'll fail, and
it tells me don't do it unnecessarily.

61
00:04:12.020 --> 00:04:15.425
我的主张是如果我们认为合理
My claim is that if we
find to be reasonable,

62
00:04:15.425 --> 00:04:19.113
那么反阳性也是合理的。
then the counter positive
is also reasonable.

63
00:04:19.113 --> 00:04:22.197
如果在类型不匹配时使用它是毫无意义的，
If it is pointless to use it
when the types don't match,

64
00:04:22.197 --> 00:04:25.029
当类型匹配时，不需要使用它。
it is unnecessary to use
it when the types do match.

65
00:04:30.665 --> 00:04:33.548
>> 凯尔 - 辛普森: 如果我们喜欢我们的人抱怨什么时候没有意义的话，
&gt;&gt; Kyle Simpson: If we like for our linter
to complain when it'd be pointless,

66
00:04:33.548 --> 00:04:36.829
那我们就应该有个在不必要的情况下抱怨的过客
then we ought to have a linter that
complains when it's unnecessary.

67
00:04:40.659 --> 00:04:45.178
>> 凯尔 - 辛普森: 如果你知道对比的类型，他们就不同了，
&gt;&gt; Kyle Simpson: So if you know the types
in a comparison, and they're different,

68
00:04:45.178 --> 00:04:47.841
这才是有趣的地方
this is where things get interesting,

69
00:04:47.841 --> 00:04:52.699
因为用 === 是在保护你，救你。
because supposedly using the ===
is protecting you and saving you.

70
00:04:52.699 --> 00:04:57.745
但是你知道类型，你知道不一样的，一个 ===
But if you know the types and you know
them to be different, a single === will

71
00:04:57.745 --> 00:05:03.338
始终失败，这是我们刚刚讨论的 TypeScript 规则的全部原因。
always fail, which is the whole reason for
that TypeScript rule we just talked about.

72
00:05:04.944 --> 00:05:09.031
>> 凯尔 - 辛普森: 它肯定会被打破，你和我一起吗 ?
&gt;&gt; Kyle Simpson: It would definitely
be broken, you're with me?

73
00:05:09.031 --> 00:05:13.141
所以你只有两个选择如果你知道这些类型和
So your only two options in that case,
if you know the types and

74
00:05:13.141 --> 00:05:16.384
他们不匹配你有两种选择
they don't match you,
have one of two options,

75
00:05:16.384 --> 00:05:20.122
您可以不进行比较，也可以使用 ==。
you can either not do the comparison or
you can use ==.

76
00:05:20.122 --> 00:05:22.913
那是你唯一的选择
Those are your only two options and

77
00:05:22.913 --> 00:05:28.110
如果你知道对比的类型他们就不一样了
if you know the types in a comparison,
and they're different,

78
00:05:28.110 --> 00:05:33.319
仅相当于单个 == 的值为两个或更多 ===。
the only equivalent to a single
== would be two or more ===.

79
00:05:35.697 --> 00:05:37.699
>> 凯尔 - 辛普森: 你不能有 ===
&gt;&gt; Kyle Simpson: You
can not have a === and

80
00:05:37.699 --> 00:05:43.014
如果类型不同，那么 == 是等效的，这是不可能的。
a == be equivalent when the types
are different, that is impossible.

81
00:05:43.014 --> 00:05:49.574
因此，如果您有一个可以使用一个 == 的方案，或者您可以使用两个或多个
So if you have a scenario where you could
use one ==, or you could use two or

82
00:05:49.574 --> 00:05:55.634
more === ，估计哪个要慢，两个 ===。
more ===, guess which one is
going to be slower, the two ===.

83
00:05:55.634 --> 00:05:58.966
让 JavaScript 进行胁迫的速度更快
It is faster to let JavaScript
do the coercion than it is for

84
00:05:58.966 --> 00:06:01.077
你要做些露体的
you to make a bunch of explicit ones.

85
00:06:01.077 --> 00:06:04.081
如果你要做 3 个或者 3 个
And it gets even worse if
you have to do three or

86
00:06:04.081 --> 00:06:07.653
四取决于胁迫的复杂性
four depending upon
the complexity of the coercion.

87
00:06:07.653 --> 00:06:14.029
现在我说慢，用引号，因为我们说的是微秒。
Now I say slower, in air quotes because
we're talking about microseconds.

88
00:06:14.029 --> 00:06:20.661
但在此场景中， === 绝对不可能。
But it is absolutely not possible for
a === to be faster in this scenario.

89
00:06:20.661 --> 00:06:25.805
在最好的情况下，它是平等的，实际上，
In the best possible scenario,
it's equal and actually, in reality,

90
00:06:25.805 --> 00:06:30.120
只是几次把它们列出来比较慢
it's just a tiny bit slower to
list them out multiple times.

91
00:06:30.120 --> 00:06:34.235
现在我不是在说仅在表演上是个论点
Now I'm not making the case that on
performance alone that's an argument,

92
00:06:34.235 --> 00:06:37.463
因为微秒差异不是相关的。
because the microsecond
difference is not that relevant.

93
00:06:37.463 --> 00:06:43.122
但这就是 === 不高于 ==的大案的一部分。
But this is part of the larger case
that === is not somehow superior to ==.

94
00:06:43.122 --> 00:06:47.105
很多人说 === 更快，不是强迫的。
Many people have said === is
faster cuz it doesn't coerce.

95
00:06:47.105 --> 00:06:49.353
那是橘子和橘子的比较
That's a apples to oranges comparison,

96
00:06:49.353 --> 00:06:53.860
cutz ，你说一个 === 快了一个 == ，不等于。
cuz you're saying one === is faster
than one == and they're not equivalent.

97
00:06:55.649 --> 00:06:59.646
>> 凯尔 - 辛普森: 如果你真的在看苹果，两个 ===
&gt;&gt; Kyle Simpson: If you actually looked
at an apples to apples two === is always

98
00:06:59.646 --> 00:07:02.464
有点慢于一个 ==
going to be a little
bit slower than one ==.

99
00:07:04.862 --> 00:07:09.797
>> Kyle Simpson: 因此，如果您在此场景中，可以执行两个 === 或
&gt;&gt; Kyle Simpson: So if you're in this
scenario where you could do two === or

100
00:07:09.797 --> 00:07:13.084
三，四，或者你可以做一个 ==，
three or four, or you could do one ==,

101
00:07:13.084 --> 00:07:18.694
我说你应该更喜欢那两个是单一的 ==
I say you should prefer the faster
of the two which is the single ==,

102
00:07:18.694 --> 00:07:24.242
这一论点的一部分，肯定不是整个论点的一部分。
part of the argument, certainly
not the entirety of the argument.

103
00:07:24.242 --> 00:07:29.384
最后，如果类型不同，而两个或更多的是比较，
And finally, if the types are different,
and two or more are what the comparisons,

104
00:07:29.384 --> 00:07:32.862
就是你要用的，就是两个或者两个以上的 ===，
that's what you would use,
is two or more of the ===,

105
00:07:32.862 --> 00:07:37.933
我的说法是它让读者失去了不必要的信息
my claim is that it's distracting the
reader with unnecessary type information,

106
00:07:37.933 --> 00:07:40.855
例如，在 null 未定义的情况下。
like in the null undefined case,
for example.

107
00:07:40.855 --> 00:07:44.761
没有人发现你在分散读者的注意力
And the no one find case, you're
distracting the reader there is these two

108
00:07:44.761 --> 00:07:48.547
不同的空值和奇怪的古怪的差异
different empty values and they sort
of have weird quirky differences.

109
00:07:48.547 --> 00:07:52.406
在大多数情况下，读者不需要看到这种情况，
That's not necessary for
the reader to see in most cases,

110
00:07:52.406 --> 00:07:57.605
在大多数情况下，通过显式列出和您拥有的内容来分散它们的注意力
in most cases you're distracting them
by listing explicitly and what you have

111
00:07:57.605 --> 00:08:03.064
要用的是更恰当的抽象性的强迫它是用 " ==" 来清除的
to use is the more properly abstracted
coercion that it's cleaner with the ==.

112
00:08:03.064 --> 00:08:05.764
记住这就是你知道的类型，对，
Now remember,
this is if you know the types, right,

113
00:08:05.764 --> 00:08:08.408
我只是想说你知道这些类型
I'm only making these claims
if you know the types.

114
00:08:08.408 --> 00:08:09.576
通过了解这些类型
And by know the types,

115
00:08:09.576 --> 00:08:13.278
我的意思是，对代码的读者来说，这些类型的含义是显而易见的。
I mean that it is obvious to the reader
of the code what the types will be.

116
00:08:16.055 --> 00:08:19.737
>> 凯尔 - 辛普森: 那么，对不起，还有一个，摘要幻灯片，
&gt;&gt; Kyle Simpson: So what about, sorry,
there's one more, the summary slide,

117
00:08:19.737 --> 00:08:20.408
当然
of course.

118
00:08:20.408 --> 00:08:26.552
如果您知道类型，那么在摘要中，无论类型是否匹配，
This is if you know the types, so in
summary, whether the types match or not,

119
00:08:26.552 --> 00:08:31.673
当你知道这些类型的时候， == 是更明智的选择，好吗 ?
== is the more sensible choice
when you know the types, okay?

120
00:08:31.673 --> 00:08:35.130
当您了解类型时， == 是更明智的选择，因此
When you know the types,
== is the more sensible choice, so

121
00:08:35.130 --> 00:08:39.534
让我们看看对方，在那些你不知道类型的情况下。
let's look at the other side, in those
cases where you don't know the types.

122
00:08:39.534 --> 00:08:45.153
如果您不知道类型，这意味着您不充分了解代码，
If you do not know the types, that means
you don't fully understand the code,

123
00:08:45.153 --> 00:08:48.147
这可能是不必要的要求
that may be an unnecessary requirement.

124
00:08:48.147 --> 00:08:52.006
不能保证 100% ，你一直都知道
It is not possible to guarantee 100%,
you always know

125
00:08:52.006 --> 00:08:56.748
整个系统的类型，不合理，不合理。
the types in the entire system,
that's not reasonable and rational.

126
00:08:56.748 --> 00:09:01.399
因此，我承认有时会有比较的时候，
So I recognize that there will be
times when comparisons happen, and

127
00:09:01.399 --> 00:09:03.413
还有一些不确定性
there's some uncertainty.

128
00:09:03.413 --> 00:09:09.070
我的主张是，这应该是一个稀有的，而不是现状。
My claim is that that should be
a rarity rather than the status quo.

129
00:09:09.070 --> 00:09:13.553
但它的意思是，不管它是稀有的还是现状，
But what it does mean, whether it's
a rarity or the status quo, is that that

130
00:09:13.553 --> 00:09:17.846
由于这种不确定性，部分代码更难理解。
part of the code is harder to understand
as a result of that uncertainty.

131
00:09:17.846 --> 00:09:22.840
因此，不知道这些类型意味着您无法完全了解该代码。
So not knowing the types means that
you don't fully understand that code.

132
00:09:22.840 --> 00:09:30.197
最佳响应是对其进行折射，以便您可以了解类型( 如果可能) 。
The best response is to refractor it so
that you can know the types, if possible.

133
00:09:30.197 --> 00:09:32.971
如果你不知道这些类型
If you don't know the types, and

134
00:09:32.971 --> 00:09:37.135
这种不明朗的因素必须得到处理
that uncertainty of knowing
just has to be dealt,

135
00:09:37.135 --> 00:09:42.009
然后至少让读者明白这一点。
then at least make sure that
that is obvious to the reader.

136
00:09:42.009 --> 00:09:46.471
请确保读者对此处存在某些不确定性是显而易见的。
Make sure that it is obvious to the reader
that there is some uncertainty here.

137
00:09:46.471 --> 00:09:47.503
输入代码注释，
Put a code comment,

138
00:09:47.503 --> 00:09:51.695
这样的话读者就不会有虚假的安全感，
structure it in such a way that the reader
doesn't have a false sense of security,

139
00:09:51.695 --> 00:09:55.490
他们认为他们知道发生了什么，而且实际上是不确定的。
they think they know what's happening,
and actually it's uncertain.

140
00:09:55.490 --> 00:09:59.754
应该是很明显，不管你怎么做都不确定
It should be super obvious that it's
uncertain in whatever possible way you

141
00:09:59.754 --> 00:10:03.293
因为我们再次试图传达我们的意图
can, because again we're trying
to communicate our intent.

142
00:10:03.293 --> 00:10:07.298
我的意思是告诉你这很不确定
My intent here is to tell you that
it's uncertain, just so you know,

143
00:10:07.298 --> 00:10:11.876
就会有龙，对，这就是我们想用我们的代码来做的。
beware there'll be dragons, right,
that's what we wanna do with our code.

144
00:10:11.876 --> 00:10:14.803
这对读者来说应该是显而易见的
So it should be obvious to the reader, and

145
00:10:14.803 --> 00:10:19.749
您可以使用的最明显的信号是 ===。
the most obvious signal you can
use about that uncertainty is ===.

146
00:10:19.749 --> 00:10:23.000
如果你遵循我在第一条条款中所主张的
If you followed what I argued
in the first set of clauses,

147
00:10:23.000 --> 00:10:27.403
即，当您了解类型时， == 是首选项，然后使用
which is that the == is preferable when
you know the types, then the usage of

148
00:10:27.403 --> 00:10:31.572
=== 应该为您不知道类型的情况保留。
=== should be reserved for
the cases where you don't know the types.

149
00:10:33.480 --> 00:10:36.178
>> 凯尔 - 辛普森: 所以它向读者发出信号，我不知道这些类型，
&gt;&gt; Kyle Simpson: So that it signals to
the reader, I don't know the types,

150
00:10:36.178 --> 00:10:37.677
我在努力保护自己
I'm trying to protect myself.

151
00:10:41.764 --> 00:10:45.929
>> 凯尔 - 辛普森: 它应该跳出来，读者应该看到，这里有一个 === 。
&gt;&gt; Kyle Simpson: It should jump out,
the reader should see, there's a === here.

152
00:10:45.929 --> 00:10:48.663
这意味着这些类型存在一些不确定性，并且
That means there are some
uncertainty of the types, and

153
00:10:48.663 --> 00:10:51.879
我们得把自己限制在一个角落
we need to restrict ourselves so
we don't run into a corner case.

154
00:10:54.822 --> 00:10:59.927
>> Kyle Simpson: 还有，我说不知道类型是等价的
&gt;&gt; Kyle Simpson: Also, I would say that
not knowing the types is equivalent

155
00:10:59.927 --> 00:11:05.461
以假定将发生类型转换或类型强制。
to assuming that type conversion or
type coercion will occur.

156
00:11:05.461 --> 00:11:09.462
这相当于假设如果你不知道这些类型
It's equivalent to assuming that
because if you don't know the types,

157
00:11:09.462 --> 00:11:13.855
最坏的情况是它们不匹配并且在某些情况下不匹配
the worst case scenario is that they will
not match and they will not match in some

158
00:11:13.855 --> 00:11:17.158
一种奇怪的方式来引起一些奇怪的胁迫
weird way that invokes some
weird corner case of coercion.

159
00:11:17.158 --> 00:11:19.659
你得想好最坏的情况
You need to assume the worst case.

160
00:11:19.659 --> 00:11:24.947
所以不知道这种情况的类型与最坏的情况是一样的。
So not knowing the types of equivalent
to that worst case coercion.

161
00:11:24.947 --> 00:11:27.585
唯一明智的回应是
And the only sensible response to that,

162
00:11:27.585 --> 00:11:32.485
唯一安全的响应是使用 === 保护您自己。
the only safe response to that is
protect yourself from that with a ===.

163
00:11:32.485 --> 00:11:38.682
如果你不能也不能，用一个你能知道的，
In summary if you can't or won't,
use a style where you can know and

164
00:11:38.682 --> 00:11:43.794
有明显的类型，唯一明智的
have obvious types,
the only thing that is sensible and

165
00:11:43.794 --> 00:11:47.522
== = 是合理的。
reasonable is for you to use the ===.

166
00:11:47.522 --> 00:11:51.470
如果使用 ===，这不是针对您的攻击。
This isn't meant to be an attack
against you if use ===.

167
00:11:51.470 --> 00:11:55.148
我只是想以实际行动来重新讨论
I'm just trying to reframe this
discussion in a way that actually moves

168
00:11:55.148 --> 00:11:58.825
而不是一场宗教争论的讨论
the discussion forward rather than
a sort of religious debate of well,

169
00:11:58.825 --> 00:12:03.018
这本书说从来没有用过，我也从来没有考虑过别的。
this one book said never use it, and
I've never even considered anything else.

170
00:12:03.018 --> 00:12:07.849
我其实是想在这里做一套理性的分析
I'm actually trying to make a rational
set of analysis here to come to some real

171
00:12:07.849 --> 00:12:11.447
结论不只是一个人说的好吗
conclusion, not just the thing
that one guy said, okay?

172
00:12:11.447 --> 00:12:16.663
你可以测试我的分析，如果你不同意我的理由，那就好。
And you can test my analysis, if you don't
agree with my rationale, that's okay.

173
00:12:16.663 --> 00:12:20.854
但我要搁置这件案子让你能测试理由
But I'm laying out this case so
that you can test the rationale.

174
00:12:20.854 --> 00:12:23.730
即使在这种情况下我也会这样说
And I would say this,
even in that scenario,

175
00:12:23.730 --> 00:12:27.745
你要用一个 === 的每个地方都是一样的，
where every place that you would
use a === would be the same,

176
00:12:27.745 --> 00:12:33.043
就相当于一个 ==，所以你说，你知道，我们就是想简单的
it would be equivalent to a ==, and so you
say, you know, we just want the simpler

177
00:12:33.043 --> 00:12:38.028
因为林德赫斯特说的，我们想用的东西到处都是 == = 。
thing we want to use === everywhere
because that's what Lyndhurst says.

178
00:12:38.028 --> 00:12:41.745
你实际做的是把错误的语义信号发送给
What you are actually doing is sending
the wrong semantic signal to a reader of

179
00:12:41.745 --> 00:12:42.327
你的密码
your code.

180
00:12:42.327 --> 00:12:46.043
我在这些案子里保护自己因为我不知道
Which is I’m protecting myself in all of
these cases because I don't know about

181
00:12:46.043 --> 00:12:46.605
类型。
the types.

182
00:12:48.539 --> 00:12:51.790
>> 凯尔 - 辛普森: 那不是传达你要传达的信息
&gt;&gt; Kyle Simpson: And that is not
communicating what you put to communicate

183
00:12:51.790 --> 00:12:53.558
向未来的读者提供密码
to future readers of the code.

184
00:12:53.558 --> 00:12:57.062
了解语义信号的代码的未来读者，
Future readers of the code
that see the semantic signal,

185
00:12:57.062 --> 00:13:02.318
我不知道类型，所以我要回一些 === 保护自己，
I don't know about the types, so I've to
fall back to some === to protect myself,

186
00:13:02.318 --> 00:13:06.845
这些代码的未来读者更有可能重写代码
those future readers of the code are much
more likely to rewrite the code,

187
00:13:06.845 --> 00:13:09.111
因为他们不懂
because they don't understand it.

188
00:13:09.111 --> 00:13:11.462
他们会第一次做你该做的
They're gonna do what you should
have done the first time.

189
00:13:11.462 --> 00:13:15.402
他们会把它重构到已知类型的地方
They're gonna refactor it to
where the types are known.

190
00:13:15.402 --> 00:13:17.667
不确定对于您的代码并不是一件好事。
Uncertainty is not a good thing for
your code basis.

191
00:13:19.743 --> 00:13:23.384
>> Kyle Simpson: 因此，摘要中，使您的类型为已知和
&gt;&gt; Kyle Simpson: So in summary,
making your types known and

192
00:13:23.384 --> 00:13:26.426
就会有更好的密码
obvious just leads to better code.

193
00:13:26.426 --> 00:13:29.105
没有任何理由可以提出相反的意见。
There's no argument that can
be made to the contrary.

194
00:13:29.105 --> 00:13:34.116
了解类型可导致更好的代码，如果类型已知，那么 == 始终最好。
Knowing the types leads to better code and
if the types are known, == is always best.

195
00:13:35.869 --> 00:13:39.201
>> 凯尔 - 辛普森: 在每种情况下，最好是在已知类型的情况下 ==
&gt;&gt; Kyle Simpson: In every scenario ==
is best when the types are known and

196
00:13:39.201 --> 00:13:42.965
在任何情况下都不能返回到 ===。
in any scenario where you can't
you should fall back to ===.

197
00:13:42.965 --> 00:13:48.498
我很清楚这件案子很有争议
I'm fully aware that case
is quite controversial.

198
00:13:48.498 --> 00:13:52.294
而你们中的任何一个人都不太相信
And it's unlikely that any of you
are convinced at the moment by that

199
00:13:52.294 --> 00:13:53.100
讨论。
discussion.

200
00:13:53.100 --> 00:14:00.231
但我真正想问的是，你要回去思考。
But what I would really like to ask
you is to go back and think about it.

201
00:14:00.231 --> 00:14:03.346
后退并测试此原理，并针对您的代码进行测试。
Go back and test this rationale and
test it against your code.

202
00:14:03.346 --> 00:14:08.067
问自己真的是写更清楚的代码吧
Ask yourself if you really are writing
better code that is more clearly

203
00:14:08.067 --> 00:14:12.309
通过简单使用 === 来传达其意图。
communicating its intent by
simply using === everywhere.

204
00:14:12.309 --> 00:14:14.510
我不能为你做这些决定
I can't make those decisions for you but

205
00:14:14.510 --> 00:14:19.250
我认为我已经做了最有力的例子，因为我可以重新分析他们的原因。
I think I've made the most solid case that
I can, for why they should be re-analysed.
