WEBVTT

1
00:00:00.420 --> 00:00:02.970
>> 扬声器 2: 如果函数已使用绑定绑定
&gt;&gt; Speaker 2: If function
is already bound using bind

2
00:00:02.970 --> 00:00:05.459
可以在以后重新绑定到其他对象。
can be rebound to
a different object later.

3
00:00:06.650 --> 00:00:11.199
>> 凯尔 - 辛普森: 好，我们这次讨论的这个单位，
&gt;&gt; Kyle Simpson: Okay, so in our this
discussion a bit earlier in this unit,

4
00:00:11.199 --> 00:00:14.550
我们讨论了一个尚未约束的函数
we talked about the idea that
a function that is not yet bound,

5
00:00:14.550 --> 00:00:19.859
你可以调用它并产生一个被称为硬约束的函数，好吗 ?
you can call that bind on it and produces
a so called hardbound function, all right?

6
00:00:19.859 --> 00:00:25.710
该硬约束函数被固定到您说要绑定到的上下文中，
That hardbound function is fixed to
the context that you said to bind it to,

7
00:00:25.710 --> 00:00:29.690
只有一种方法可以覆盖这一结合
and there's only one possible
way to override that binding.

8
00:00:29.690 --> 00:00:32.329
您不能再次调用 .bind ，但是
You cannot call .bind on it again, but

9
00:00:32.329 --> 00:00:36.350
你可以用一个新的关键词来引用它
you could invoke it with a new key word,
which would have the effect of

10
00:00:36.350 --> 00:00:40.479
将此行为覆盖为新构建的对象。
overriding its this behavior to
be a newly constructed object.

11
00:00:41.570 --> 00:00:45.100
所以这个问题的答案只是通过新的关键词。
So the answer to that question
is only via the new keyword.

12
00:00:45.100 --> 00:00:49.420
您不能重新绑定并将其重新绑定到其他位置。
You cannot recall.bind and
rebind it somewhere else.

13
00:00:52.000 --> 00:00:55.192
>> 扬声器 2: 如果在箭头函数中定义变量，
&gt;&gt; Speaker 2: If you define
a variable inside an arrow function,

14
00:00:55.192 --> 00:00:59.509
是作用域限定为箭头函数或父作用域的变量吗 ?
is that variable scoped to the arrow
function or to the parent scope?

15
00:01:00.780 --> 00:01:01.820
>> 凯尔 - 辛普森: 好的问题。
&gt;&gt; Kyle Simpson: Good question.

16
00:01:01.820 --> 00:01:05.180
箭头函数具有词法作用域。
Arrow functions do have lexical scope.

17
00:01:05.180 --> 00:01:07.000
他们只是没有这个关键词
They just don't have this keyword.

18
00:01:07.000 --> 00:01:09.989
我见过很多地方有人说
I've seen actually a number
of places where people say

19
00:01:09.989 --> 00:01:11.900
箭头函数没有作用域。
that arrow functions don't have scope.

20
00:01:11.900 --> 00:01:13.489
他们绝对有范围。
They absolutely have scope.

21
00:01:13.489 --> 00:01:15.870
他们的词法就像任何其他的函数一样。
They are lexical just
like any other function.

22
00:01:15.870 --> 00:01:19.569
所以如果你在一个箭头函数中定义一个变量它就像定义
So if you define a variable inside of an
arrow function it's exactly like defining

23
00:01:19.569 --> 00:01:22.289
任何其他功能中的任何其他变量。
any other variable in any
other kind of function.

24
00:01:22.289 --> 00:01:26.510
这两个人之间唯一的区别就是
The only difference between those two,
really, is the difference of regular

25
00:01:26.510 --> 00:01:31.439
函数定义此关键字，而箭头函数不定义此关键字。
functions define a this keyword, and arrow
functions don't define a this keyword.

26
00:01:31.439 --> 00:01:36.353
>> 扬声器 2: 在此为回调的情况下，此值取决于
&gt;&gt; Speaker 2: In the case of the this were
callback, does the value of this depend

27
00:01:36.353 --> 00:01:40.500
更高阶函数调用回调的方式吗 ?
upon how the higher order
function calls the callback?

28
00:01:43.390 --> 00:01:46.740
>> 凯尔 - 辛普森: 是的，电话站点是唯一重要的事情。
&gt;&gt; Kyle Simpson: Yes, the call site
is the only thing that matters.

29
00:01:46.740 --> 00:01:50.545
所以如果你通过一个函数的话
So if you pass a function into say .map,

30
00:01:50.545 --> 00:01:56.560
.map 如何调用回调是确定其此绑定的唯一方法。
how .map invokes your callback is the only
thing that determines its this binding.

31
00:01:56.560 --> 00:02:00.248
除非你有一个强硬的函数，在这个情况下，
Unless you have passed in
a hardbound function, in which case,

32
00:02:00.248 --> 00:02:02.719
你的强硬有先例
your hard binding has taking precedence.

33
00:02:02.719 --> 00:02:04.248
但是在内部地图上
But .map internally,

34
00:02:04.248 --> 00:02:09.719
你可以把它想象成一个叫 CB 的封闭括号或者类似的东西。
you can think of it as calling CB open
closed parentheses or something like that.

35
00:02:09.719 --> 00:02:12.389
那个电话网站对这一点没有约束力
That call site isn't binding of this.

36
00:02:13.419 --> 00:02:19.013
所以你的高位功能，你的 arrayraymap 或 filter，
So yes, absolutely your high order
functions, your array.map or filter,

37
00:02:19.013 --> 00:02:24.259
这些都是绝对有这种微妙的，或者说这个微妙的
all those, those all absolutely have
this nuance or this quirk to it that

38
00:02:24.259 --> 00:02:30.588
如何调用您的函数完全确定此上下文将是什么。
how they invoke your function entirely
determines what the this context will be.

39
00:02:30.588 --> 00:02:32.870
>> 扬声器 2: 当您设置受影响的 proto时发生了什么 ?
&gt;&gt; Speaker 2: What happens
when you set dunder proto?

40
00:02:34.439 --> 00:02:35.509
>> 凯尔 - 辛普森: 好的问题。
&gt;&gt; Kyle Simpson: Good question.

41
00:02:35.509 --> 00:02:40.259
使用 Don Proto as a setter方法并不常见。
It is not very common for
you to use the Dunder Proto as a setter.

42
00:02:40.259 --> 00:02:43.689
从技术上来说，它既是一种消气剂，也是一种制定剂。
It is technically both a getter and
a setter.

43
00:02:43.689 --> 00:02:47.270
几乎总是用它来引用它。
It is almost always used
just to reference it.

44
00:02:47.270 --> 00:02:49.139
我要说的是
And I would say generally speaking,

45
00:02:49.139 --> 00:02:54.159
它是一种反模式来对对象的原型链进行重新连线。
it's sort of an anti-pattern to rewire
the prototype chain of an object.

46
00:02:54.159 --> 00:02:59.079
但是在 ES6 的情况下， ddrd proto 也正式成为了
But as of ES6,
dunder proto is officially also something

47
00:02:59.079 --> 00:03:04.210
可以将 proto 链接从一个对象设置为另一个对象。
that can set the proto linkage from
one object to a different object.

48
00:03:04.210 --> 00:03:07.699
所以如果你有一个对象 A
So if you have an object
A that's linked over here and

49
00:03:07.699 --> 00:03:11.400
然后你决定我要把这个对象的原型链接到这里
then later you decide, I want that
object prototype linked over here,

50
00:03:11.400 --> 00:03:14.909
您可以使用 drod proto 作为设置者来更改它。
you can use dunder proto
as a setter to change it.

51
00:03:14.909 --> 00:03:17.920
还有一个实用程序
And there's also a utility or

52
00:03:17.920 --> 00:03:22.599
API 版本的对象为 object.setPrototypeOf。
an API version of that called
object.setPrototypeOf.

53
00:03:22.599 --> 00:03:25.949
这将允许您使用任何对象并对其进行重新连线。
Which will allow you to take
any any object and rewire it.

54
00:03:25.949 --> 00:03:30.804
我说你有 0.001% 的时间
I would say 0.001% of the time
do you ever see anybody rewiring

55
00:03:30.804 --> 00:03:35.060
原型链，但是是，你绝对能做到，
prototype chains, but yes,
you absolutely can do them and

56
00:03:35.060 --> 00:03:40.187
在某些情况下，它可能是非常有力和有用的。
it might in fact be very powerful and
useful in certain circumstances.

57
00:03:44.288 --> 00:03:45.899
>> 扬声器 2: 执行原型对象，
&gt;&gt; Speaker 2: Do the prototype objects,

58
00:03:45.899 --> 00:03:49.188
每个功能都预先安装了正方形吗 ?
the squares come pre-installed
with every function?

59
00:03:52.900 --> 00:03:55.099
>> 凯尔 - 辛普森: 所以问题是。
&gt;&gt; Kyle Simpson: So the question is.

60
00:03:55.099 --> 00:04:00.080
在我画的图中，我们为一个功能画了一个圆圈。
In the diagram that I was drawing,
where we drew a circle for a function.

61
00:04:00.080 --> 00:04:03.590
然后我们在这里画了一个正方形，它是它的点原型。
And then we drew a square over here,
which was its dot prototype.

62
00:04:03.590 --> 00:04:08.280
常规函数具有点原型，箭头函数不具有。
Regular functions have dot prototypes,
arrow functions do not.

63
00:04:08.280 --> 00:04:12.650
所以如果我们有一个正常的功能，它是一个声明，它是一个表情，
So if we have a regular function,
it's a declaration, it's an expression,

64
00:04:12.650 --> 00:04:14.189
是匿名的名字
it's anonymous, its name.

65
00:04:14.189 --> 00:04:16.930
所有这些都有一个正方形
All of those are always
gonna have a square.

66
00:04:16.930 --> 00:04:20.470
但如果你有一个箭功能它就不会有雏形了
But if you make an arrow function
it's not gonna have a prototype,

67
00:04:20.470 --> 00:04:24.370
这就是为什么当你对它进行新调用的时候，它失败了。
which is why by the way when
you call new on it, it fails.

68
00:04:24.370 --> 00:04:26.470
因为它不是一个构造函数。
Because it is not a constructor.

69
00:04:26.470 --> 00:04:30.329
它没有原型，因此无法使用新关键字来构造它。
It doesn't have a prototype so it can't
be constructed with the new keyword.

70
00:04:30.329 --> 00:04:34.340
>> 扬声器 3: 它只是一个侧面问题，因为您使用了关键字
&gt;&gt; Speaker 3: It just a side question
because you said use the keyword

71
00:04:34.340 --> 00:04:35.629
超级也。
super also.

72
00:04:35.629 --> 00:04:38.042
它也能被用作原型吗 ?
Can it be used as a prototype too?

73
00:04:38.042 --> 00:04:38.610
>> 凯尔 - 辛普森: 好的问题。
&gt;&gt; Kyle Simpson: Good question.

74
00:04:38.610 --> 00:04:43.269
所以超级关键词能在课堂以外使用，
So the super keyword,
is able to used outside of classes,

75
00:04:43.269 --> 00:04:45.759
当你处理物体和它们的方法时
when you're dealing with objects and
their methods.

76
00:04:45.759 --> 00:04:47.689
你可以去拿一个物体
So you could go and take one object and

77
00:04:47.689 --> 00:04:51.149
将其连接到具有原型链接的另一个对象。
wire it up to another object
with the prototype linkage.

78
00:04:51.149 --> 00:04:53.019
我们会在这个模式下进行研究。
We're gonna look at that pattern in a bit.

79
00:04:53.019 --> 00:04:56.370
使对象在没有类的情况下进行链接的想法。
The idea of making objects that
are linked without classes.

80
00:04:56.370 --> 00:05:00.199
从技术上来说你可以在其中一个方法中
And you could use technically a super
inside one of those methods to

81
00:05:00.199 --> 00:05:02.800
请参阅原型链中的一些内容。
refer to something of the prototype chain.

82
00:05:02.800 --> 00:05:06.839
caveat 是超级关键字未动态绑定，
The caveat is that the super
keyword is not dynamically bound,

83
00:05:06.839 --> 00:05:12.329
它是静态绑定的，这意味着您实际上必须创建一个对象
it is statically bound which means to use
that you actually have to create an object

84
00:05:12.329 --> 00:05:17.540
字面上的字面值，并且在此时必须链接到对象。
literal with the method in it, and it has
to at that moment be linked to the object.

85
00:05:17.540 --> 00:05:22.369
换句话说，你无法接受一个物体，改变它的雏形，
So in other words, you won't be able to
take one object, change its prototype, and

86
00:05:22.369 --> 00:05:25.370
神奇的是另一个是超级的
magically have super
refer to the other one.

87
00:05:25.370 --> 00:05:30.209
它在第一次被创建到它所链接的任何地方都是静态的。
It is statically bound the first time
it's created to wherever it's linked.

88
00:05:30.209 --> 00:05:32.980
但是可以在对象字面值中使用超级字符
But yes, you can use super
inside of object literals

89
00:05:32.980 --> 00:05:35.829
只要是简洁的方法
as long as they
are the concise method form.
