WEBVTT

1
00:00:00.012 --> 00:00:02.873
>> 凯尔 - 辛普森: 让我们谈谈提升。
&gt;&gt; Kyle Simpson: Let’s
talk about hoisting.

2
00:00:02.873 --> 00:00:05.509
你们有多少人听过这句话 ?
How many of you have heard
the phrase hoisting before?

3
00:00:05.509 --> 00:00:10.948
好的，它被抛出或者被抛出了很长一段时间。
Okay, it is thrown around or has been
thrown around JavaScript for a long time.

4
00:00:10.948 --> 00:00:14.516
此外，变量提升并提升并提升该值。
As well, variables hoist, and
hoisting this and hoisting that.

5
00:00:14.516 --> 00:00:18.521
直到最近一两年内
Until recently,
that is within the last year or two,

6
00:00:18.521 --> 00:00:24.495
字提升机甚至没有出现在 JavaScript 规范中。
the word hoist literally did not even
appear in the JavaScript specification.

7
00:00:24.495 --> 00:00:29.740
因为事实证明吊起并不是一件真实的事情。
Because it turns out that hoisting
is not actually a real thing.

8
00:00:29.740 --> 00:00:31.811
JavaScript 引擎未挂起，
The JavaScript engine does not hoist,

9
00:00:31.811 --> 00:00:35.457
它不会绕它建议吊装的方式移动。
it does not move things around
the way it is suggested with hoisting.

10
00:00:35.457 --> 00:00:38.372
我的坚持是我们所做的一个比喻。
Hoisting is a metaphor
that we have made up.

11
00:00:38.372 --> 00:00:41.904
这是我们所做的语言约定
It is a language convention
that we have made up, and

12
00:00:41.904 --> 00:00:44.485
我是说英语公约
I mean English language convention.

13
00:00:44.485 --> 00:00:49.652
这是我们要讨论的英语语言公约
It is an english language convention
that we have made up to discuss

14
00:00:49.652 --> 00:00:55.484
词法范围的概念，不考虑词法范围，好吗 ?
the idea of lexical scope, without
thinking about lexical scope, okay?

15
00:00:55.484 --> 00:01:00.634
我来告诉你为什么它不存在，为什么不可能呢 ?
And I'll show you why it doesn't actually
exist, why it's really not even possible

16
00:01:00.634 --> 00:01:05.298
因为它有这么简单的代码，它只需要几条线。
for it to exist with this very simple
piece of code, it only takes a few lines.

17
00:01:05.298 --> 00:01:08.454
如果你试图解释第一个是什么
If you try to explain what
happens with line one, and

18
00:01:08.454 --> 00:01:12.492
我们用我们已经讨论过的词法范围的讨论
we use the lexical scope discussion
like we already talked about.

19
00:01:12.492 --> 00:01:15.192
然后，您将首先通过此作为编译器，并且
Then you would first pass through
this as the compiler, and

20
00:01:15.192 --> 00:01:17.359
那你就会把它当作行刑
then you would pass through
it as an execution.

21
00:01:17.359 --> 00:01:20.197
但人们不喜欢做的事情
But what people don't like doing,
it seems,

22
00:01:20.197 --> 00:01:23.052
从两条过去的角度来思考这个问题
is thinking about this
in terms of two passes.

23
00:01:23.052 --> 00:01:28.189
人们似乎想过一次就能通过它
People seem to be wanting to be stuck
on passing through it just once.

24
00:01:28.189 --> 00:01:30.191
两票看起来更乱
Two passes seems more confusing,

25
00:01:30.191 --> 00:01:33.578
只要给我一个有用的解释
just give me an explanation
that works with a single pass.

26
00:01:33.578 --> 00:01:37.774
无论是否属实，我只想更方便地解释。
Whether it's true or not,
I just want a more convenient explanation.

27
00:01:37.774 --> 00:01:39.858
这就是吊装的来源。
And that's where hoisting comes from.

28
00:01:39.858 --> 00:01:44.316
库兹吊装说我们可以解释这里到底发生了什么
Cuz hoisting says, well,
we could explain what really happens here,

29
00:01:44.316 --> 00:01:47.674
如果有这种神奇的行为叫做提升
if there was this magical
behavior called hoisting.

30
00:01:47.674 --> 00:01:53.441
任何时候 JavaScript的执行引擎都进入了一个范围
Which was that any time JavaScript's
execution engine entered a scope,

31
00:01:53.441 --> 00:01:58.835
它神奇地向前看，在任何地方都发现了所有的声明
it magically looked ahead and
found all of the declarations wherever

32
00:01:58.835 --> 00:02:03.781
他们在那个范围内，为他们做了变数，对吧 ?
they were in that scope, and
made variables for them, right?

33
00:02:03.781 --> 00:02:09.358
就像 JavaScript 引擎去发现那些变量声明
So it's as if the JavaScript engine goes
and finds those variable declarations and

34
00:02:09.358 --> 00:02:12.873
在执行前将其移动到作用域的顶部。
moves them to the top of
the scope before execution.

35
00:02:12.873 --> 00:02:16.724
这就是提升吊升的方式。
That's literally how
hoisting is described.

36
00:02:16.724 --> 00:02:18.334
这不是实际发生的事情。
That's not what actually happens.

37
00:02:18.334 --> 00:02:22.180
JavaScript 实际上不会通过向上移动 vars 来重组代码
JavaScript does not actually reorganize
your code by moving the vars up

38
00:02:22.180 --> 00:02:26.235
我可以向你证明这不是发生的事情
to the top, and here is how I can prove
to you that that's not what happens.

39
00:02:26.235 --> 00:02:30.992
因为，这个神奇的前方是如何运作的呢 ?
Because, how would that magical
look ahead actually work?

40
00:02:30.992 --> 00:02:34.656
当它进入代码的时候它会多么的神奇
How would it magically somehow when
it enters the piece of code for

41
00:02:34.656 --> 00:02:38.651
第一次在第一次通过的时候
the very first time on the very first
pass, magically be able to at it and

42
00:02:38.651 --> 00:02:40.400
只会找到宣言吗
only find that declarations?

43
00:02:40.400 --> 00:02:44.581
您当然不能使用正则表达式，因为 JavaScript
You certainly can't use regular
expressions for that, because JavaScript

44
00:02:44.581 --> 00:02:48.581
是一种非正则语言，所以正则表达式不够好。
is a non-regular language so
regular expressions aren't good enough.

45
00:02:48.581 --> 00:02:52.490
那么你要怎么弄清楚那些 vars 是什么地方
So, how are you going to figure
out where all the vars are?

46
00:02:52.490 --> 00:02:55.491
你要做一些非常精细的处理
You're gonna do some very
sophisticated processing

47
00:02:55.491 --> 00:02:59.834
在该块中稍后出现的标记上，直到找到块的末尾。
on the tokens that come later in that
block until you find the end of the block.

48
00:02:59.834 --> 00:03:02.927
然后那些地方可能发生了声明
And then any of those places where
a declaration could have occurred,

49
00:03:02.927 --> 00:03:06.661
然后你就可以把它们拉出来，理论上你可以重新安排和移动这些
then you can pull those out, and you could
theoretically rearrange and move those.

50
00:03:06.661 --> 00:03:11.812
猜猜这个神奇的处理方法会叫什么
And guess what that magical,
fancy processing would be called?

51
00:03:11.812 --> 00:03:14.201
正在解析，好吗 ?
Parsing, okay?

52
00:03:14.201 --> 00:03:16.824
这叫解析
That's called parsing.

53
00:03:16.824 --> 00:03:20.771
如果你想在街区里找到变量声明
If you wanna find the variable
declarations further down in the block,

54
00:03:20.771 --> 00:03:23.219
你唯一能做的就是解析
the only way you can do
that is with parsing.

55
00:03:23.219 --> 00:03:28.276
所以起重并不是一件事情，它是一个简写，一个我们可以用来
So hoisting isn't really a thing, it is a
shorthand, a convention that we can use to

56
00:03:28.276 --> 00:03:33.280
在不需要了解细节的情况下去描述一些事情
try to describe something without needing
to get into the nitty-gritty details.

57
00:03:33.280 --> 00:03:39.751
我不是说这件事很糟糕但很普遍
I'm not saying that it is a bad thing but
what has been rather prevalent,

58
00:03:39.751 --> 00:03:45.603
如我所见，我甚至无法计算 Stack Overflow 的数量。
as I have seen, in, I can't even
count how many Stack Overflow.

59
00:03:45.603 --> 00:03:49.581
当人们问为什么 JavaScript 要做什么
When people asks questions about why
JavaScript is doing something and

60
00:03:49.581 --> 00:03:53.497
看起来很奇怪或者坏了他们发布了一些代码示例
it seems like it's weird or broken,
and they post some code example.

61
00:03:53.497 --> 00:03:56.763
然后有人说这是因为举升的原因
And then somebody says, well,
it's because of the hoisting, and

62
00:03:56.763 --> 00:03:58.377
然后这个人说，好的。
then this person says, Okay.

63
00:03:58.377 --> 00:04:02.213
结果证明他们错了。
And then it turns out
that they're just wrong.

64
00:04:02.213 --> 00:04:03.829
这对你来说可能很意外
This may be surprising to you, but

65
00:04:03.829 --> 00:04:06.237
你知道 Stack Overflow的问题吗
did you know that stuff is
wrong on Stack Overflow?

66
00:04:06.237 --> 00:04:07.176
>> 扬声器 1: [INAUDIBLE]。
&gt;&gt; Speaker 1: [INAUDIBLE].

67
00:04:07.176 --> 00:04:08.096
>> 凯尔 - 辛普森: 是的，令人震惊，
&gt;&gt; Kyle Simpson: Yes, shocking,

68
00:04:08.096 --> 00:04:11.718
我应该给你警告下才会掉下这枚知识炸弹
I should have given you warning
before dropping that knowledge bomb.

69
00:04:11.718 --> 00:04:16.346
这是一个事实， Stack Overflow 中存在人员，
This is a fact, there are posts on
Stack Overflow where people have

70
00:04:16.346 --> 00:04:20.744
问了关于我的书的问题你不懂 JS
asked questions about my books,
the You Don't Know JS books.

71
00:04:20.744 --> 00:04:25.305
在其中一个岗位上，很多人，但是在我找到的其中一个职位上，
And on one of those posts, many of them,
but on one of these posts that I found,

72
00:04:25.305 --> 00:04:28.143
这个人说凯尔是什么意思
this person said,
what does Kyle mean when, and

73
00:04:28.143 --> 00:04:31.552
他引述了我在书中所说的一段话。
he quoted some passage that I
was talking about in my book.

74
00:04:31.552 --> 00:04:36.423
我尽量去 Stack Overflow 去检查这些，但是
I try as much as possible on Stack
Overflow to go in and check for these, but

75
00:04:36.423 --> 00:04:40.745
有太多太多的问题我已经失去了对这些问题的关注
there's too many and I have lost
track of triaging questions on,

76
00:04:40.745 --> 00:04:44.536
已使用 " 不了解 JS " 或 " YDKJS" 进行标记。
that have been tagged with
You Don't Know JS, or YDKJS.

77
00:04:44.536 --> 00:04:48.744
所以，我在这个职位上跑了一次，所以这是个问题。
So, I ran across this post-one time,
and so here's this question.

78
00:04:48.744 --> 00:04:53.012
我是写这本书的人我的名字写在书上
And I'm the one that wrote the book,
my name is on the book.

79
00:04:53.012 --> 00:04:57.497
地球上没有人能更权威地处理
There is nobody on the planet that is more
authoritative on the question of what did

80
00:04:57.497 --> 00:04:58.343
我的意思是
I mean than me.

81
00:04:58.343 --> 00:05:00.577
>> 演讲者 2: [LAUGH] >> 凯尔 - 辛普森: 我们能同意吗 ?
&gt;&gt; Speaker 2: [LAUGH]
&gt;&gt; Kyle Simpson: Can we agree with that?

82
00:05:00.577 --> 00:05:01.146
>> 演讲者 2: 好的地方。
&gt;&gt; Speaker 2: Good point, there.

83
00:05:01.146 --> 00:05:03.192
>> 凯尔 - 辛普森: 好吗 ?
&gt;&gt; Kyle Simpson: Okay?

84
00:05:03.192 --> 00:05:07.120
我对 JavaScript 的错误是否是一个单独的问题，但是
Whether I'm wrong about JavaScript
is a separate issue, but

85
00:05:07.120 --> 00:05:10.757
我是说我是那个规范的权威
what I mean,
I'm the authoritative on the spec, okay?

86
00:05:10.757 --> 00:05:13.586
>> 扬声器 2: [LAUGH] >> 凯尔 - 辛普森: 其他人回答了
&gt;&gt; Speaker 2: [LAUGH]
&gt;&gt; Kyle Simpson: Somebody else answered

87
00:05:13.586 --> 00:05:17.134
问题是他们完全错了
the question, and
they were completely wrong.

88
00:05:17.134 --> 00:05:20.939
完全错误的是 100% 。
Just 100% totally wrong.

89
00:05:20.939 --> 00:05:24.814
我不觉得，我不喜欢那个人，人犯错误，
I don't feel, I'm not like down on
that person, people make mistakes,

90
00:05:24.814 --> 00:05:26.505
他们不懂的东西
they don't understand stuff.

91
00:05:26.505 --> 00:05:31.694
但这里的情况是如此的不正常，绿色的复选标记和超过 4000 个的上传。
But here's what was so demoralizing, the
green check mark and over 4000 uploads.

92
00:05:31.694 --> 00:05:36.432
即使我把我的小答案发布到现在也有 17 个上传
Even when I post my little answer
there is now like 17 uploads,

93
00:05:36.432 --> 00:05:39.518
它永远不会被任何人看到
it's never going to get seen by anybody.

94
00:05:39.518 --> 00:05:41.634
所以你不能永远相信你在足球名单上读到的东西
So you can't always trust
what you read on Soccer List.

95
00:05:41.634 --> 00:05:44.312
对不起这小的小问题好吗
Sorry for that little digression, okay?

96
00:05:44.312 --> 00:05:44.899
>> 扬声器 3: 我们可以帮助您。
&gt;&gt; Speaker 3: We can help you.

97
00:05:44.899 --> 00:05:47.475
我们都能投票给你
We can all upvote you.

98
00:05:47.475 --> 00:05:50.004
>> 凯尔 - 辛普森: 是的，我们可以得到 100 张选票 [LAUGH ] 。
&gt;&gt; Kyle Simpson: Yeah,
we can get 100 more votes [LAUGH].

99
00:05:50.004 --> 00:05:51.329
这不可能让我到 4000人
It's not gonna get me to 4000.

100
00:05:51.329 --> 00:05:54.976
但不管怎么说我所做的就是很多问题
But anyway, so, the point that I was
making is there's lots of questions where

101
00:05:54.976 --> 00:05:58.733
人们会问关于这件事的问题他们会说我是
people will ask questions about this
whole hoisting thing, and they'll say I'm

102
00:05:58.733 --> 00:06:02.067
很沮丧因为这不是正确的方法或者我是什么
frustrated because this doesn't seem
to work the right way or what am I.

103
00:06:02.067 --> 00:06:06.903
有人会回答这个问题他们会用吊起
And somebody will answer it and
they'll use hoisting, and

104
00:06:06.903 --> 00:06:09.619
它会使不准确的情况永久化
it will perpetuate inaccuracy.

105
00:06:09.619 --> 00:06:14.100
不是吊装对你没有帮助，但是当你用吊装的时候，
It is not that hoisting is unhelpful
to you, but when you use hoisting, and

106
00:06:14.100 --> 00:06:18.867
你不知道这些细节你不知道到底发生了什么
you don't know the nuances, and
you don't know what's actually happening,

107
00:06:18.867 --> 00:06:22.519
那你就会被误导了
then you actually get misled
into thinking the wrong thing.

108
00:06:22.519 --> 00:06:25.608
这就是我第一次教你这样做的原因
Which is why I first taught
you ow it really works, and

109
00:06:25.608 --> 00:06:30.213
我们如何回到更速记的定义上
how we're circling back to the more
shorthand definition, because armed with

110
00:06:30.213 --> 00:06:34.629
这两个你以后都可以保证你不会搞糊涂的。
both of those, you can make sure in
the future that you don't get confused.

111
00:06:34.629 --> 00:06:39.591
但只携带有吊重的武器只需要几行代码
But armed only with hoisting,
it only takes a few lines of code for

112
00:06:39.591 --> 00:06:41.680
我把开发商搞糊涂了
me to confuse a developer.

113
00:06:41.680 --> 00:06:44.620
所以这件案子不是被搬上来的
So it is not the case
that these get moved up,

114
00:06:44.620 --> 00:06:48.608
就像职能被重新分配一样
just like it is not the case
that functions get reassigned.

115
00:06:48.608 --> 00:06:51.029
如果我们想弄明白它的行为
This code, if we were trying
to figure out what it did,

116
00:06:51.029 --> 00:06:53.781
我们会说根据吊装，这就是它所做的。
we would say according to hoisting,
that this is what it did.

117
00:06:53.781 --> 00:06:58.752
它先移动函数，然后移动变量声明，
It moved the function first, and then
it moved the variable declaration, and

118
00:06:58.752 --> 00:06:59.966
然后它就被处死了
then it executed.

119
00:06:59.966 --> 00:07:05.697
对于完全相同的原因，它不会丢失变量，它不会失去功能。
For the exact same reason it doesn't lose
variables, it doesn't lose functions.

120
00:07:05.697 --> 00:07:11.560
它在第一次传递过程中处理它们，然后执行。
It handle them during the first pass,
and then it execute.

121
00:07:11.560 --> 00:07:15.862
但是，在这张幻灯片上要做的是非常重要的区别。
There is, however, and important
distinction to be made here on this slide,

122
00:07:15.862 --> 00:07:20.504
函数声明和函数表达式之间的差异。
which is the difference between a function
declaration and a function expression.

123
00:07:20.504 --> 00:07:25.997
有几个你在问我们说到错误功能的时候，哎，
A number of you were asking when we were
talking about error functions, hey well,

124
00:07:25.997 --> 00:07:31.348
如果我把我最喜欢的错误函数分配给变量就行了吗
isn't it okay if I just assign my favorite
loving error function to a variable?

125
00:07:31.348 --> 00:07:32.240
还好吗
Is it okay?

126
00:07:32.240 --> 00:07:33.653
嗯。 行吗 ?
Yes.
Will it work?

127
00:07:33.653 --> 00:07:34.432
那得看情况了
It depends.

128
00:07:34.432 --> 00:07:39.266
在此特定示例中，我们具有要移动到顶部的功能，但
In this particular example, we have the
functions having to move to the top, but

129
00:07:39.266 --> 00:07:42.893
请注意第 9 行上的功能分配所发生的情况，
notice what happened to
the function assignment on line 9,

130
00:07:42.893 --> 00:07:45.117
只会在 9 号线路上发生
it's still only happens on line 9.

131
00:07:45.117 --> 00:07:49.040
这意味着第 7 行将抛出类型错误。
Which means that line seven is
going to throw a type error.

132
00:07:49.040 --> 00:07:50.249
那么换句话说，
So in other words,

133
00:07:50.249 --> 00:07:55.308
要使用仅将其分配给属性或变量的函数形式，
to use the form of function where you only
assign it to properties or variables,

134
00:07:55.308 --> 00:07:59.629
您必须先定义所有功能，然后才能对其进行调用。
you have to have all of your functions
defined before you call them.

135
00:07:59.629 --> 00:08:00.934
有些人喜欢这样
Some people like that.

136
00:08:00.934 --> 00:08:05.185
事实上，我的发展生涯可能已经超过 15 年了，
As a matter of fact, for probably more
than 15 years of my development career,

137
00:08:05.185 --> 00:08:06.259
我就是这么做的
I did exactly that.

138
00:08:06.259 --> 00:08:10.509
可能是因为我的编程语言很像 C
Probably because I have roots
in programming languages like C.

139
00:08:10.509 --> 00:08:14.043
我习惯了我所有的功能都在上面
I got used to the habit of having
all my functions at the top, and

140
00:08:14.043 --> 00:08:16.201
我的所有可执行代码都在底部
all my executable code at the bottom.

141
00:08:16.201 --> 00:08:20.036
有一天，大约五年，六年前，大概七年前
And one day, about five, six years ago,
maybe almost seven years ago at this

142
00:08:20.036 --> 00:08:24.050
啊，我一天就知道了，为什么我要把所有的职能都放在上面，
point, it just dawned on my one day, why
am I putting all my functions at the top,

143
00:08:24.050 --> 00:08:25.997
然后每次我打开这个文件
and then every time I open up this file,

144
00:08:25.997 --> 00:08:29.747
在找到可执行代码之前，我要滚动 3000 行吗 ?
I've gotta scroll 3,000 lines before
I can find my executable code?

145
00:08:29.747 --> 00:08:32.452
我为什么不能把那个代码放在上面
Why can't I just put that code at the top,
so

146
00:08:32.452 --> 00:08:35.027
在我打开文件的时候就在那儿吗
it's right there when I open up the file?

147
00:08:35.027 --> 00:08:37.022
这很明显是密码的作用。
And it's real obvious what the code does.

148
00:08:37.022 --> 00:08:40.022
如果我需要看看这些功能，他们还在那里，但是
If I need to look at the functions,
they're still there, but

149
00:08:40.022 --> 00:08:42.052
我想轻松找到可执行代码
I wanna find the executable code easily.

150
00:08:42.052 --> 00:08:45.773
在底部发现它比在顶部找到它要困难得多。
And finding it at the bottom is a lot
of harder than finding it at the top.

151
00:08:45.773 --> 00:08:49.359
所以我就开始把所有功能放在任何范围的底部。
And so I just started putting all
the functions at the bottom of any scope.

152
00:08:49.359 --> 00:08:53.613
我不仅在最重要的范围内这样做，而且在范围内也是这样做的。
And not only do I do that in the top
scope, but I also do that within scopes.

153
00:08:53.613 --> 00:08:55.654
我把可执行代码放在最上面
I put the executable code at the top, and

154
00:08:55.654 --> 00:08:58.009
我把功能声明放在底部
I put my function
declarations at the bottom.

155
00:08:58.009 --> 00:09:01.995
我利用功能提升的优势
And I take advantage of
the fact that functions hoist.

156
00:09:01.995 --> 00:09:03.001
他们在吊重机对吧
They hoist, right?

157
00:09:03.001 --> 00:09:07.234
它们是在编译时进行的，以这样定义的方式进行定义
They are taken at compile time and
defined in such a way so

158
00:09:07.234 --> 00:09:13.373
他们可以在比他们被宣布的范围更早地使用
that they can be used even earlier in
the scope than when they've been declared.

159
00:09:13.373 --> 00:09:17.594
所以有很多很多人说 JavaScript 吊起
So there are many, many people that
say that JavaScript's hoisting

160
00:09:17.594 --> 00:09:21.610
这个机制是一个坏的，设计不好的，模糊的一部分。
mechanism is a bad, poorly designed,
buggy part of the system.

161
00:09:21.610 --> 00:09:25.682
这就是为什么 JavaScript 不符合词汇限定语言的原因
And it's why JavaScript doesn't qualify
as a lexically scoped language because of

162
00:09:25.682 --> 00:09:28.969
我们不应该用它，也不应该依赖它。
hoisting, and we shouldn't use it,
and shouldn't rely upon it.

163
00:09:28.969 --> 00:09:32.524
和大多数事情一样它取决于
And as with most things, it kinda depends,

164
00:09:32.524 --> 00:09:38.110
取决于你对你要完成的事情的看法
it depend on your perspective of
what you're trying to accomplish.

165
00:09:38.110 --> 00:09:40.759
有时吊装是不好的，
It is sometimes the case
that hoisting is bad, and

166
00:09:40.759 --> 00:09:43.289
有时我觉得这很有用
sometimes the case I
think it's quite useful.
