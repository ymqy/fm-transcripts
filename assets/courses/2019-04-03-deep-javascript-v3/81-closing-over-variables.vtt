WEBVTT

1
00:00:00.340 --> 00:00:02.790
>> 凯尔 - 辛普森: 这是一个例子
&gt;&gt; Kyle Simpson: Here's
an example that tries to

2
00:00:02.790 --> 00:00:04.679
指出这不是一个快照
point out that it's not a snapshot.

3
00:00:04.679 --> 00:00:08.500
这也是开发者似乎一直感到沮丧的其中之一。
And this is one of the perpetual
frustrations that developers seem to have.

4
00:00:08.500 --> 00:00:12.660
他们知道这个想法，好封闭，然后马上就跳了
They get this idea, okay closure,
but then they immediately jump

5
00:00:12.660 --> 00:00:17.140
这意味着我将会有一个价值
to the assumption that that means
that I'm snapshoting a value.

6
00:00:17.140 --> 00:00:20.250
我正在捕捉一些有价值的信息
That I'm capturing some
value at some moment.

7
00:00:20.250 --> 00:00:23.469
这不是关闭的原因。
That is not what closure is.

8
00:00:23.469 --> 00:00:28.050
事实上，关闭与这些价值根本没有关系。
Closure has not got anything to do with
the values at all, as a matter of fact.

9
00:00:28.050 --> 00:00:30.269
您不会关闭值。
You don't close over a value.

10
00:00:30.269 --> 00:00:33.219
我在博客和书中见过无数次
I've seen that countless
times in blogs and books.

11
00:00:33.219 --> 00:00:34.810
没有这样的事情，胡说八道，
There is no such thing, that is nonsense,

12
00:00:34.810 --> 00:00:37.159
没有关闭一个价值的东西
there's no such thing as
closing over a value.

13
00:00:37.159 --> 00:00:41.500
您可以关闭变量，这意味着您与该变量具有链接。
You close over a variable, which means
you have a linkage to that variable.

14
00:00:41.500 --> 00:00:43.689
当你进入它的时候
Which means at the time you access it,

15
00:00:43.689 --> 00:00:49.299
你可以看到任何变量在那一刻所产生的价值，而不是以前的。
you're seeing whatever value that variable
has at that moment, not it had before.

16
00:00:49.299 --> 00:00:53.170
在此示例中，当我在第 3 行上创建 myTeacher 函数时，
Here in this example when I create
the myTeacher function on line 3,

17
00:00:53.170 --> 00:00:56.509
那一刻老师的价值是凯尔的
at that moment teacher has the value Kyle.

18
00:00:56.509 --> 00:00:59.969
后来我改变了老师对苏西的价值
And then later I change
teacher to the value Suzy.

19
00:00:59.969 --> 00:01:05.125
然后当我执行它要打印的功能时，第 9 行吗 ?
And then line 9 when I execute
the function what's it gonna print?

20
00:01:05.125 --> 00:01:10.530
不是凯尔，我们没有接近凯尔的价值，我们关闭了变量老师。
Not Kyle, we didn't close over the value
Kyle, we closed over the variable teacher.

21
00:01:10.530 --> 00:01:15.019
当我们执行这一功能时，我们会获得它的价值。
And when we execute that function,
we're gonna access the value of it.

22
00:01:15.019 --> 00:01:19.260
它是对您关闭的所有变量的实时链接。
It is a live link to all the variables
that you are closed over.

23
00:01:19.260 --> 00:01:21.849
所以不要把关闭视为捕获值，
So don't think of closure
as capturing values,

24
00:01:21.849 --> 00:01:24.382
将其视为保留对变量的访问权。
think of it as preserving
access to variables.

25
00:01:28.599 --> 00:01:31.617
>> 凯尔 - 辛普森: 最经典的人最经典的地方
&gt;&gt; Kyle Simpson: The place where this
bites people the most, the most classic

26
00:01:31.617 --> 00:01:35.759
规范示例，每当您尝试在 for 循环中创建闭包，或
canonical example, is whenever you try to
create closures inside of a for loop, or

27
00:01:35.759 --> 00:01:38.299
任何循环机构的内部。
inside of any kind of looping mechanism.

28
00:01:38.299 --> 00:01:41.689
通常不与计时器有关，但这只是一个方便的插图。
Not usually with timers, but that's
just a convenient illustration here.

29
00:01:41.689 --> 00:01:45.566
通常，它就像将单击处理程序指定给一组按钮以进行
Normally it's like assigning click
handlers to an array of buttons for

30
00:01:45.566 --> 00:01:46.152
示例。
example.

31
00:01:46.152 --> 00:01:51.865
并且这个函数是在每个迭代中创建的，它具有外观
And this function, that is being created
in each iteration, it has the appearance

32
00:01:51.865 --> 00:01:56.531
每一个迭代中的值都要接近我的值。
that what it's doing is closing
over the i value in each iteration.

33
00:01:56.531 --> 00:02:01.022
所以我们希望它能打印出我的 1
So we're expecting it to print out i 1,
i 2, i 3, but

34
00:02:01.022 --> 00:02:04.290
当我们把它打印出来的时候就有四，四，四，四，四，四，四，
when we run it it prints out 4, 4, 4.

35
00:02:04.290 --> 00:02:05.290
为甚么呢 ?
Why?

36
00:02:05.290 --> 00:02:07.409
库兹只有一个我的变量
Cuz there's only one i variable.

37
00:02:08.879 --> 00:02:13.099
第 1 行有一个变量只有一个变量
There's an i variable on line 1 and
there's only one of them, and

38
00:02:13.099 --> 00:02:15.060
我们有三个功能
we have three functions.

39
00:02:15.060 --> 00:02:19.129
如果我们想有三个不同的价值观，我们需要多少变数呢 ?
If we wanted to have three separate
values, how many variables would we need?

40
00:02:21.509 --> 00:02:22.770
这不是很难的数学。
This is not hard math.

41
00:02:22.770 --> 00:02:25.479
如果我们想要三个不同的值，我们需要多少个变量 ?
If we wanted three separate values,
how many variables do we need?

42
00:02:25.479 --> 00:02:27.039
我们需要三个变量对吧
We need three variables, right?

43
00:02:27.039 --> 00:02:31.289
而且只有一个，当然它只能有一个价值。
And there's only one, so
of course it can only have the one value.

44
00:02:31.289 --> 00:02:36.192
在这种情况下它会有一个价值
And in this case,
it's gonna have the value that occurs

45
00:02:36.192 --> 00:02:40.163
在循环的末尾，是值 4。
at the end of the loop,
which is the value 4.

46
00:02:40.163 --> 00:02:44.699
我们不能有效地使用封闭装置直到我们独立
We can't effectively use closure
until we separate ourselves from that

47
00:02:44.699 --> 00:02:46.867
捕获值的感知。
perception of capturing values.

48
00:02:46.867 --> 00:02:51.360
它没有捕获值，保留对变量的访问权 ?
It's not capturing a value,
preserving access to a variable, okay?

49
00:02:51.360 --> 00:02:55.509
因此，如果我们想解决这个问题，
So, if we wanted to solve this problem,
and

50
00:02:55.509 --> 00:03:00.430
我们分析了，我需要单独的变量，我们已经看到
we analyzed that,
I need separate variables, we've seen

51
00:03:00.430 --> 00:03:06.126
如何创建变量的多个不同示例。
several multiple different examples
of how to create variables.

52
00:03:06.126 --> 00:03:10.069
如果要创建多个同名变量，请执行以下步骤 :
If we wanna create more than one
variable with the same name,

53
00:03:10.069 --> 00:03:12.400
我们需要做新的工作对吧
we need to make new scopes, right?

54
00:03:12.400 --> 00:03:16.250
所以我们可以在这里做一个很重要的工作，但现在我们有了 6 个展览，
So we could do an iffy here, but the much
more common way now that we have ES six,

55
00:03:16.250 --> 00:03:17.810
现在我们有了封锁范围
now that we have blockscoping,

56
00:03:17.810 --> 00:03:22.530
只是在迭代中粘贴块作用域声明。
is to just stick a block scoped
declaration in the iteration.

57
00:03:22.530 --> 00:03:27.639
因此，现在，让 j 在每次 4 循环迭代时运行。
So now let j is going to run
every time the 4 loop iterates.

58
00:03:27.639 --> 00:03:31.579
它将在这个循环的整个新迭代中创造一个全新的 j
And it's gonna create a whole new j in
that whole new iteration of the loop.

59
00:03:32.740 --> 00:03:37.319
当我们在第 4 行上结束时，我们正在关闭一个全新的 j。
When we close over it on line 4,
we are closing over a whole new j.

60
00:03:38.579 --> 00:03:43.853
有三个单独的 js ，因此，我们会获得其中 1， 2和 3的值。
There are three separate js and therefore
we get the values in them 1, 2, and 3.

61
00:03:43.853 --> 00:03:48.468
请参阅 " 捕获值 " 和 " 结束变量" 之间的差异 ?
See the difference between capturing
a value and closing over a variable?

62
00:03:48.468 --> 00:03:52.995
我觉得有些人甚至会说更棘手的问题
It turns out there's an even, I think
better some people might say trickier, but

63
00:03:52.995 --> 00:03:56.509
有更好的办法解决这个问题
there's an even better way
of solving this problem.

64
00:03:56.509 --> 00:04:01.199
因为我一直在为 var i 和
Because that perpetual problem
of I'm doing for var i and

65
00:04:01.199 --> 00:04:03.599
我的关闭不是在捕捉价值
my closures aren't capturing the value.

66
00:04:03.599 --> 00:04:07.960
这对 JavaScript 开发者造成了 20 年的问题。
That's been a problem for
JavaScript developers for like 20 years.

67
00:04:09.069 --> 00:04:12.997
他们决定用 iOS 6 来决定我们为什么不去
They decided with iOS six, well,
why don't we just go ahead and

68
00:04:12.997 --> 00:04:15.394
所以如果你想让你的人
make it so
that if you use a let on your for

69
00:04:15.394 --> 00:04:19.201
循环，我们将自动为每个迭代创建一个新的 i 。
loop we'll automatically create
a new i for each iteration.

70
00:04:19.201 --> 00:04:22.704
而不是仅仅创造一个属于全人类的
Instead of creating just one
that belongs to the whole for

71
00:04:22.704 --> 00:04:26.437
在这里每次迭代都有一个全新的全新 i
loop here there's gonna be
a brand new i for each iteration.

72
00:04:26.437 --> 00:04:32.560
这意味着闭关闭厂好吗
Which means the closure
just magically works, okay?

73
00:04:32.560 --> 00:04:37.149
重点是您需要对您关闭多个不同值
The point is if you need multiple
different values being closed over you

74
00:04:37.149 --> 00:04:38.379
需要多个不同的变量。
need multiple different variables.

75
00:04:39.949 --> 00:04:43.106
您需要关闭不同的变量，而不是尝试捕获值。
You need to close over different
variables, not try to capture values.

76
00:04:46.259 --> 00:04:46.935
>> 凯尔 - 辛普森: 是吗 ?
&gt;&gt; Kyle Simpson: Yes?

77
00:04:46.935 --> 00:04:49.463
>> 扬声器 2: 所以，我实际上是在里面定义的，
&gt;&gt; Speaker 2: So,
the i is defined actually inside,

78
00:04:49.463 --> 00:04:55.490
虽然是这样写的，但是它实际上是在块里面定义的吗 ?
even though it's written this way, but is
it actually then defined inside the block?

79
00:04:55.490 --> 00:04:56.529
这就是它的本质吗
Is that basically what it is?

80
00:04:56.529 --> 00:05:00.021
>> 键盘 Simpson: 是，它被解释为每个迭代都有一个新的
&gt;&gt; Kyle Simpson: Yes, it is interpreted
as if each iteration there's a new

81
00:05:00.021 --> 00:05:04.653
声明 i，并且 JavaScript 负责为其指定值
declaration of i, and JavaScript takes
care of assigning it the value that it

82
00:05:04.653 --> 00:05:08.310
它的表弟在上一次迭代结束时就有了
had that its cousin had at the end
of the previous iteration.

83
00:05:08.310 --> 00:05:10.290
把所有东西都给你
It wires up all that stuff for you.

84
00:05:10.290 --> 00:05:12.839
>> 扬声器 3: 是否还有其他情况适用，或者
&gt;&gt; Speaker 3: Is there any other
case were that applies as well or

85
00:05:12.839 --> 00:05:13.839
是唯一的吗
is that the only one?

86
00:05:14.899 --> 00:05:19.332
>> 凯尔 - 辛普森: 所有 for 循环表单都有一个方差。
&gt;&gt; Kyle Simpson: All of the for
loop forms have a for let variance.

87
00:05:19.332 --> 00:05:23.567
所以在这里我们得让他知道
So for here, we have for let of.

88
00:05:23.567 --> 00:05:28.358
我们已经允许， >> 演讲者 4: 每个人 ?
We have let,
&gt;&gt; Speaker 4: Each?

89
00:05:28.358 --> 00:05:30.555
>> Kyle Simpson: 嗯，对于每个都不是语法形式。
&gt;&gt; Kyle Simpson: Well, for
each isn't a syntactic form.

90
00:05:30.555 --> 00:05:33.954
这是一个迭代器，所以你已经有了这个功能。
That's a iterator, so
you already get a function with that one.

91
00:05:35.581 --> 00:05:40.316
>> Kyle Simpson: [COUGH] 但是对，对于，对于这三种语法而言，
&gt;&gt; Kyle Simpson: [COUGH] But yeah, for,
for of, and for in, those three syntactic

92
00:05:40.316 --> 00:05:45.240
对于循环，自动在迭代中进行其任务。
for loops automatically make their
thing inside of the iteration.

93
00:05:50.062 --> 00:05:52.117
>> 凯尔 - 辛普森: 顺便说一下，
&gt;&gt; Kyle Simpson: By the way,
just as a little tiny detail,

94
00:05:52.117 --> 00:05:54.480
不是很多人都要穿过这条
not that many people
are gonna run across this.

95
00:05:54.480 --> 00:05:56.769
但如果你想用一个公寓
But if you did try to use a const there,

96
00:05:56.769 --> 00:06:01.238
您将会收到错误，因为 i++ 正在尝试修改变量。
you're gonna get an error because that
i++ is trying to modify the variable.

97
00:06:03.420 --> 00:06:05.196
因此，您需要使用 let。
So here you would need to use a let.

98
00:06:05.196 --> 00:06:10.759
所以封闭才是
So closure is a preservation
of the linkage

99
00:06:10.759 --> 00:06:15.310
变量，而不是值的捕获。
to a variable,
not the capturing of the value.
