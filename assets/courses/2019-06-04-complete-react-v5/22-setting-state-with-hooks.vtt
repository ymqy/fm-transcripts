WEBVTT

1
00:00:00.120 --> 00:00:02.355
>> Brian Holt: 我希望您尝试输入此内容。
&gt;&gt; Brian Holt: I want you to try and
type into this.

2
00:00:06.921 --> 00:00:09.439
>> Brian Holt: 恭喜，您打破了 DOM。
&gt;&gt; Brian Holt: Congratulations,
you broke the DOM.

3
00:00:09.439 --> 00:00:11.330
这其实挺难做的对吧
This is actually kinda difficult to do,
right?

4
00:00:11.330 --> 00:00:15.429
[ LAUGH] 这是人们第一次出现的挫折感
[LAUGH] And this is one of people's
frustrations when they first

5
00:00:15.429 --> 00:00:19.780
学习写 React 就像以前这么简单
learn to write React is like,
this was so simple to do before.

6
00:00:19.780 --> 00:00:22.600
我们为什么要做些简单的事情
Why did we make something simple hard?

7
00:00:22.600 --> 00:00:25.629
对，说的是有效的。
Right, it's a valid thing to say.

8
00:00:25.629 --> 00:00:28.969
但我想让你想想这事是怎么运作的
But I want you to think
about how this works.

9
00:00:30.579 --> 00:00:32.030
每当我在这里输入某样东西
Whenever I type something in here, so

10
00:00:32.030 --> 00:00:37.640
如果我现在按下一个按键，会发生什么 " 反应 " 会捕捉到这个事件。
if I hit a keystroke right now,
what happens is React captures that event.

11
00:00:37.640 --> 00:00:41.850
然后，它的组件中的再渲染循环会发生什么。
Then what happens is that kicks off a
re-render cycle inside of its components.

12
00:00:42.920 --> 00:00:46.179
所以，第一个发生的事情是重新呈现应用程序。
So the first thing that
happens is it re-renders app.

13
00:00:46.179 --> 00:00:50.159
然后它做了一个 SearchParams ，它会跳到搜索参数中。
And then it gets done a SearchParams and
it hops down into search params.

14
00:00:50.159 --> 00:00:53.826
这里说的是公寓等于西雅图华盛顿
Here, it says const location
equals Seattle, Washington.

15
00:00:53.826 --> 00:00:59.350
它重新呈现，这个输入的价值是什么 ?
And it re-renders, and what is
the value of this input right here?

16
00:01:01.520 --> 00:01:02.799
西雅图对吧
Seattle, right?

17
00:01:02.799 --> 00:01:04.349
没什么变化对吧
Nothing changes that, right?

18
00:01:04.349 --> 00:01:08.739
所以当它重新呈现时，仍然是西雅图的原因，因为什么都没有改变。
So when it re-renders again, it's still
Seattle's because nothing changed it.

19
00:01:08.739 --> 00:01:14.379
所以这就是为什么，即使我在那里，也没有改变。
So that's why, even when I type in there,
it's not changing.

20
00:01:14.379 --> 00:01:15.569
那么换句话说，
So in other words,

21
00:01:15.569 --> 00:01:20.280
两种数据绑定在 React 中不可用，这可能是一个沮丧的问题。
two way data binding is not free in React,
which can be a point of frustration.

22
00:01:20.280 --> 00:01:21.890
我以前是个角开发商
I used to be an Angular developer.

23
00:01:21.890 --> 00:01:24.430
我在 Reddit 工作的时候写了很多角度
I wrote a lot of Angular
when I worked at Reddit.

24
00:01:24.430 --> 00:01:27.129
这对我来说是令人沮丧的，因为这对我来说是自由的，对吧 ?
So this was frustrating for me because
this used to be free to me, right?

25
00:01:27.129 --> 00:01:30.760
如果是在 Angular就像他那样做了什么
If, in Angular, just did the NG bind or
something like that and

26
00:01:30.760 --> 00:01:34.099
它只是结合在一起工作和魔法
it was just bound together and
it worked and magical.

27
00:01:34.099 --> 00:01:36.770
这已经不是我的问题了我要为此辩解
That's no longer the case and
I'm gonna argue for that.

28
00:01:36.770 --> 00:01:39.729
这其实是个好处因为它迫使我
It's actually a benefit
because it forces me to

29
00:01:39.729 --> 00:01:41.409
想想那些正在发生的事情
think through everything that's happening.

30
00:01:41.409 --> 00:01:44.789
我不再受限于这个框架会为我做什么。
And I'm no longer limited by what
the framework is gonna do for me.

31
00:01:44.789 --> 00:01:47.210
我必须这样做，我认为这是一个好处，因为后来
I have to do it,
which I think is a benefit because later,

32
00:01:47.210 --> 00:01:51.039
当我回到它的时候我可以读读所有正在发生的事情对吧
when I come back to it, I can read
everything that's happening, right?

33
00:01:51.039 --> 00:01:53.979
我不需要特别了解你的角度，或者我不需要知道什么是 " 超级好 "
I don't have to know Angular super well or
I don't have to know React super well to

34
00:01:53.979 --> 00:01:57.603
知道发生了什么，因为我可以看到所有规范的代码。
know what's happening because I can
see all the code that's governed.

35
00:01:57.603 --> 00:01:59.331
这是非常明确的。
It's very explicit.

36
00:01:59.331 --> 00:02:02.769
这实际上只是一种一般的反应趋势。
This is actually kind of just
a general trend for React.

37
00:02:02.769 --> 00:02:04.060
很详细，对吧 ?
It's verbose, right?

38
00:02:04.060 --> 00:02:06.280
您编写更多代码。
You write more code.

39
00:02:06.280 --> 00:02:07.939
这可能是一个沮丧的问题。
And that can be a point of frustration.

40
00:02:07.939 --> 00:02:11.449
但我认为这其实是 React 最大的好处之一
But I argue that this is actually
one of the biggest benefits of React

41
00:02:11.449 --> 00:02:14.479
因为这是可以理解的对吧
because it's very understandable, right?

42
00:02:14.479 --> 00:02:16.073
它迫使你思考一切
It forces you to think through everything.

43
00:02:16.073 --> 00:02:20.558
这意味着当你一个月后回来的时候你可以重新阅读
Which means that when you come back to
this a month later, you can re-read all

44
00:02:20.558 --> 00:02:24.370
你写的代码明白发生了什么好吗
the code that you wrote and
understand what's happened, okay?

45
00:02:25.689 --> 00:02:30.800
因此，我们希望现在能从西雅图， WA 改变到其他事情。
So we want to be able to change this
now from Seattle, WA to something else.

46
00:02:30.800 --> 00:02:32.439
那么我们要怎么做呢 ?
So how are we going to do that?

47
00:02:34.329 --> 00:02:35.944
那我们来看看吧
Well, let's take a look at that.

48
00:02:39.120 --> 00:02:43.355
>> Brian Holt: 在此处，显示导入 React 的位置
&gt;&gt; Brian Holt: Up here,
where it says import React, for

49
00:02:43.355 --> 00:02:47.844
我我要用逗号了 { useState }
me, I'm gonna put comma, { useState }.

50
00:02:47.844 --> 00:02:49.848
然后我要从雷法进口
Then I'm going to import that from React.

51
00:02:53.430 --> 00:02:58.235
> > Brian Holt: 因此，我要在这里说，
&gt;&gt; Brian Holt: So instead of having
this location here, I'm gonna say const,

52
00:02:58.235 --> 00:03:02.252
方括号，位置，逗号和 setLocation。
square bracket, location,
comma, setLocation.

53
00:03:02.252 --> 00:03:09.532
= useState，然后是缺省状态，即西雅图， WA，
= useState, and then the default state,
which is gonna be Seattle, WA,

54
00:03:17.396 --> 00:03:18.801
>> Brian Holt: 好吗 ?
&gt;&gt; Brian Holt: Okay?

55
00:03:18.801 --> 00:03:23.599
现在，我在此输入中有此位置。
Now, I have this location in this input.

56
00:03:23.599 --> 00:03:24.479
你可能注意到的事情
The thing you might notice,

57
00:03:24.479 --> 00:03:28.719
如果你看这里的控制台，如果我看着控制台，它大概会说，
if you look at the console here, if I look
at the console, it's probably gonna say,

58
00:03:28.719 --> 00:03:31.659
您在没有非更改处理程序的情况下向表单提供了值属性。
you provided a value prop to a form
without a non-change handler.

59
00:03:31.659 --> 00:03:33.408
这就是原因
That's why.

60
00:03:33.408 --> 00:03:37.280
我们要给这个改变处理程序
We're going to give this
a on change handler.

61
00:03:38.889 --> 00:03:43.719
所以我想说改的是花括号
So I'm gonna say on change = curly braces.

62
00:03:43.719 --> 00:03:46.569
我要给它一个小小的功能当一个事件发生时就能运行
I'm going to give it just a tiny function
to run whenever an event happens.

63
00:03:46.569 --> 00:03:52.930
所以我想说只要有一件事
So I'm gonna say,
whenever there is an event,

64
00:03:52.930 --> 00:03:57.865
setLocation 为 e.target 值。
setLocation to be e.target value.

65
00:03:57.865 --> 00:04:03.186
所以这有点有点
[BLANK AUDIO] So this is a little,

66
00:04:03.186 --> 00:04:07.830
小小的功能对吧
little tiny function, right?

67
00:04:07.830 --> 00:04:10.679
它只需要一个活动，所以你可以在那里举办活动，
And all it does it it takes an event,
so you can actually put event there,

68
00:04:10.679 --> 00:04:12.240
如果这让你感觉更好
if that makes you feel better about it.

69
00:04:13.419 --> 00:04:16.839
我只是养成了一个永远的习惯
I just have a habit from
forever that I call events e.

70
00:04:19.110 --> 00:04:20.654
>> Brian Holt: 您可以决定这对您是否有用。
&gt;&gt; Brian Holt: You can decide
if that's useful to you or not.

71
00:04:24.526 --> 00:04:26.603
>> Brian Holt: 如果您已为 jQuery 编写事件处理程序，或者
&gt;&gt; Brian Holt: And if you've ever
written an event handler for jQuery or

72
00:04:26.603 --> 00:04:28.910
就是普通的 JavaScript ，应该是熟悉的，对吧 ?
just normal JavaScript,
that should look familiar, right?

73
00:04:28.910 --> 00:04:30.990
这是一个正常的事件处理程序。
It's a normal-looking event handler.

74
00:04:32.966 --> 00:04:36.821
>> Brian Holt: 另一个问题是，如果您有一行函数
&gt;&gt; Brian Holt: And the other thing is
if you have a single line of a function

75
00:04:36.821 --> 00:04:41.470
使用箭头函数，花括号是可选的。
with an arrow function,
the curly braces are optional.

76
00:04:41.470 --> 00:04:45.028
所以我可以把它放进去，然后它看起来也一样，也很好。
So I could put that, and then it would
look like that, which is fine as well.

77
00:04:52.156 --> 00:04:55.384
>> Brian Holt: 那么现在，任何在此输入中发生更改的时间，
&gt;&gt; Brian Holt: So now, any time that
a change happens in this input,

78
00:04:55.384 --> 00:04:59.500
它会用输入中的任何东西来调用 setLocation 。
it's gonna call setLocation with
whatever is inside of the input.

79
00:05:01.410 --> 00:05:03.699
所以现在如果我回到这里我就开始在这里打字
So now if I go back over here and
I start typing in here,

80
00:05:03.699 --> 00:05:05.904
它就会重新开始工作
it's gonna start working again.

81
00:05:05.904 --> 00:05:08.362
为什么呢
Now, why?

82
00:05:08.362 --> 00:05:15.860
我输入的是重新呈现程序搜索参数重新呈现程序
Well, I type, it kicks off a reRender,
search param reRenders.

83
00:05:15.860 --> 00:05:20.019
然后我把这两件事情都在这里，地点和位置。
And then I have these two things up here,
location and setLocation.

84
00:05:20.019 --> 00:05:25.089
位置将会是位置的当前状态，好吗 ?
Location is going to be the current
state of location, okay?

85
00:05:25.089 --> 00:05:31.129
然后，设置位置是该特定状态的更新程序。
And then set location is an updater for
that particular piece of state.

86
00:05:32.310 --> 00:05:36.379
所以每次那个事件发生的时候，对，我就在里面，
So every time that that event happens,
right, that I type into there,

87
00:05:36.379 --> 00:05:39.949
E 将表示输入中发生的事件。
E is going to represent an event
that happened in the input.

88
00:05:39.949 --> 00:05:44.850
然后我就会打电话给 setLocation
And then I'm gonna call setLocation
with whatever is inside

89
00:05:44.850 --> 00:05:49.670
在那个特定事件中或者在输入的内部
of that particular event,
or inside of that input,

90
00:05:50.970 --> 00:05:55.579
就是要更新我的状态好吗
which is going to update that
state that I'm getting here, okay?

91
00:05:55.579 --> 00:05:57.790
那么当这种重新出现的时候
So then,
when that re-render happens after that,

92
00:05:57.790 --> 00:06:00.949
无论我把它更新成什么样的位置
location is going to now be
whatever I've updated it to be.

93
00:06:02.740 --> 00:06:05.233
现在可以让我感到困惑了，我这里有个字符串，华盛顿西雅图。
Now it can be a little confusing that I
have this string here Seattle, Washington.

94
00:06:05.233 --> 00:06:08.007
很明显那是不改变的
And obviously, that's not changing, but

95
00:06:08.007 --> 00:06:13.192
请记住，这始终是缺省状态，对，第一个状态。
just keep in mind that this is always
the default state, right, the first state.

96
00:06:13.192 --> 00:06:15.478
然后在那之后，它就会成为当时的一切。
And then after that, it'll be
whatever it is at that point in time.

97
00:06:17.990 --> 00:06:21.899
但那是你必须谨记的是
But that's, you have to keep in mind
that that's what happens with these

98
00:06:21.899 --> 00:06:24.860
这些组件的功能是它们运行了很多次，对吗 ?
render functions for these components
is they're run a bunch of times, right?

99
00:06:24.860 --> 00:06:28.180
每次更新应用程序时，它都将重新运行所有呈示。
Every time that you update your
application, it reruns all of the renders.

100
00:06:29.779 --> 00:06:33.769
因此，您希望确保这些功能未在执行
So you want to make sure that
these functions are not doing

101
00:06:33.769 --> 00:06:35.350
什么外来的，对吗 ?
anything extraneous, right?

102
00:06:35.350 --> 00:06:36.800
他们不应该更新任何功能。
They shouldn't be updating any function.

103
00:06:36.800 --> 00:06:39.829
他们不应该有任何类似的副作用
They shouldn't have any like side
effects or anything like that.

104
00:06:39.829 --> 00:06:44.490
你要把它们的重点放在渲染的焦点上，好吗 ?
You want to keep them pretty narrow to
the focus of rendering something, okay?

105
00:06:46.329 --> 00:06:51.552
这是一个钩子，这就是反应术语的存在。
So this is a hook,
that's what the react terminology is here.

106
00:06:51.552 --> 00:06:58.879
还有一件事，你需要遵守钩子，所有钩子都开始使用。
And one thing that you need to abide by
with hooks, all hooks begin with use.

107
00:06:58.879 --> 00:07:03.100
使用状态，使用效果，使用回调，使用备忘录，
Use state, use effect,
use callback, use memo,

108
00:07:03.100 --> 00:07:05.670
所有这些钩子都开始使用了
all that stuff, all hooks begin with use.

109
00:07:05.670 --> 00:07:07.350
即便是定制挂钩之类的
Even the ones like custom hooks,

110
00:07:07.350 --> 00:07:09.639
我们要做一个定制的钩子 [ COUGH]
we're going to make a custom
hook [COUGH] excuse me.

111
00:07:09.639 --> 00:07:12.129
我们要在这里做个定制的钩子
We're going to make a custom
hook here in just a second.

112
00:07:13.769 --> 00:07:16.899
但如果你看到有什么用的话，它是一个钩子。
But if you see use something,
it is a hook.

113
00:07:18.560 --> 00:07:24.600
这就是你的有状态逻辑与 React 有这些挂钩的方式。
So this is how you have stateful
logic with React is with these hooks.

114
00:07:26.199 --> 00:07:32.843
所以现在任何时候都要向你证明
So now at any given time,
just to demonstrate to you,

115
00:07:32.843 --> 00:07:37.865
我就说一个 console.log('state )
I'll just say a console.log('state

116
00:07:37.865 --> 00:07:41.716
位置，位置 )。
of location', location).

117
00:07:45.759 --> 00:07:48.389
>> Brian Holt: 或者更好，我们来做吧。
&gt;&gt; Brian Holt: Or
even better, let's do this.

118
00:07:48.389 --> 00:07:50.144
我们就放个 h1 吧
Let's just put an h1 right here.

119
00:07:53.100 --> 00:07:54.317
>> Brian Holt: 在其中有位置。
&gt;&gt; Brian Holt: That has location in it.

120
00:07:58.134 --> 00:08:01.160
>> Brian Holt: 现在它说西雅图， WA 在那儿，对吧 ?
&gt;&gt; Brian Holt: So now it says Seattle,
WA right there, right?

121
00:08:01.160 --> 00:08:05.290
如果我们开始打字，就会发现它正在和
And if we start typing in there,
notice that it's changing alongside of,

122
00:08:06.490 --> 00:08:09.339
因为每当它重新呈现的时候，它就会输出到那个位置。
because every time it re-renders, right,
it's outputting that location there.

123
00:08:12.689 --> 00:08:20.079
所以我可以把盐湖城放在犹他州
So I could put Salt Lake City, Utah.

124
00:08:20.079 --> 00:08:25.504
>> 扬声器 2: 在此上下文中使用状态与设置状态不同，
&gt;&gt; Speaker 2: Is using state different
than setting state in this context,

125
00:08:25.504 --> 00:08:32.899
那就因为它设定了一个默认值，就在这里。
then, because it's setting a default,
out of the box here.

126
00:08:32.899 --> 00:08:38.299
>> Brian Holt: 是的，那么使用状态就像创建一个挂钩，对吧 ?
&gt;&gt; Brian Holt: Yes, so
useState is like creating a hook, right?

127
00:08:38.299 --> 00:08:42.769
所以，当你回来的时候，你会得到一系列的东西。
So and, when you get back a hook,
you get back an array of two things.

128
00:08:42.769 --> 00:08:45.970
第一件事永远是它的现状。
The first thing is always going
to be the current state of it.

129
00:08:45.970 --> 00:08:48.440
第二件事始终是一个更新的功能
The second thing is always going
to be an updater function for

130
00:08:48.440 --> 00:08:50.850
那个特殊的说法，对吧 ?
that particular piece of statement, right?

131
00:08:50.850 --> 00:08:53.159
因此 useState 会创建挂钩。
So useState creates the hook.

132
00:08:53.159 --> 00:08:56.591
这被称为集合地点，因为我选择这样称呼它，但是
This is called set location because
I chose to call it that, but

133
00:08:56.591 --> 00:08:59.135
您可以完全调用此 updateLocation。
you could totally call
this updateLocation.

134
00:08:59.135 --> 00:09:03.090
它的功能使您能够支持特定事物的更新。
It's a function that gives you back
the updates that particular thing.

135
00:09:03.090 --> 00:09:06.370
我选择总是叫它，因为我可以看到它，但是
I choose to always call it set
because then I can kind of see it, but

136
00:09:06.370 --> 00:09:08.351
这只是我的约定
that's just a convention that I have.

137
00:09:08.351 --> 00:09:13.485
这不是行业最佳做法。
That's not an industry best practice or
anything like that.

138
00:09:13.485 --> 00:09:14.827
这能回答你的问题吗
Does that answer your question?

139
00:09:14.827 --> 00:09:16.873
太酷了
Cool.

140
00:09:16.873 --> 00:09:18.620
我应该打电话给你这对你来说有点怪
I should call out here,
this might look a little weird to you.

141
00:09:18.620 --> 00:09:22.080
这也是一种破坏性的，对，因为我知道这会是一个数组。
This is also destructuring, right,
because I know this is gonna be an array.

142
00:09:22.080 --> 00:09:23.780
这始终支持数组。
This always gives back an array.

143
00:09:23.780 --> 00:09:26.409
我知道第一个项目总是国家
And I know that the first
item is always the state, and

144
00:09:26.409 --> 00:09:28.970
我一直知道第二个项目是 " 更新者 " 功能。
I always know the second item
is the updater function.

145
00:09:28.970 --> 00:09:30.450
这就是为什么这是一个阵列。
So that's why that's an array.

146
00:09:31.799 --> 00:09:33.519
有道理吗
Makes sense?

147
00:09:33.519 --> 00:09:34.163
太酷了
Cool.

148
00:09:38.159 --> 00:09:41.312
> > Brian Holt: 在历史上，如果你一直在写 " React" ，
&gt;&gt; Brian Holt: So historically,
if you've been writing React,

149
00:09:41.312 --> 00:09:45.549
你就得用所谓的 " 设定 " 状态对吧
you would have had to use
something called set state, right?

150
00:09:45.549 --> 00:09:52.049
这就取代了对这些功能组件的设置状态的需求。
This is kind of supplanting the need for
set state for these function components.

151
00:09:52.049 --> 00:09:54.610
我再给你看看怎么做
I will show you later how to do that

152
00:09:54.610 --> 00:09:57.840
因为重要的是它仍然是重做生态系统的一部分
because it's important cuz it's still
very much a part of the React ecosystem.

153
00:09:57.840 --> 00:10:01.029
但现在，这就是用钩子做状态的方法。
But for now,
this is the way to do state with hooks.
